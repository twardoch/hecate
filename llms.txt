This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.build_release/
  src/
    hecate/
      gflseg.d
      hecate_highlight.d
      hecate_highlight.o.warnings.txt
      hecate_main.d
      hecate_main.o.warnings.txt
      hecate_thumbnail.d
      hecate_thumbnail.o.warnings.txt
      video_parser.d
    tools/
      hecate.d
      hecate.o.warnings.txt
  temp/
    hecate-master (1)/
      hecate-master/
        include/
          hecate/
            cc_parser.hpp
            ffmpeg_helper.hpp
            file_helper.hpp
            gapstat.hpp
            gflseg.hpp
            hecate.hpp
            hist_opencv.hpp
            image_metrics.hpp
            knapsack.hpp
            shot_range.hpp
            sort.hpp
            time.hpp
            video_parser.hpp
        src/
          hecate/
            gflseg.cpp
            hecate_highlight.cpp
            hecate_main.cpp
            hecate_thumbnail.cpp
            video_parser.cpp
          tools/
            hecate.cpp
        LICENSE
        Makefile
        Makefile.config
        README.md
    ffmpeg_helper.hpp
    hecate_highlight.cpp
docker/
  base.Dockerfile
  build.sh
  README.md
include/
  hecate/
    cc_parser.hpp
    ffmpeg_helper.hpp
    file_helper.hpp
    gapstat.hpp
    gflseg.hpp
    hecate.hpp
    hist_opencv.hpp
    image_metrics.hpp
    knapsack.hpp
    shot_range.hpp
    sort.hpp
    time.hpp
    video_parser.hpp
src/
  hecate/
    gflseg.cpp
    hecate_highlight.cpp
    hecate_main.cpp
    hecate_thumbnail.cpp
    video_parser.cpp
  tools/
    hecate.cpp
.dccache
LICENSE
Makefile
Makefile.config
null.d
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".build_release/src/hecate/gflseg.d">
.build_release/src/hecate/gflseg.o: src/hecate/gflseg.cpp \
  /usr/local/include/hecate/gflseg.hpp \
  /usr/local/opt/opencv@2/include/opencv2/opencv.hpp \
  /usr/local/opt/opencv@2/include/opencv2/opencv_modules.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/core_c.h \
  /usr/local/opt/opencv@2/include/opencv2/core/types_c.h \
  /usr/local/opt/opencv@2/include/opencv2/core/core.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/version.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/operations.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/mat.hpp \
  /usr/local/opt/opencv@2/include/opencv2/flann/miniflann.hpp \
  /usr/local/opt/opencv@2/include/opencv2/flann/defines.h \
  /usr/local/opt/opencv@2/include/opencv2/flann/config.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc_c.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/types_c.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc.hpp \
  /usr/local/opt/opencv@2/include/opencv2/photo/photo.hpp \
  /usr/local/opt/opencv@2/include/opencv2/photo/photo_c.h \
  /usr/local/opt/opencv@2/include/opencv2/video/video.hpp \
  /usr/local/opt/opencv@2/include/opencv2/video/tracking.hpp \
  /usr/local/opt/opencv@2/include/opencv2/video/background_segm.hpp \
  /usr/local/opt/opencv@2/include/opencv2/features2d/features2d.hpp \
  /usr/local/opt/opencv@2/include/opencv2/objdetect/objdetect.hpp \
  /usr/local/opt/opencv@2/include/opencv2/calib3d/calib3d.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/affine.hpp \
  /usr/local/opt/opencv@2/include/opencv2/ml/ml.hpp \
  /usr/local/opt/opencv@2/include/opencv2/highgui/highgui_c.h \
  /usr/local/opt/opencv@2/include/opencv2/highgui/highgui.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/contrib.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/retina.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/openfabmap.hpp \
  /usr/local/include/hecate/sort.hpp

/usr/local/include/hecate/gflseg.hpp:

/usr/local/opt/opencv@2/include/opencv2/opencv.hpp:

/usr/local/opt/opencv@2/include/opencv2/opencv_modules.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/core_c.h:

/usr/local/opt/opencv@2/include/opencv2/core/types_c.h:

/usr/local/opt/opencv@2/include/opencv2/core/core.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/version.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/operations.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/mat.hpp:

/usr/local/opt/opencv@2/include/opencv2/flann/miniflann.hpp:

/usr/local/opt/opencv@2/include/opencv2/flann/defines.h:

/usr/local/opt/opencv@2/include/opencv2/flann/config.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc_c.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/types_c.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc.hpp:

/usr/local/opt/opencv@2/include/opencv2/photo/photo.hpp:

/usr/local/opt/opencv@2/include/opencv2/photo/photo_c.h:

/usr/local/opt/opencv@2/include/opencv2/video/video.hpp:

/usr/local/opt/opencv@2/include/opencv2/video/tracking.hpp:

/usr/local/opt/opencv@2/include/opencv2/video/background_segm.hpp:

/usr/local/opt/opencv@2/include/opencv2/features2d/features2d.hpp:

/usr/local/opt/opencv@2/include/opencv2/objdetect/objdetect.hpp:

/usr/local/opt/opencv@2/include/opencv2/calib3d/calib3d.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/affine.hpp:

/usr/local/opt/opencv@2/include/opencv2/ml/ml.hpp:

/usr/local/opt/opencv@2/include/opencv2/highgui/highgui_c.h:

/usr/local/opt/opencv@2/include/opencv2/highgui/highgui.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/contrib.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/retina.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/openfabmap.hpp:

/usr/local/include/hecate/sort.hpp:
</file>

<file path=".build_release/src/hecate/hecate_highlight.d">
.build_release/src/hecate/hecate_highlight.o: \
  src/hecate/hecate_highlight.cpp /usr/local/include/hecate/hecate.hpp \
  /usr/local/include/hecate/sort.hpp /usr/local/include/hecate/time.hpp \
  /usr/local/include/hecate/gapstat.hpp \
  /usr/local/opt/opencv@2/include/opencv2/opencv.hpp \
  /usr/local/opt/opencv@2/include/opencv2/opencv_modules.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/core_c.h \
  /usr/local/opt/opencv@2/include/opencv2/core/types_c.h \
  /usr/local/opt/opencv@2/include/opencv2/core/core.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/version.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/operations.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/mat.hpp \
  /usr/local/opt/opencv@2/include/opencv2/flann/miniflann.hpp \
  /usr/local/opt/opencv@2/include/opencv2/flann/defines.h \
  /usr/local/opt/opencv@2/include/opencv2/flann/config.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc_c.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/types_c.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc.hpp \
  /usr/local/opt/opencv@2/include/opencv2/photo/photo.hpp \
  /usr/local/opt/opencv@2/include/opencv2/photo/photo_c.h \
  /usr/local/opt/opencv@2/include/opencv2/video/video.hpp \
  /usr/local/opt/opencv@2/include/opencv2/video/tracking.hpp \
  /usr/local/opt/opencv@2/include/opencv2/video/background_segm.hpp \
  /usr/local/opt/opencv@2/include/opencv2/features2d/features2d.hpp \
  /usr/local/opt/opencv@2/include/opencv2/objdetect/objdetect.hpp \
  /usr/local/opt/opencv@2/include/opencv2/calib3d/calib3d.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/affine.hpp \
  /usr/local/opt/opencv@2/include/opencv2/ml/ml.hpp \
  /usr/local/opt/opencv@2/include/opencv2/highgui/highgui_c.h \
  /usr/local/opt/opencv@2/include/opencv2/highgui/highgui.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/contrib.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/retina.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/openfabmap.hpp \
  /usr/local/include/hecate/knapsack.hpp \
  /usr/local/include/hecate/cc_parser.hpp \
  /usr/local/include/hecate/file_helper.hpp \
  /usr/local/include/hecate/video_parser.hpp \
  /usr/local/include/hecate/gflseg.hpp \
  /usr/local/include/hecate/shot_range.hpp \
  /usr/local/include/hecate/hist_opencv.hpp \
  /usr/local/include/hecate/image_metrics.hpp \
  /usr/local/include/hecate/ffmpeg_helper.hpp

/usr/local/include/hecate/hecate.hpp:

/usr/local/include/hecate/sort.hpp:

/usr/local/include/hecate/time.hpp:

/usr/local/include/hecate/gapstat.hpp:

/usr/local/opt/opencv@2/include/opencv2/opencv.hpp:

/usr/local/opt/opencv@2/include/opencv2/opencv_modules.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/core_c.h:

/usr/local/opt/opencv@2/include/opencv2/core/types_c.h:

/usr/local/opt/opencv@2/include/opencv2/core/core.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/version.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/operations.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/mat.hpp:

/usr/local/opt/opencv@2/include/opencv2/flann/miniflann.hpp:

/usr/local/opt/opencv@2/include/opencv2/flann/defines.h:

/usr/local/opt/opencv@2/include/opencv2/flann/config.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc_c.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/types_c.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc.hpp:

/usr/local/opt/opencv@2/include/opencv2/photo/photo.hpp:

/usr/local/opt/opencv@2/include/opencv2/photo/photo_c.h:

/usr/local/opt/opencv@2/include/opencv2/video/video.hpp:

/usr/local/opt/opencv@2/include/opencv2/video/tracking.hpp:

/usr/local/opt/opencv@2/include/opencv2/video/background_segm.hpp:

/usr/local/opt/opencv@2/include/opencv2/features2d/features2d.hpp:

/usr/local/opt/opencv@2/include/opencv2/objdetect/objdetect.hpp:

/usr/local/opt/opencv@2/include/opencv2/calib3d/calib3d.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/affine.hpp:

/usr/local/opt/opencv@2/include/opencv2/ml/ml.hpp:

/usr/local/opt/opencv@2/include/opencv2/highgui/highgui_c.h:

/usr/local/opt/opencv@2/include/opencv2/highgui/highgui.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/contrib.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/retina.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/openfabmap.hpp:

/usr/local/include/hecate/knapsack.hpp:

/usr/local/include/hecate/cc_parser.hpp:

/usr/local/include/hecate/file_helper.hpp:

/usr/local/include/hecate/video_parser.hpp:

/usr/local/include/hecate/gflseg.hpp:

/usr/local/include/hecate/shot_range.hpp:

/usr/local/include/hecate/hist_opencv.hpp:

/usr/local/include/hecate/image_metrics.hpp:

/usr/local/include/hecate/ffmpeg_helper.hpp:
</file>

<file path=".build_release/src/hecate/hecate_highlight.o.warnings.txt">
In file included from src/hecate/hecate_highlight.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:41:
/usr/local/include/hecate/cc_parser.hpp:69:60: warning: 'bind1st<std::__1::not_equal_to<char>, char>' is deprecated [-Wdeprecated-declarations]
    dst.erase(dst.begin(), find_if(dst.begin(), dst.end(), bind1st(not_equal_to<char>(), ' ')));
                                                           ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1063:1: note: 'bind1st<std::__1::not_equal_to<char>, char>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/hecate/hecate_highlight.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:41:
/usr/local/include/hecate/cc_parser.hpp:70:49: warning: 'bind1st<std::__1::not_equal_to<char>, char>' is deprecated [-Wdeprecated-declarations]
    dst.erase(find_if(dst.rbegin(), dst.rend(), bind1st(not_equal_to<char>(), ' ')).base(), dst.end());
                                                ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1063:1: note: 'bind1st<std::__1::not_equal_to<char>, char>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/hecate/hecate_highlight.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:41:
/usr/local/include/hecate/cc_parser.hpp:126:60: warning: 'bind1st<std::__1::not_equal_to<char>, char>' is deprecated [-Wdeprecated-declarations]
    dst.erase(dst.begin(), find_if(dst.begin(), dst.end(), bind1st(not_equal_to<char>(), ' ')));
                                                           ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1063:1: note: 'bind1st<std::__1::not_equal_to<char>, char>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/hecate/hecate_highlight.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:41:
/usr/local/include/hecate/cc_parser.hpp:127:49: warning: 'bind1st<std::__1::not_equal_to<char>, char>' is deprecated [-Wdeprecated-declarations]
    dst.erase(find_if(dst.rbegin(), dst.rend(), bind1st(not_equal_to<char>(), ' ')).base(), dst.end());
                                                ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1063:1: note: 'bind1st<std::__1::not_equal_to<char>, char>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/hecate/hecate_highlight.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:42:
/usr/local/include/hecate/file_helper.hpp:78:72: warning: 'ptr_fun<int, int>' is deprecated [-Wdeprecated-declarations]
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
                                                                       ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1107:1: note: 'ptr_fun<int, int>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/hecate/hecate_highlight.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:42:
/usr/local/include/hecate/file_helper.hpp:83:63: warning: 'ptr_fun<int, int>' is deprecated [-Wdeprecated-declarations]
    s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
                                                              ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1107:1: note: 'ptr_fun<int, int>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
6 warnings generated.
</file>

<file path=".build_release/src/hecate/hecate_main.d">
.build_release/src/hecate/hecate_main.o: src/hecate/hecate_main.cpp \
  /usr/local/include/hecate/hecate.hpp \
  /usr/local/include/hecate/sort.hpp /usr/local/include/hecate/time.hpp \
  /usr/local/include/hecate/gapstat.hpp \
  /usr/local/opt/opencv@2/include/opencv2/opencv.hpp \
  /usr/local/opt/opencv@2/include/opencv2/opencv_modules.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/core_c.h \
  /usr/local/opt/opencv@2/include/opencv2/core/types_c.h \
  /usr/local/opt/opencv@2/include/opencv2/core/core.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/version.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/operations.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/mat.hpp \
  /usr/local/opt/opencv@2/include/opencv2/flann/miniflann.hpp \
  /usr/local/opt/opencv@2/include/opencv2/flann/defines.h \
  /usr/local/opt/opencv@2/include/opencv2/flann/config.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc_c.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/types_c.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc.hpp \
  /usr/local/opt/opencv@2/include/opencv2/photo/photo.hpp \
  /usr/local/opt/opencv@2/include/opencv2/photo/photo_c.h \
  /usr/local/opt/opencv@2/include/opencv2/video/video.hpp \
  /usr/local/opt/opencv@2/include/opencv2/video/tracking.hpp \
  /usr/local/opt/opencv@2/include/opencv2/video/background_segm.hpp \
  /usr/local/opt/opencv@2/include/opencv2/features2d/features2d.hpp \
  /usr/local/opt/opencv@2/include/opencv2/objdetect/objdetect.hpp \
  /usr/local/opt/opencv@2/include/opencv2/calib3d/calib3d.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/affine.hpp \
  /usr/local/opt/opencv@2/include/opencv2/ml/ml.hpp \
  /usr/local/opt/opencv@2/include/opencv2/highgui/highgui_c.h \
  /usr/local/opt/opencv@2/include/opencv2/highgui/highgui.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/contrib.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/retina.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/openfabmap.hpp \
  /usr/local/include/hecate/knapsack.hpp \
  /usr/local/include/hecate/cc_parser.hpp \
  /usr/local/include/hecate/file_helper.hpp \
  /usr/local/include/hecate/video_parser.hpp \
  /usr/local/include/hecate/gflseg.hpp \
  /usr/local/include/hecate/shot_range.hpp \
  /usr/local/include/hecate/hist_opencv.hpp \
  /usr/local/include/hecate/image_metrics.hpp \
  /usr/local/include/hecate/ffmpeg_helper.hpp

/usr/local/include/hecate/hecate.hpp:

/usr/local/include/hecate/sort.hpp:

/usr/local/include/hecate/time.hpp:

/usr/local/include/hecate/gapstat.hpp:

/usr/local/opt/opencv@2/include/opencv2/opencv.hpp:

/usr/local/opt/opencv@2/include/opencv2/opencv_modules.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/core_c.h:

/usr/local/opt/opencv@2/include/opencv2/core/types_c.h:

/usr/local/opt/opencv@2/include/opencv2/core/core.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/version.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/operations.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/mat.hpp:

/usr/local/opt/opencv@2/include/opencv2/flann/miniflann.hpp:

/usr/local/opt/opencv@2/include/opencv2/flann/defines.h:

/usr/local/opt/opencv@2/include/opencv2/flann/config.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc_c.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/types_c.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc.hpp:

/usr/local/opt/opencv@2/include/opencv2/photo/photo.hpp:

/usr/local/opt/opencv@2/include/opencv2/photo/photo_c.h:

/usr/local/opt/opencv@2/include/opencv2/video/video.hpp:

/usr/local/opt/opencv@2/include/opencv2/video/tracking.hpp:

/usr/local/opt/opencv@2/include/opencv2/video/background_segm.hpp:

/usr/local/opt/opencv@2/include/opencv2/features2d/features2d.hpp:

/usr/local/opt/opencv@2/include/opencv2/objdetect/objdetect.hpp:

/usr/local/opt/opencv@2/include/opencv2/calib3d/calib3d.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/affine.hpp:

/usr/local/opt/opencv@2/include/opencv2/ml/ml.hpp:

/usr/local/opt/opencv@2/include/opencv2/highgui/highgui_c.h:

/usr/local/opt/opencv@2/include/opencv2/highgui/highgui.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/contrib.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/retina.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/openfabmap.hpp:

/usr/local/include/hecate/knapsack.hpp:

/usr/local/include/hecate/cc_parser.hpp:

/usr/local/include/hecate/file_helper.hpp:

/usr/local/include/hecate/video_parser.hpp:

/usr/local/include/hecate/gflseg.hpp:

/usr/local/include/hecate/shot_range.hpp:

/usr/local/include/hecate/hist_opencv.hpp:

/usr/local/include/hecate/image_metrics.hpp:

/usr/local/include/hecate/ffmpeg_helper.hpp:
</file>

<file path=".build_release/src/hecate/hecate_main.o.warnings.txt">
In file included from src/hecate/hecate_main.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:41:
/usr/local/include/hecate/cc_parser.hpp:69:60: warning: 'bind1st<std::__1::not_equal_to<char>, char>' is deprecated [-Wdeprecated-declarations]
    dst.erase(dst.begin(), find_if(dst.begin(), dst.end(), bind1st(not_equal_to<char>(), ' ')));
                                                           ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1063:1: note: 'bind1st<std::__1::not_equal_to<char>, char>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/hecate/hecate_main.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:41:
/usr/local/include/hecate/cc_parser.hpp:70:49: warning: 'bind1st<std::__1::not_equal_to<char>, char>' is deprecated [-Wdeprecated-declarations]
    dst.erase(find_if(dst.rbegin(), dst.rend(), bind1st(not_equal_to<char>(), ' ')).base(), dst.end());
                                                ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1063:1: note: 'bind1st<std::__1::not_equal_to<char>, char>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/hecate/hecate_main.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:41:
/usr/local/include/hecate/cc_parser.hpp:126:60: warning: 'bind1st<std::__1::not_equal_to<char>, char>' is deprecated [-Wdeprecated-declarations]
    dst.erase(dst.begin(), find_if(dst.begin(), dst.end(), bind1st(not_equal_to<char>(), ' ')));
                                                           ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1063:1: note: 'bind1st<std::__1::not_equal_to<char>, char>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/hecate/hecate_main.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:41:
/usr/local/include/hecate/cc_parser.hpp:127:49: warning: 'bind1st<std::__1::not_equal_to<char>, char>' is deprecated [-Wdeprecated-declarations]
    dst.erase(find_if(dst.rbegin(), dst.rend(), bind1st(not_equal_to<char>(), ' ')).base(), dst.end());
                                                ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1063:1: note: 'bind1st<std::__1::not_equal_to<char>, char>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/hecate/hecate_main.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:42:
/usr/local/include/hecate/file_helper.hpp:78:72: warning: 'ptr_fun<int, int>' is deprecated [-Wdeprecated-declarations]
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
                                                                       ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1107:1: note: 'ptr_fun<int, int>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/hecate/hecate_main.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:42:
/usr/local/include/hecate/file_helper.hpp:83:63: warning: 'ptr_fun<int, int>' is deprecated [-Wdeprecated-declarations]
    s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
                                                              ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1107:1: note: 'ptr_fun<int, int>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
6 warnings generated.
</file>

<file path=".build_release/src/hecate/hecate_thumbnail.d">
.build_release/src/hecate/hecate_thumbnail.o: \
  src/hecate/hecate_thumbnail.cpp /usr/local/include/hecate/hecate.hpp \
  /usr/local/include/hecate/sort.hpp /usr/local/include/hecate/time.hpp \
  /usr/local/include/hecate/gapstat.hpp \
  /usr/local/opt/opencv@2/include/opencv2/opencv.hpp \
  /usr/local/opt/opencv@2/include/opencv2/opencv_modules.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/core_c.h \
  /usr/local/opt/opencv@2/include/opencv2/core/types_c.h \
  /usr/local/opt/opencv@2/include/opencv2/core/core.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/version.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/operations.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/mat.hpp \
  /usr/local/opt/opencv@2/include/opencv2/flann/miniflann.hpp \
  /usr/local/opt/opencv@2/include/opencv2/flann/defines.h \
  /usr/local/opt/opencv@2/include/opencv2/flann/config.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc_c.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/types_c.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc.hpp \
  /usr/local/opt/opencv@2/include/opencv2/photo/photo.hpp \
  /usr/local/opt/opencv@2/include/opencv2/photo/photo_c.h \
  /usr/local/opt/opencv@2/include/opencv2/video/video.hpp \
  /usr/local/opt/opencv@2/include/opencv2/video/tracking.hpp \
  /usr/local/opt/opencv@2/include/opencv2/video/background_segm.hpp \
  /usr/local/opt/opencv@2/include/opencv2/features2d/features2d.hpp \
  /usr/local/opt/opencv@2/include/opencv2/objdetect/objdetect.hpp \
  /usr/local/opt/opencv@2/include/opencv2/calib3d/calib3d.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/affine.hpp \
  /usr/local/opt/opencv@2/include/opencv2/ml/ml.hpp \
  /usr/local/opt/opencv@2/include/opencv2/highgui/highgui_c.h \
  /usr/local/opt/opencv@2/include/opencv2/highgui/highgui.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/contrib.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/retina.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/openfabmap.hpp \
  /usr/local/include/hecate/knapsack.hpp \
  /usr/local/include/hecate/cc_parser.hpp \
  /usr/local/include/hecate/file_helper.hpp \
  /usr/local/include/hecate/video_parser.hpp \
  /usr/local/include/hecate/gflseg.hpp \
  /usr/local/include/hecate/shot_range.hpp \
  /usr/local/include/hecate/hist_opencv.hpp \
  /usr/local/include/hecate/image_metrics.hpp \
  /usr/local/include/hecate/ffmpeg_helper.hpp

/usr/local/include/hecate/hecate.hpp:

/usr/local/include/hecate/sort.hpp:

/usr/local/include/hecate/time.hpp:

/usr/local/include/hecate/gapstat.hpp:

/usr/local/opt/opencv@2/include/opencv2/opencv.hpp:

/usr/local/opt/opencv@2/include/opencv2/opencv_modules.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/core_c.h:

/usr/local/opt/opencv@2/include/opencv2/core/types_c.h:

/usr/local/opt/opencv@2/include/opencv2/core/core.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/version.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/operations.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/mat.hpp:

/usr/local/opt/opencv@2/include/opencv2/flann/miniflann.hpp:

/usr/local/opt/opencv@2/include/opencv2/flann/defines.h:

/usr/local/opt/opencv@2/include/opencv2/flann/config.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc_c.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/types_c.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc.hpp:

/usr/local/opt/opencv@2/include/opencv2/photo/photo.hpp:

/usr/local/opt/opencv@2/include/opencv2/photo/photo_c.h:

/usr/local/opt/opencv@2/include/opencv2/video/video.hpp:

/usr/local/opt/opencv@2/include/opencv2/video/tracking.hpp:

/usr/local/opt/opencv@2/include/opencv2/video/background_segm.hpp:

/usr/local/opt/opencv@2/include/opencv2/features2d/features2d.hpp:

/usr/local/opt/opencv@2/include/opencv2/objdetect/objdetect.hpp:

/usr/local/opt/opencv@2/include/opencv2/calib3d/calib3d.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/affine.hpp:

/usr/local/opt/opencv@2/include/opencv2/ml/ml.hpp:

/usr/local/opt/opencv@2/include/opencv2/highgui/highgui_c.h:

/usr/local/opt/opencv@2/include/opencv2/highgui/highgui.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/contrib.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/retina.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/openfabmap.hpp:

/usr/local/include/hecate/knapsack.hpp:

/usr/local/include/hecate/cc_parser.hpp:

/usr/local/include/hecate/file_helper.hpp:

/usr/local/include/hecate/video_parser.hpp:

/usr/local/include/hecate/gflseg.hpp:

/usr/local/include/hecate/shot_range.hpp:

/usr/local/include/hecate/hist_opencv.hpp:

/usr/local/include/hecate/image_metrics.hpp:

/usr/local/include/hecate/ffmpeg_helper.hpp:
</file>

<file path=".build_release/src/hecate/hecate_thumbnail.o.warnings.txt">
In file included from src/hecate/hecate_thumbnail.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:41:
/usr/local/include/hecate/cc_parser.hpp:69:60: warning: 'bind1st<std::__1::not_equal_to<char>, char>' is deprecated [-Wdeprecated-declarations]
    dst.erase(dst.begin(), find_if(dst.begin(), dst.end(), bind1st(not_equal_to<char>(), ' ')));
                                                           ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1063:1: note: 'bind1st<std::__1::not_equal_to<char>, char>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/hecate/hecate_thumbnail.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:41:
/usr/local/include/hecate/cc_parser.hpp:70:49: warning: 'bind1st<std::__1::not_equal_to<char>, char>' is deprecated [-Wdeprecated-declarations]
    dst.erase(find_if(dst.rbegin(), dst.rend(), bind1st(not_equal_to<char>(), ' ')).base(), dst.end());
                                                ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1063:1: note: 'bind1st<std::__1::not_equal_to<char>, char>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/hecate/hecate_thumbnail.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:41:
/usr/local/include/hecate/cc_parser.hpp:126:60: warning: 'bind1st<std::__1::not_equal_to<char>, char>' is deprecated [-Wdeprecated-declarations]
    dst.erase(dst.begin(), find_if(dst.begin(), dst.end(), bind1st(not_equal_to<char>(), ' ')));
                                                           ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1063:1: note: 'bind1st<std::__1::not_equal_to<char>, char>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/hecate/hecate_thumbnail.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:41:
/usr/local/include/hecate/cc_parser.hpp:127:49: warning: 'bind1st<std::__1::not_equal_to<char>, char>' is deprecated [-Wdeprecated-declarations]
    dst.erase(find_if(dst.rbegin(), dst.rend(), bind1st(not_equal_to<char>(), ' ')).base(), dst.end());
                                                ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1063:1: note: 'bind1st<std::__1::not_equal_to<char>, char>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/hecate/hecate_thumbnail.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:42:
/usr/local/include/hecate/file_helper.hpp:78:72: warning: 'ptr_fun<int, int>' is deprecated [-Wdeprecated-declarations]
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
                                                                       ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1107:1: note: 'ptr_fun<int, int>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/hecate/hecate_thumbnail.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:42:
/usr/local/include/hecate/file_helper.hpp:83:63: warning: 'ptr_fun<int, int>' is deprecated [-Wdeprecated-declarations]
    s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
                                                              ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1107:1: note: 'ptr_fun<int, int>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
6 warnings generated.
</file>

<file path=".build_release/src/hecate/video_parser.d">
.build_release/src/hecate/video_parser.o: src/hecate/video_parser.cpp \
  /usr/local/include/hecate/video_parser.hpp \
  /usr/local/opt/opencv@2/include/opencv2/opencv.hpp \
  /usr/local/opt/opencv@2/include/opencv2/opencv_modules.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/core_c.h \
  /usr/local/opt/opencv@2/include/opencv2/core/types_c.h \
  /usr/local/opt/opencv@2/include/opencv2/core/core.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/version.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/operations.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/mat.hpp \
  /usr/local/opt/opencv@2/include/opencv2/flann/miniflann.hpp \
  /usr/local/opt/opencv@2/include/opencv2/flann/defines.h \
  /usr/local/opt/opencv@2/include/opencv2/flann/config.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc_c.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/types_c.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc.hpp \
  /usr/local/opt/opencv@2/include/opencv2/photo/photo.hpp \
  /usr/local/opt/opencv@2/include/opencv2/photo/photo_c.h \
  /usr/local/opt/opencv@2/include/opencv2/video/video.hpp \
  /usr/local/opt/opencv@2/include/opencv2/video/tracking.hpp \
  /usr/local/opt/opencv@2/include/opencv2/video/background_segm.hpp \
  /usr/local/opt/opencv@2/include/opencv2/features2d/features2d.hpp \
  /usr/local/opt/opencv@2/include/opencv2/objdetect/objdetect.hpp \
  /usr/local/opt/opencv@2/include/opencv2/calib3d/calib3d.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/affine.hpp \
  /usr/local/opt/opencv@2/include/opencv2/ml/ml.hpp \
  /usr/local/opt/opencv@2/include/opencv2/highgui/highgui_c.h \
  /usr/local/opt/opencv@2/include/opencv2/highgui/highgui.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/contrib.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/retina.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/openfabmap.hpp \
  /usr/local/include/hecate/sort.hpp \
  /usr/local/include/hecate/gflseg.hpp \
  /usr/local/include/hecate/gapstat.hpp \
  /usr/local/include/hecate/shot_range.hpp \
  /usr/local/include/hecate/hist_opencv.hpp \
  /usr/local/include/hecate/image_metrics.hpp

/usr/local/include/hecate/video_parser.hpp:

/usr/local/opt/opencv@2/include/opencv2/opencv.hpp:

/usr/local/opt/opencv@2/include/opencv2/opencv_modules.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/core_c.h:

/usr/local/opt/opencv@2/include/opencv2/core/types_c.h:

/usr/local/opt/opencv@2/include/opencv2/core/core.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/version.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/operations.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/mat.hpp:

/usr/local/opt/opencv@2/include/opencv2/flann/miniflann.hpp:

/usr/local/opt/opencv@2/include/opencv2/flann/defines.h:

/usr/local/opt/opencv@2/include/opencv2/flann/config.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc_c.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/types_c.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc.hpp:

/usr/local/opt/opencv@2/include/opencv2/photo/photo.hpp:

/usr/local/opt/opencv@2/include/opencv2/photo/photo_c.h:

/usr/local/opt/opencv@2/include/opencv2/video/video.hpp:

/usr/local/opt/opencv@2/include/opencv2/video/tracking.hpp:

/usr/local/opt/opencv@2/include/opencv2/video/background_segm.hpp:

/usr/local/opt/opencv@2/include/opencv2/features2d/features2d.hpp:

/usr/local/opt/opencv@2/include/opencv2/objdetect/objdetect.hpp:

/usr/local/opt/opencv@2/include/opencv2/calib3d/calib3d.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/affine.hpp:

/usr/local/opt/opencv@2/include/opencv2/ml/ml.hpp:

/usr/local/opt/opencv@2/include/opencv2/highgui/highgui_c.h:

/usr/local/opt/opencv@2/include/opencv2/highgui/highgui.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/contrib.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/retina.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/openfabmap.hpp:

/usr/local/include/hecate/sort.hpp:

/usr/local/include/hecate/gflseg.hpp:

/usr/local/include/hecate/gapstat.hpp:

/usr/local/include/hecate/shot_range.hpp:

/usr/local/include/hecate/hist_opencv.hpp:

/usr/local/include/hecate/image_metrics.hpp:
</file>

<file path=".build_release/src/tools/hecate.d">
.build_release/src/tools/hecate.o: src/tools/hecate.cpp \
  /usr/local/include/hecate/hecate.hpp \
  /usr/local/include/hecate/sort.hpp /usr/local/include/hecate/time.hpp \
  /usr/local/include/hecate/gapstat.hpp \
  /usr/local/opt/opencv@2/include/opencv2/opencv.hpp \
  /usr/local/opt/opencv@2/include/opencv2/opencv_modules.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/core_c.h \
  /usr/local/opt/opencv@2/include/opencv2/core/types_c.h \
  /usr/local/opt/opencv@2/include/opencv2/core/core.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/version.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/operations.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/mat.hpp \
  /usr/local/opt/opencv@2/include/opencv2/flann/miniflann.hpp \
  /usr/local/opt/opencv@2/include/opencv2/flann/defines.h \
  /usr/local/opt/opencv@2/include/opencv2/flann/config.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc_c.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/types_c.h \
  /usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc.hpp \
  /usr/local/opt/opencv@2/include/opencv2/photo/photo.hpp \
  /usr/local/opt/opencv@2/include/opencv2/photo/photo_c.h \
  /usr/local/opt/opencv@2/include/opencv2/video/video.hpp \
  /usr/local/opt/opencv@2/include/opencv2/video/tracking.hpp \
  /usr/local/opt/opencv@2/include/opencv2/video/background_segm.hpp \
  /usr/local/opt/opencv@2/include/opencv2/features2d/features2d.hpp \
  /usr/local/opt/opencv@2/include/opencv2/objdetect/objdetect.hpp \
  /usr/local/opt/opencv@2/include/opencv2/calib3d/calib3d.hpp \
  /usr/local/opt/opencv@2/include/opencv2/core/affine.hpp \
  /usr/local/opt/opencv@2/include/opencv2/ml/ml.hpp \
  /usr/local/opt/opencv@2/include/opencv2/highgui/highgui_c.h \
  /usr/local/opt/opencv@2/include/opencv2/highgui/highgui.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/contrib.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/retina.hpp \
  /usr/local/opt/opencv@2/include/opencv2/contrib/openfabmap.hpp \
  /usr/local/include/hecate/knapsack.hpp \
  /usr/local/include/hecate/cc_parser.hpp \
  /usr/local/include/hecate/file_helper.hpp \
  /usr/local/include/hecate/video_parser.hpp \
  /usr/local/include/hecate/gflseg.hpp \
  /usr/local/include/hecate/shot_range.hpp \
  /usr/local/include/hecate/hist_opencv.hpp \
  /usr/local/include/hecate/image_metrics.hpp \
  /usr/local/include/hecate/ffmpeg_helper.hpp

/usr/local/include/hecate/hecate.hpp:

/usr/local/include/hecate/sort.hpp:

/usr/local/include/hecate/time.hpp:

/usr/local/include/hecate/gapstat.hpp:

/usr/local/opt/opencv@2/include/opencv2/opencv.hpp:

/usr/local/opt/opencv@2/include/opencv2/opencv_modules.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/core_c.h:

/usr/local/opt/opencv@2/include/opencv2/core/types_c.h:

/usr/local/opt/opencv@2/include/opencv2/core/core.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/version.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/operations.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/mat.hpp:

/usr/local/opt/opencv@2/include/opencv2/flann/miniflann.hpp:

/usr/local/opt/opencv@2/include/opencv2/flann/defines.h:

/usr/local/opt/opencv@2/include/opencv2/flann/config.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc_c.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/types_c.h:

/usr/local/opt/opencv@2/include/opencv2/imgproc/imgproc.hpp:

/usr/local/opt/opencv@2/include/opencv2/photo/photo.hpp:

/usr/local/opt/opencv@2/include/opencv2/photo/photo_c.h:

/usr/local/opt/opencv@2/include/opencv2/video/video.hpp:

/usr/local/opt/opencv@2/include/opencv2/video/tracking.hpp:

/usr/local/opt/opencv@2/include/opencv2/video/background_segm.hpp:

/usr/local/opt/opencv@2/include/opencv2/features2d/features2d.hpp:

/usr/local/opt/opencv@2/include/opencv2/objdetect/objdetect.hpp:

/usr/local/opt/opencv@2/include/opencv2/calib3d/calib3d.hpp:

/usr/local/opt/opencv@2/include/opencv2/core/affine.hpp:

/usr/local/opt/opencv@2/include/opencv2/ml/ml.hpp:

/usr/local/opt/opencv@2/include/opencv2/highgui/highgui_c.h:

/usr/local/opt/opencv@2/include/opencv2/highgui/highgui.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/contrib.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/retina.hpp:

/usr/local/opt/opencv@2/include/opencv2/contrib/openfabmap.hpp:

/usr/local/include/hecate/knapsack.hpp:

/usr/local/include/hecate/cc_parser.hpp:

/usr/local/include/hecate/file_helper.hpp:

/usr/local/include/hecate/video_parser.hpp:

/usr/local/include/hecate/gflseg.hpp:

/usr/local/include/hecate/shot_range.hpp:

/usr/local/include/hecate/hist_opencv.hpp:

/usr/local/include/hecate/image_metrics.hpp:

/usr/local/include/hecate/ffmpeg_helper.hpp:
</file>

<file path=".build_release/src/tools/hecate.o.warnings.txt">
In file included from src/tools/hecate.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:41:
/usr/local/include/hecate/cc_parser.hpp:69:60: warning: 'bind1st<std::__1::not_equal_to<char>, char>' is deprecated [-Wdeprecated-declarations]
    dst.erase(dst.begin(), find_if(dst.begin(), dst.end(), bind1st(not_equal_to<char>(), ' ')));
                                                           ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1063:1: note: 'bind1st<std::__1::not_equal_to<char>, char>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/tools/hecate.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:41:
/usr/local/include/hecate/cc_parser.hpp:70:49: warning: 'bind1st<std::__1::not_equal_to<char>, char>' is deprecated [-Wdeprecated-declarations]
    dst.erase(find_if(dst.rbegin(), dst.rend(), bind1st(not_equal_to<char>(), ' ')).base(), dst.end());
                                                ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1063:1: note: 'bind1st<std::__1::not_equal_to<char>, char>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/tools/hecate.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:41:
/usr/local/include/hecate/cc_parser.hpp:126:60: warning: 'bind1st<std::__1::not_equal_to<char>, char>' is deprecated [-Wdeprecated-declarations]
    dst.erase(dst.begin(), find_if(dst.begin(), dst.end(), bind1st(not_equal_to<char>(), ' ')));
                                                           ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1063:1: note: 'bind1st<std::__1::not_equal_to<char>, char>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/tools/hecate.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:41:
/usr/local/include/hecate/cc_parser.hpp:127:49: warning: 'bind1st<std::__1::not_equal_to<char>, char>' is deprecated [-Wdeprecated-declarations]
    dst.erase(find_if(dst.rbegin(), dst.rend(), bind1st(not_equal_to<char>(), ' ')).base(), dst.end());
                                                ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1063:1: note: 'bind1st<std::__1::not_equal_to<char>, char>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/tools/hecate.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:42:
/usr/local/include/hecate/file_helper.hpp:78:72: warning: 'ptr_fun<int, int>' is deprecated [-Wdeprecated-declarations]
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
                                                                       ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1107:1: note: 'ptr_fun<int, int>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
In file included from src/tools/hecate.cpp:11:
In file included from /usr/local/include/hecate/hecate.hpp:42:
/usr/local/include/hecate/file_helper.hpp:83:63: warning: 'ptr_fun<int, int>' is deprecated [-Wdeprecated-declarations]
    s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
                                                              ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1107:1: note: 'ptr_fun<int, int>' has been explicitly marked deprecated here
_LIBCPP_DEPRECATED_IN_CXX11 inline _LIBCPP_INLINE_VISIBILITY
^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1030:39: note: expanded from macro '_LIBCPP_DEPRECATED_IN_CXX11'
#  define _LIBCPP_DEPRECATED_IN_CXX11 _LIBCPP_DEPRECATED
                                      ^
/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config:1019:48: note: expanded from macro '_LIBCPP_DEPRECATED'
#    define _LIBCPP_DEPRECATED __attribute__ ((deprecated))
                                               ^
6 warnings generated.
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/include/hecate/cc_parser.hpp">
/*
 * Video caption parser (VTT and TTML)
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_CC_PARSER_HPP
#define HECATE_CC_PARSER_HPP

#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <fstream>
#include <cstring>
#include <algorithm>

#include "hecate/time.hpp"

using namespace std;

namespace hecate {
  
  struct tcc {
    double start; // milli-seconds
    double end;   // milli-seconds
    string text;
  };
  
  inline double time_str2num( const string str_time )
  {
    int hh,mm,ss,ms;
    
    hh = stoi( str_time.substr(0,2) );
    mm = stoi( str_time.substr(3,2) );
    ss = stoi( str_time.substr(6,2) );
    ms = stoi( str_time.substr(9,3) );
    
    return 60*60*hh + 60*mm + ss + (double)ms/1000.0;
  }
  
  
  inline string truncate_caption( const string src, const int maxlen )
  {
    string dst = src;
    while( (int)dst.length()>maxlen )
    {
      size_t pos = dst.find_last_of(" ");
      dst = dst.substr(0,pos);
    }
    return dst;
  }
  
  inline string clean_caption( const string src )
  {
    string dst = src;
    size_t pos, pos2;
    
    // Remove special characters
    char chars[] = ".,;:@#$%^&*\"><_+=~`/";
    for(unsigned i=0; i<strlen(chars); i++)
      dst.erase( remove(dst.begin(), dst.end(), chars[i]), dst.end() );
    
    // Remove leading & trailing spaces
    dst.erase(dst.begin(), find_if(dst.begin(), dst.end(), bind1st(not_equal_to<char>(), ' ')));
    dst.erase(find_if(dst.rbegin(), dst.rend(), bind1st(not_equal_to<char>(), ' ')).base(), dst.end());
    
    // Remove leadning words
    vector<string> lwords = {"And ","But ","Or ","and ","Then ","then "};
    for(size_t i=0; i<lwords.size(); i++)
    {
      pos = dst.find(lwords[i]);
      if( pos==0 ) {
        //printf("<<[%s>> [%s] -> [%s]\n", lwords[i].c_str(), dst.c_str(), dst.substr(lwords[i].length(),string::npos).c_str());
        dst = dst.substr(lwords[i].length(),string::npos);
      }
    }
    
    // Remove trailing words
    dst = dst + " ";
    vector<string> words = {" and "," or "," but "," however "," to "," of "," so ",
      " because "," who "," when "," where "," what "," how ", " why ",
      " while "," which "," with "," the "};
    for(size_t i=0; i<words.size(); i++)
    {
      pos = dst.substr(0,dst.find_last_of(" ")).find_last_of(" ");
      if( pos==string::npos )
        break;
      pos2 = dst.substr(pos,string::npos).find(words[i]);
      if( pos2!=string::npos ) {
        //printf("<<%s]>> [%s] -> [%s]\n", words[i].c_str(), dst.c_str(), dst.substr(0,pos).c_str());
        dst = dst.substr(0,pos) + " ";
      }
    }
    
    // Remove annotation inside a bracket, e.g., [UNKNOWN], [LAUGH], [MUSIC], etc.
    pos = dst.find("[");
    while( pos!=string::npos )
    {
      pos2 = dst.find("]");
      dst = dst.substr(0,pos) + dst.substr(pos2+1,string::npos);
      pos = dst.find("[");
    }
    
    // Remove double ??
    pos = dst.find("??");
    while( pos!=string::npos )
    {
      dst = dst.substr(0,pos) + dst.substr(pos+2,string::npos);
      pos = dst.find("??");
    }
    
    // Remove double space
    pos = dst.find("  ");
    while( pos!=string::npos )
    {
      dst = dst.substr(0,pos) + dst.substr(pos+1,string::npos);
      pos = dst.find("  ");
    }
    
    // Remove leading & trailing spaces
    dst.erase(dst.begin(), find_if(dst.begin(), dst.end(), bind1st(not_equal_to<char>(), ' ')));
    dst.erase(find_if(dst.rbegin(), dst.rend(), bind1st(not_equal_to<char>(), ' ')).base(), dst.end());
    
    
    return dst;
  }
  
  
  
  inline void print_closed_caption( vector<tcc>& cc )
  {
    for(size_t i=0; i<cc.size(); i++ )
      printf("%.2f  -->  %.2f: [%s]\n",cc[i].start,cc[i].end,cc[i].text.c_str());
  }
  
  
  
  inline void parse_vtt( const string filename, vector<tcc>& vtt )
  {
    string line;
    
    ifstream fid;
    fid.open( filename );
    getline( fid, line );
    while( fid )
    {
      size_t pos = line.find(" --> ");
      if( pos!=string::npos )
      {
        tcc cc;
        
        // time
        cc.start = time_str2num( line.substr( 0, pos ) );
        cc.end = time_str2num( line.substr( pos+5, string::npos) );
        
        // text
        getline( fid, line );
        line = clean_caption( line );
        
        pos = line.find("???");
        if( pos==string::npos && line.length()>3 ) {
          cc.text = line;
          vtt.push_back( cc );
        }
      }
      getline( fid, line );
    }
  }
  
  inline void parse_ttml( const string filename, vector<tcc>& ttml )
  {
    size_t pos1, pos2, pos3;
    string line, item;
    
    string p_start = "<p ";
    string p_end   = "</p>";
    
    ifstream fid;
    fid.open( filename );
    getline( fid, line );
    
    // Check the language
    pos1 = line.find("<language>en-US</language>");
    if( pos1==string::npos )
      return;
    
    // Parse TTML
    while( fid )
    {
      pos1 = line.find(p_start);
      while( pos1!=string::npos )
      {
        pos2 = line.find(p_end);
        item = line.substr(pos1, pos2-pos1);
        line = line.substr( pos2+3, string::npos );
        
        pos1 = item.find("begin=");
        pos2 = item.find("end=");
        pos3 = item.find("\">");
        
        tcc cc;
        cc.start = time_str2num( item.substr(pos1+7,12) );
        cc.end   = time_str2num( item.substr(pos2+5,12) );
        cc.text  = clean_caption( item.substr(pos3+2,string::npos) );
        ttml.push_back( cc );
        
        pos1 = line.find(p_start);
      }
      getline( fid, line );
    }
    
    //print_closed_caption( ttml );
  }
  
  //
  inline string encode_vtt( int index, float start_sec, float end_sec,
                           vector<string>& v_msg )
  {
    char buf[512];
    string start_sec_str = hecate::second2string( start_sec, "hh:mm:ss.mss" );
    string end_sec_str = hecate::second2string( end_sec, "hh:mm:ss.mss" );
    sprintf( buf, "%d\n%s --> %s\n", index, start_sec_str.c_str(),
            end_sec_str.c_str());

    for(size_t i=0; i<v_msg.size(); i++) {
      sprintf( buf, "%s- %s\n", buf, v_msg[i].c_str());
    }
    
    string ret = buf;
    return ret;
  }
  
}
#endif
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/include/hecate/ffmpeg_helper.hpp">
/*
 * Various helper functions using ffmpeg
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */


#ifndef HECATE_FFMPEG_HPP
#define HECATE_FFMPEG_HPP

#include <stdio.h>
#include <string.h>

#include <iostream>
#include <fstream>
#include <string>
#include <vector>

#include "hecate/file_helper.hpp"

#define BUF_S 256
#define BUF_M 512
#define BUF_L 1024

using namespace std;

namespace hecate {
  const string _ffmpeg = hecate::which("ffmpeg");
  const string _ffmarg = "-loglevel quiet -y";
  const int _lfade = 8; // fade-in/out duration (unit: frame)
  
  // Crop video segment & resize
  static inline void ffmpeg_video_crop(string in_file,
                                       string out_file,
                                       string start_time,
                                       string duration,
                                       int out_width_px)
  {
    in_file = escape_space(in_file);
    
    char filter[BUF_S];
    sprintf( filter, "'scale=%d:trunc(ow/a/2)*2'", out_width_px);
    
    char cmd[BUF_L];
    sprintf( cmd, "%s -ss %s -t %s -i %s -strict -2 -vf %s %s %s",
            _ffmpeg.c_str(), start_time.c_str(), duration.c_str(),
            in_file.c_str(), filter, out_file.c_str(), _ffmarg.c_str());
    
    system( cmd );
  };
  
  static inline void ffmpeg_video_concat(string in_filelist,
                                         string out_file)
  {
    char cmd[BUF_L];
    sprintf( cmd, "%s -f concat -i %s -c copy %s %s",
            _ffmpeg.c_str(), in_filelist.c_str(), out_file.c_str(),
            _ffmarg.c_str() );
    system( cmd );
  };
  
  // Audio fade in/out
  static inline void ffmpeg_audio_fade(string in_file,
                                       string out_file,
                                       double video_duration_sec,
                                       double video_fps)
  {
    in_file = escape_space(in_file);
    
    const double afade_sec = (double)2*_lfade/video_fps;
    const double afade_msec = (int)10000*(afade_sec-floor(afade_sec));
    
    double afos  = video_duration_sec - afade_sec; // audio fade-out start
    int afos_ss  = (int) afos; // NOTE: we don't compute modulo this time
    int afos_mss = (int) 10000*(afos - floor(afos));
    
    char filter[BUF_S];
    sprintf( filter, "'afade=t=in:ss=0:d=0.%04d,"
                      "afade=t=out:st=%d.%04d:d=0.%04d'",
            (int)afade_msec, afos_ss, afos_mss, (int)afade_msec);

    char cmd[BUF_L];
    sprintf( cmd, "%s -i %s -af %s %s %s", _ffmpeg.c_str(),
            in_file.c_str(), filter, out_file.c_str(), _ffmarg.c_str() );
    system( cmd );

  };
  
  // Video fade in/out
  static inline void ffmpeg_video_fade(string in_file,
                                       string out_file,
                                       int video_duration,
                                       bool out_only=false)
  {
    in_file = escape_space(in_file);
    
    char filter[BUF_S];
    if( out_only ) {
      sprintf( filter, "'fade=out:%d:%d'",
              video_duration-_lfade, _lfade);
    }
    else {
      sprintf( filter, "'fade=in:0:%d,fade=out:%d:%d'",
              _lfade, video_duration-_lfade, _lfade);
    }
    
    char cmd[BUF_L];
    sprintf( cmd, "%s -i %s -vf %s %s %s", _ffmpeg.c_str(),
            in_file.c_str(), filter, out_file.c_str(), _ffmarg.c_str());
    system( cmd );
  };
  
  
  // Based on http://blog.pkh.me/p/21-high-quality-gif-with-ffmpeg.html
  static inline void ffmpeg_video2gif(string in_file,
                                      string out_file,
                                      string start_time,
                                      string duration,
                                      int out_fps,
                                      int out_width_px)
  {
    in_file = escape_space(in_file);
    
    string out_dir = hecate::get_dir( std::string(out_file) );
    
    char filter[BUF_S];
    sprintf( filter, "fps=%d,scale=%d:-1:flags=lanczos", out_fps, out_width_px );
    
    char palette[BUF_M];
    sprintf( palette, "%s/palatte.png", out_dir.c_str() );
    
    char time_setup[BUF_S] = "";
    if( !start_time.empty() && !duration.empty() ) {
      sprintf( time_setup, "-ss %s -t %s",
              start_time.c_str(), duration.c_str() );
    }

    char cmd[BUF_L];
    
    // Create a palatte
    sprintf( cmd, "%s %s -i %s -vf '%s,palettegen=stats_mode=diff' %s %s",
            _ffmpeg.c_str(), time_setup,  in_file.c_str(), filter,
            _ffmarg.c_str(), palette );
    system( cmd );
    
    // Convert segment to gif
    sprintf( cmd, "%s %s -i %s -i %s -lavfi '%s [x]; [x][1:v] paletteuse' %s %s",
            _ffmpeg.c_str(), time_setup, in_file.c_str(), palette, filter,
            _ffmarg.c_str(), out_file.c_str());
    system( cmd );
    
    // Delete palette
    sprintf( cmd, "rm %s", palette );
    system( cmd );
  };
  
  
  
}
#endif
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/include/hecate/file_helper.hpp">
/*
 * Various helper functions for filesystem
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_FILE_HPP
#define HECATE_FILE_HPP

#include <stdio.h>
#include <string.h>

#include <iostream>
#include <fstream>
#include <algorithm>
#include <functional>
#include <cctype>
#include <locale>
#include <string>
#include <vector>

namespace hecate {
  
  // GET FILENAME WITHOUT EXTENSION AND TRAILING DIRECTORIES
  struct FileParts
  {
    std::string path;
    std::string name;
    std::string ext;
  };
  
  static inline FileParts fileparts(std::string filename)
  {
    int idx0 = filename.rfind("/");
    int idx1 = filename.rfind(".");
    
    if( idx1 == (int) std::string::npos )
      idx1 = filename.length();
    
    FileParts fp;
    fp.path = filename.substr(0,idx0+1);
    fp.name = filename.substr(idx0+1,idx1-idx0-1);
    fp.ext  = filename.substr(idx1);
    
    return fp;
  };
  
  static inline std::string get_dir( std::string filepath ) {
    hecate::FileParts fp = hecate::fileparts( filepath );
    std::string dir = fp.path;
    return dir;
  };
  
  static inline std::string escape_space( std::string s ) {
    std::string out;
    for( size_t i=0; i<s.size(); i++) {
      if( s[i] == ' ' )
        out += '\\';
      out += s[i];
    }
    return out;
  }
  
  static inline std::string get_filename( std::string filepath ) {
    hecate::FileParts fp = hecate::fileparts( filepath );
    std::string filename = fp.name;
    replace( filename.begin(), filename.end(), ' ', '_' );
    return filename;
  };
  
  // TRIM STRING. USEFUL FOR PROCESSING STRING FILENAMES
  // trim from start
  static inline std::string &ltrim(std::string &s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
    return s;
  };
  // trim from end
  static inline std::string &rtrim(std::string &s) {
    s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
    return s;
  };
  // trim from both ends
  static inline std::string &trim(std::string &s) {
    return ltrim(rtrim(s));
  };
  
  
  static inline char *trim(char *str)
  {
    size_t len = 0;
    char *frontp = str;
    char *endp = NULL;
    
    if( str == NULL ) { return NULL; }
    if( str[0] == '\0' ) { return str; }
    
    len = strlen(str);
    endp = str + len;
    
    /* Move the front and back pointers to address the first non-whitespace
     * characters from each end.
     */
    while( isspace(*frontp) ) { ++frontp; }
    if( endp != frontp )
    {
      while( isspace(*(--endp)) && endp != frontp ) {}
    }
    
    if( str + len - 1 != endp )
      *(endp + 1) = '\0';
    else if( frontp != str &&  endp == frontp )
      *str = '\0';
    
    /* Shift the string so that it starts at str so that if it's dynamically
     * allocated, we can still free it on the returned pointer.  Note the reuse
     * of endp to mean the front of the string buffer now.
     */
    endp = str;
    if( frontp != str )
    {
      while( *frontp ) { *endp++ = *frontp++; }
      *endp = '\0';
    }
    return str;
  };
  
  
  // CHECK IF FILE EXISTS
  static inline bool file_exists (const std::string& name) {
    if (FILE *file = fopen(name.c_str(), "r")) {
      fclose(file);
      return true;
    } else {
      return false;
    }
  };
  
  // READ TEXT FILE INTO A VECTOR
  static inline void read_textlist( const std::string& in,
                                   std::vector<std::string>& out )
  {
    std::string str;
    std::ifstream file( in );
    while( std::getline( file, str ) ) {
      str = hecate::trim(str);
      if( str.length()==0 ) continue;
      if( str.at(0)=='#' ) continue;
      out.push_back( str );
    }
  };
  
  // READ TEXT FILE CONTAINING A LIST OF FILEPATHS
  static inline void read_filelist( const std::string& in,
                                   std::vector<std::string>& out )
  {
    std::string str;
    std::ifstream file( in );
    while( std::getline( file, str ) ) {
      str = hecate::trim(str);
      if( str.length()==0 ) continue;
      if( str.at(0)=='#' ) continue;
      
      if( hecate::file_exists( str ) )
        out.push_back( str );
      else
        fprintf( stderr, "File doesn't exist: %s\n", str.c_str() );
      
    }
  };
  
  static inline void split_string( char* in,
                                  std::vector<std::string>& out,
                                  const char* delimiter)
  {
    out.clear();
    char *token = in;
    while( (token=strsep(&in,delimiter)) != NULL )
      out.push_back( hecate::trim(token) );
  };
  
  static inline std::string exec(const char* cmd) {
    FILE* pipe = popen(cmd, "r");
    if (!pipe) return "ERROR";
    char buffer[1024];
    std::string result = "";
    while (!feof(pipe)) {
      if (fgets(buffer, 1024, pipe) != NULL)
        result += buffer;
    }
    pclose(pipe);
    return result;
  };
  
  static inline std::string which(const char* bin) {
    char buf[1024];
    sprintf( buf, "echo `which %s`", bin );
    std::string result = hecate::exec(buf);
    result.erase( result.find_last_not_of(" \n\r\t")+1);
    return result;
  }
}
#endif
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/include/hecate/gapstat.hpp">
/*
 * Gap statistics
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */


#ifndef HECATE_GAPSTAT_HPP
#define HECATE_GAPSTAT_HPP

#include <stdio.h>
#include <stdlib.h>

#include <iostream>   // for standard I/O
#include <limits>
#include <numeric>

#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>

#if CV_MAJOR_VERSION > 2
#include <opencv2/core/core_c.h>
#include <opencv2/imgproc/types_c.h>
#endif

using namespace std;
using namespace cv;

namespace hecate {
  
  // Compute mean-squared error (mse)
  inline double calc_mse( const Mat& km_data, const Mat& km_lbl, const Mat& km_ctr )
  {
    double compactness = 0;
    
    int nsamples = km_lbl.rows;
    int nclusters  = km_ctr.rows;
    
    for( int k=0; k<nclusters; k++ ) {
      int nk = 0;
      double err = 0;
      for( int i=0; i<nsamples; i++ ) {
        if( km_lbl.at<int>(i)==k ) {
          nk++;
          err += pow(cv::norm(km_data.row(i)-km_ctr.row(k)),2.0);
        }
      }
      compactness += 0.5 * err / nk;
    }
    
    return compactness;
  }
  
  inline void find_bounds( const Mat& km_data, Mat& bounds )
  {
    int ndim = km_data.cols;
    bounds = Mat(2,ndim,CV_64F);
    
    double minval, maxval;
    for( int d=0; d<ndim; d++ ){
      minMaxLoc( km_data.col(d), &minval, &maxval );
      bounds.at<double>(0,d) = minval;
      bounds.at<double>(1,d) = maxval;
    }
  }
  
  inline void randu_bound( Mat& X, const Mat& bounds, int nsamples, int ndims )
  {
    X = Mat(nsamples, ndims, CV_32F);
    randu( X, Scalar::all(0.0), Scalar::all(1.0) );
    for(int c=0; c<X.cols; c++) {
      double lb = bounds.at<double>(0,c);
      double ub = bounds.at<double>(1,c);
      X.col(c) = (ub-lb)*X.col(c) + lb;
    }
  }
  
  //fix error when there is only 1 data point: http://docs.opencv.org/2.4/modules/core/doc/clustering.html
  inline void perform_kmeans(const Mat& km_data, Mat& km_lbl, Mat& km_ctr, int ncluster,
                             int km_attempts=1, int km_max_cnt=1000, double km_eps=0.0001)
  {
      if(km_data.rows==1){
          km_lbl = Mat::zeros(1,1, km_lbl.type());
          cv::reduce( km_data, km_ctr, 0, CV_REDUCE_AVG );
      }
      else{
        int km_k = min(ncluster, km_data.rows);
        TermCriteria km_opt = TermCriteria(CV_TERMCRIT_ITER|CV_TERMCRIT_EPS, km_max_cnt, km_eps);
        kmeans( km_data, km_k, km_lbl, km_opt, km_attempts, KMEANS_PP_CENTERS, km_ctr );
      }
}
  
  inline int perform_kmeans_gs( const Mat& km_data, Mat& km_lbl, Mat& km_ctr,
                               vector<int> K, int B=10, int N=500 )
  {
    int ndims = km_data.cols;
    
    // Generate null reference dataset
    vector<Mat> v_Xb;
    Mat bounds; find_bounds( km_data, bounds );
    for(int b=0; b<B; b++) {
      Mat Xb;
      randu_bound( Xb, bounds, N, ndims );
      v_Xb.push_back( Xb );
    }
    
    // Compute Gap Statistics
    vector<double> gap(K.size(), 0.0);    // gap statistics = E[logWk] - logWk
    vector<double> ElogWk(K.size(), 0.0); // compactness of the null reference distribution
    vector<double> logWk(K.size(), 0.0);  // compactness of the given data
    vector<double> Sk(K.size(), 0.0);   // standard deviations
    
    for( size_t i=0; i<K.size(); i++ )
    {
      Mat lbl, ctr;
      perform_kmeans( km_data, lbl, ctr, K[i] );
      logWk[i] = log(calc_mse( km_data, lbl, ctr ));
      
      ElogWk[i] = 0.0;
      vector<double> logWkb(B, 0.0);
      for(int b=0; b<B; b++)
      {
        Mat lbl_b, ctr_b;
        perform_kmeans( v_Xb[b], lbl_b, ctr_b, K[i], 100, 1000, 0.001 );
        logWkb[b] = log(calc_mse( v_Xb[b], lbl_b, ctr_b ));
        ElogWk[i] += logWkb[b];
      }
      ElogWk[i] /= B;
      
      Sk[i] = 0.0;
      for(int b=0; b<B; b++)
        Sk[i] += (logWkb[b]-ElogWk[i])*(logWkb[b]-ElogWk[i]);
      Sk[i] = sqrt(1.0+1.0/B) * sqrt( Sk[i] / B );
      
      gap[i] = ElogWk[i] - logWk[i];
      printf("\tgapstat: k=%d, logWk=%f, ElogWk=%f, Sk=%f, Gap=%f\n",
             K[i], logWk[i], ElogWk[i], Sk[i], gap[i]);
    }
    
    // find the smallest k such that gap(k) >= gap(k+1) - S[k+1]
    size_t kstar=0;
    for(size_t i=0; i<K.size()-1; i++) {
      if( gap[i] >= gap[i+1] - Sk[i+1] ) {
        kstar = i;
        break;
      }
    }
    printf("\tgapstat: Optimal k=%d [%d:%d]\n", K[kstar], K[0], K[K.size()-1]);
    
    // return results
    perform_kmeans( km_data, km_lbl, km_ctr, K[kstar] );
    return K[kstar];
    
  }
}

#endif
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/include/hecate/gflseg.hpp">
/*
 * GFLSEG Group Fused LASSO Change Point Detection solver
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 *
 * Implementation is based on:
 *   Kevin Bleakley and Jean-Philippe Vert.
 *     "The group fused lasso for multiple change-point detection."
 *   arXiv preprint arXiv:1106.4199 (2011).
 */


#ifndef HECATE_GFLSEG_HPP
#define HECATE_GFLSEG_HPP

#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>

#if CV_MAJOR_VERSION > 2
#include <opencv2/core/core_c.h>
#endif

#include "hecate/sort.hpp"

using namespace std;
using namespace cv;

namespace hecate {
  
  class Segmenter {
  public:
    /*
     Automatic multiple change-point detection
     
     This function is a wrapper for multi-dimensional signal segmentation into at
     least k change-points by the LARS (function gflars), followed by change-point
     selection with a dynamic programming optimization (function dpseg).
     
     INPUT
     X      : n-by-p matrix to be segmented (n: # obs, p: # dim).
     k      : the number of change points to find in the first segmentation step
     theta  : stopping criteria, see dpseg. (default=0.1)
     forcek : k is set as the hard maximum number of change points
     
     OUTPUT
     jumps  : vector of change-points
     val    : matrix of the value on each interval
     updown : the up/down statistics on each interval
     */
    void gflseg(const Mat& X, vector<int>& jumps, int k, double theta=0.1);
    
    
    
    /*
     Segmentation of a multi-dimensional signal with dynamic programming
     http://pbil.univ-lyon1.fr/members/fpicard/franckpicard_fichiers/pdf/aCGH-stat.pdf
     Improvement is made by penalizing with the optimal segment length,
     lambda=sqrt(lstar-l) where lstar = n/k (typically chosen as 2-second long)
     
     INPUT
     X     : n-by-p matrix to be segmented (n: # obs, p: # dim).
     cp    : candidate change points (default: [0:n-2])
     kmax  : maximum number of change-points to test (default: length(cp))
     theta : stopping criteria. Typically chonse to be in the interval (0 0.5].
     The smaller the threshold, the higher the tendency to keep more
     breakpoints. The criteria is based on the method found in
     'Picard et al (2005)' "A statistical approach for array CGH data
     analysis" (BMC Bioinformatics). (default=0.5)
     
     OUTPUT
     jump  : j-by-1 vector of change-point positions for the i-th lambda value
     (j depends on lambda). i varies between 1 and kmax
     rse   : (kmax+1)-by-1 vector of residual squared error
     kbest : the number of selected change-points
     */
    void dpseg(const Mat& X, const vector<int>& cp, vector<vector<int> >& jumps,
               Mat& rse, int& kbest, double theta, int kmax=-1 );
    
    
    private:
    /*
     Segmentation of a multi-dimensional signal with the group fused LARS.
     
     INPUT
     X       : n-by-p matrix to be segmented (n: # obs, p: # dim).
     k       : the number of change points to find.
     epsilon : values smaller than epsilon are considered null.
     weights : (n-1)*1 vector of weights for the weighted graph fused LASSO.
     
     OUTPUT
     lambda     : estimated lambda values for each change-point
     jump       : successive change-point positions (1 x k)
     meansignal : mean signal per column (1 x p vector)
     */
    void gflars(const Mat& X, vector<int>& jumps, vector<double>& lambda,
                const int k, const double epsilon );
    
    
    /*
     Fast computation of Y' * X
     
     Compute R = Y'*X, where Y is the n-by-(n-1) design matrix for the weighted
     group fused lasso, with weights defined by the vector w, and X is a n-by-p
     data matrix. The computation is done in O(np).
     
     INPUT
     X : n-by-p matrix
     w : (n-1)-by-1 vector of weights
     
     OUTPUT
     R : (n-1)-by-p matrix equal to W' * X
     */
    void leftmultiplybyXt(const Mat& X, const Mat& w, Mat& R);
    
    
    /*
     Fast computation of inv(W'*W)*X
     
     Compute R = inv(W(:,ind)'*W(:,ind))*X, where W is the n-by-(n-1) design matrix
     
     INPUT
     X   : a-by-p matrix
     ind : a-by-1 vector of indices between 1 and n-1, sorted in an ascending order
     w   : (n-1)-by-1 vector of weights
     n   : the size of X is n-by-(n-1)
     
     OUTPUT
     R   : a-by-p matrix equal to inv(W'*W)*X
     */
    void leftmultiplybyinvXAtXA(const Mat& X, const vector<int>& ind,
                                const Mat& w, const int n, Mat& R);
    
    
    /*
     Fast computation of W' * W * X when X is sparse
     
     Compute R = W'*W*X, where X is a wor-sparse (n-1)-by-p matrix and W is the
     n-by-(n-1) design matrix
     
     INPUT
     X   : a-by-p matrix whose rows are the non-zero rows of the original X
     (same order as ind)
     ind : a-by-1 vector of indices of the non-zero rows of X (each in [1,n-1])
     w   : (n-1)-by-1 vector of weights
     n   : size of the problem
     
     OUTPUT
     R   : (n-1)-by-p matrix equal to W'*W*X
     */
    void multiplyXtXbysparse(const Mat& X, const vector<int>& ind,
                             const Mat& w, const int n, Mat& R);
    
    
    /* UTILITY FUNCTIONS */
    
    // dst = src(I)
    inline void get_subvector(const Mat& src, Mat& dst, const vector<int>& I)
    {
      dst = Mat( I.size(), 1, src.type() );
      for( size_t i=0; i<I.size(); i++ )
        dst.at<double>(i) = src.at<double>(I[i]);
    };
    
    // dst = src(I,:)
    inline void get_submatrix_row(const Mat& src, Mat& dst, const vector<int>& I)
    {
      dst = Mat( I.size(), src.cols, src.type() );
      for( size_t i=0; i<I.size(); i++ )
        src.row(I[i]).copyTo( dst.row(i) );
    };
    
    // dst = cumsum(src)
    inline void cumsum(const Mat& src, Mat& dst)
    {
      if( !dst.data )
        dst = Mat( src.rows, src.cols, src.type() );
      
      src.row(0).copyTo( dst.row(0) );
      for( int r=1; r<src.rows; r++)
        dst.row(r) = dst.row(r-1) + src.row(r);
    };
    
    // dst = sum(src.^2,2)
    inline void norm2sq( const Mat& src, Mat& dst, int dim)
    {
      if( dim==0 ) {// column-wise
        dst = Mat( 1, src.cols, src.type() );
        for(int c=0; c<src.cols; c++ )
          dst.at<double>(c) = cv::sum(src.col(c).mul(src.col(c)))[0];
      }
      else {
        dst = Mat( src.rows, 1, src.type() );
        for(int r=0; r<src.rows; r++)
          dst.at<double>(r) = cv::sum(src.row(r).mul(src.row(r)))[0];
      }
    }
    
    inline void check_nan(vector<double>& v) {
      for( size_t i=0; i<v.size(); i++ )
        if( v[i]!=v[i] )
          v[i]=0.0;
    };
    
    inline void print(Mat& X, string name)
    {
      cout << name << "_c=[" << endl;
      
      for(int r=0; r<X.rows; r++) {
        for( int c=0; c<X.cols; c++) {
          if( X.type()==CV_32F || X.type()==CV_64F )
            printf("%f ", X.at<double>(r,c));
          else
            printf("%d ", X.at<int>(r,c));
        }
        printf("\n");
      }
      printf("];\n\n");
    }
    
    inline void print(vector<int> v, string name)
    {
      cout << name << "_c=[";
      for(size_t i=0; i<v.size(); i++)
        printf("%d ", v[i]);
      printf("];\n\n");
    }
    
    inline void print(vector<double> v, string name)
    {
      cout << name << "_c=[";
      for(size_t i=0; i<v.size(); i++)
        printf("%f,", v[i]);
      printf("];\n\n");
    }
  };
  
}

#endif
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/include/hecate/hecate.hpp">
/*
 * HECTATE Video Processing Library
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_HPP
#define HECATE_HPP

#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <getopt.h>
#include <sys/stat.h> // mkdir
#include <unistd.h>   // access() function

#include <ctime>      // display date and time
#include <iostream>   // for standard I/O
#include <fstream>    // for file I/O
#include <string>     // for strings
#include <iomanip>    // for controlling float print precision
#include <sstream>    // string to number conversion
#include <chrono>
#include <limits>
#include <numeric>

// OpenMP library
#if defined(_OPENMP)
#include <omp.h>
#endif

// Hecate headers
#include "hecate/sort.hpp"
#include "hecate/time.hpp"
#include "hecate/gapstat.hpp"
#include "hecate/knapsack.hpp"
#include "hecate/cc_parser.hpp"
#include "hecate/file_helper.hpp"
#include "hecate/video_parser.hpp"
#include "hecate/ffmpeg_helper.hpp"

// OpenCV library
#include <opencv2/objdetect/objdetect.hpp>
#include <opencv2/ml/ml.hpp>

using namespace std;

// program options
struct hecate_params {
  string in_video;
  string out_dir;
  string caption;
  int step_sz;          // frame subsampling step size
  int njpg;             // number of thumbnail images
  int ngif;             // number of GIFs
  int lmov;             // length of video summary (in seconds)
  int gif_fps;          // gif play speed
  int jpg_width_px;     // thumbnail image width
  int gif_width_px;     // animated GIF width
  int mov_width_px;     // summary video width
  int max_duration;     // maximum length of video to process (in seconds)
  double fltr_begin_sec;// always filter out x-second frames at the beginning
  double fltr_end_sec;  // always filter out x-second frames at the end
  double invalid_wnd;   // window for dropping neighbor frames of low-quality ones
  bool jpg;             // generate thumbnail jpg
  bool gif;             // generate summary gif
  bool mov;             // generate summary movie
  bool gifsum;          // if enabled, combine individual GIFs into one summary
  bool gifall;          // generate all possible gifs (for debugging purpose)
  bool info_shot;       // print shot boundary info
  bool info_keyfrm;     // print key frame indices
  bool prefer_dynamic;  // if enabled, prefer dynamic scene in highlight
  bool gfl;             // run group-fused lasso as part of shot segmentation
  bool fade;            // disable fade-in/out during shot transition
  bool debug;
  bool display;
  
  hecate_params():
  out_dir("./output"),
  caption(""),
  step_sz(1),
  njpg(5),
  ngif(5),
  lmov(15),
  gif_fps(8),
  jpg_width_px(360),
  gif_width_px(360),
  mov_width_px(360),
  max_duration(-1),
  fltr_begin_sec(-1.0),
  fltr_end_sec(-1.0),
  invalid_wnd(0.15),
  jpg(false),
  gif(false),
  mov(false),
  gifsum(false),
  gifall(false),
  info_shot(false),
  info_keyfrm(false),
  prefer_dynamic(true),
  gfl(false),
  fade(false),
  debug(false),
  display(false)
  {};
};

inline void hecate_parse_params(int argc, char** argv, hecate_params& opt)
{
  static struct option long_options[] = {
    {"in_video",        required_argument, 0, 'i'},
    {"out_dir",         required_argument, 0, 'o'},
    {"step",            required_argument, 0, 's'},
    {"njpg",            required_argument, 0, 'n'},
    {"ngif",            required_argument, 0, 'q'},
    {"lmov",            required_argument, 0, 'l'},
    {"gif_fps",         required_argument, 0, 'f'},
    {"jpg_width_px",    required_argument, 0, 'u'},
    {"gif_width_px",    required_argument, 0, 'v'},
    {"mov_width_px",    required_argument, 0, 'w'},
    {"max_duration",    required_argument, 0, 'd'},
    {"fltr_begin_sec",  required_argument, 0, 'a'},
    {"fltr_end_sec",    required_argument, 0, 'b'},
    {"invalid_wnd",     required_argument, 0, 'k'},
    {"generate_jpg",      no_argument, 0, 'J'},
    {"generate_gif",      no_argument, 0, 'G'},
    {"generate_mov",      no_argument, 0, 'M'},
    {"optimize_gif",      no_argument, 0, 'O'},
    {"generate_gifsum",   no_argument, 0, 'S'},
    {"generate_gifall",   no_argument, 0, 'A'},
    {"print_shot_info",   no_argument, 0, 'T'},
    {"print_keyfrm_info", no_argument, 0, 'K'},
    {"prefer_dynamic",    no_argument, 0, 'V'},
    {"gfl",               no_argument, 0, 'B'},
    {"fade",              no_argument, 0, 'F'},
    {"debug",             no_argument, 0, 'D'},
    {"display",           no_argument, 0, 'C'},
    {0,0,0,0}
  };
  
  while( true ) {
    int opt_idx=0;
    int c = getopt_long( argc, argv,
                        "0:1:2:3:4:5:6:7:8:9:"
                        "a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:"
                        "A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z",
                        long_options, &opt_idx);
    if( c==-1 ) break;
    switch( c ) {
      case 'i': opt.in_video         = optarg; break;
      case 'o': opt.out_dir          = optarg; break;
      case 's': opt.step_sz          = atoi(optarg); break;
      case 'n': opt.njpg             = atoi(optarg); break;
      case 'q': opt.ngif             = atoi(optarg); break;
      case 'l': opt.lmov             = atoi(optarg); break;
      case 'f': opt.gif_fps          = atoi(optarg); break;
      case 'u': opt.jpg_width_px     = atoi(optarg); break;
      case 'v': opt.gif_width_px     = atoi(optarg); break;
      case 'w': opt.mov_width_px     = atoi(optarg); break;
      case 'd': opt.max_duration     = atof(optarg); break;
      case 'a': opt.fltr_begin_sec   = atof(optarg); break;
      case 'b': opt.fltr_end_sec     = atof(optarg); break;
      case 'k': opt.invalid_wnd      = atof(optarg); break;
      case 'J': opt.jpg              = true; break;
      case 'G': opt.gif              = true; break;
      case 'M': opt.mov              = true; break;
      case 'S': opt.gifsum = opt.gif = true; break;
      case 'A': opt.gifall = opt.gif = true; break;
      case 'T': opt.info_shot        = true; break;
      case 'K': opt.info_keyfrm      = true; break;
      case 'V': opt.prefer_dynamic   = true; break;
      case 'B': opt.gfl              = true; break;
      case 'F': opt.fade             = true; break;
      case 'D': opt.debug            = true; break;
      case 'C': opt.display          = true; break;
    }
  }
  
  // Create output dir (silently fails if dir already exists)
  mkdir( opt.out_dir.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH );
}



inline void hecate_copyright()
{
  printf("\n");
  printf("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n");
  printf(" HECATE Copyright 2016 Yahoo Inc.\n");
  printf("   Licensed under the terms of the Apache 2.0 License.\n");
  printf("   Developed by : Yale Song (yalesong@yahoo-inc.com)\n");
  printf("   Built on  : %s %s\n", __TIME__, __DATE__ );
  printf("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n");
}

inline void hecate_usage()
{
  hecate_params opt;
  printf("USAGE: hecate -i infile [options]\n");
  printf("\n");
  printf("  -i  --in_video      (string)    Input video file\n");
  printf("  -o  --out_dir       (string)    Output directory (%s)\n", opt.out_dir.c_str());
  printf("  -s  --step          (int)       Frame subsampling step size (%d)\n", opt.step_sz);
  printf("  -n  --njpg          (int)       Number of thumbnails to be generated (%d)\n", opt.njpg);
  printf("  -q  --ngif          (int)       Number of GIFs to be generated (%d)\n", opt.ngif);
  printf("  -r  --lmov          (int)       Length of video summary to be generated (in seconds) (%d)\n", opt.lmov);
  printf("  -u  --jpg_width_px  (int)       Pixel width of thumbnail images (%d)\n", opt.jpg_width_px);
  printf("  -v  --gif_width_px  (int)       Pixel width of animated GIFs (%d)\n", opt.gif_width_px);
  printf("  -w  --mov_width_px  (int)       Pixel width of summary video (%d)\n", opt.mov_width_px);
  printf("  --generate_jpg                  Generate thumbnail images\n");
  printf("  --generate_gif                  Generate animated GIFs\n");
  printf("  --generate_mov                  Generate a summary video\n");
  printf("  --generate_gifsum               Generate animated GIFs summary\n");
  printf("  --generate_gifall               Generate all possible animated GIFs\n");
  printf("  --print_shot_info               Print valid shot ranges\n");
  printf("  --print_keyfrm_info             Print keyframe indices\n");
  
  exit(-1);
}



/*******************************************************************************
 
 HECTATE INTERFACE
 
 INPUT:
 hecate_params opt : input option paramaters
 
 OUTPUT:
 vector<int> v_thumb_idx : thumbnail frame indices
 vector<hecate::Range> v_gif_range : highlight shot ranges for GIF creation
 vector<hecate::Range> v_mov_range : highlight shot ranges for video summarization
 
 *******************************************************************************/
void run_hecate( hecate_params& opt,
                 vector<int>& v_thumb_idx,
                 vector<hecate::Range>& v_gif_range,
                 vector<hecate::Range>& v_mov_range );

inline void run_hecate( hecate_params& opt, vector<int>& v_thumb_idx) {
  vector<hecate::Range> v_gif_range, v_mov_range;
  run_hecate( opt, v_thumb_idx, v_gif_range, v_mov_range );
}

inline void run_hecate( hecate_params& opt, vector<hecate::Range>& v_range) {
  vector<int> v_thumb_idx;
  vector<hecate::Range> v_xxx_range;
  
  if( opt.gif )
    run_hecate( opt, v_thumb_idx, v_range, v_xxx_range );
  else if( opt.mov )
    run_hecate( opt, v_thumb_idx, v_xxx_range, v_range );
}


/*******************************************************************************
 
 THUMBNAIL IMAGE GENERATION MODULE
 
 INPUT:
 hecate_params opt        : input option paramaters
 video_metadata meta      : video metadata
 vector<hecate::ShotRanges> v_shot_range
                          : shot boundaries
 const Mat& X             : input features
 const Mat& diff          : n-by-1 vector of frame-by-frame difference scores
 
 OUTPUT:
 vector<int> v_thumb_idx  : vector of frame index numbers for thumbnails
 
 *******************************************************************************/

void detect_thumbnail_frames( hecate_params& opt,
                              hecate::video_metadata& meta,
                              const vector<hecate::ShotRange>& v_shot_range,
                              const Mat& X,
                              const Mat& diff,
                              vector<int>& v_thumb_idx);

void generate_thumbnails( hecate_params& opt, vector<int>& v_thumb_idx );




/*******************************************************************************
 
 VIDEO SUMMARIZATION MODULE
 
 INPUT:
 hecate_params opt        : input option paramaters
 video_metadata meta      : video metadata
 vector<hecate::ShotRanges> v_shot_range
                          : shot boundaries
 const Mat& X             : input features
 const Mat& diff          : n-by-1 vector of frame-by-frame difference scores
 
 OUTPUT:
 vector<hecate::Ranges> v_highlight_range
                          : vector of highlight shot ranges
 
 *******************************************************************************/

void detect_highlight_shots( hecate_params& opt,
                             hecate::video_metadata& meta,
                             const vector<hecate::ShotRange>& v_shot_range,
                             const Mat& X,
                             const Mat& diff,
                             vector<hecate::Range>& v_highlight_range );

void generate_highlight_clips( hecate_params& opt,
                               vector<hecate::Range>& v_highlight_range );


////////////////////////////////////////////////////////////////////////////////
//
// VARIOUS HELPER FUNCTIONS
//
////////////////////////////////////////////////////////////////////////////////


inline void mark_invalid( vector<bool>& vec, int idx, int wnd_sz=0 )
{
  int vec_len = (int)vec.size();
  for(int i=max(0,idx-wnd_sz); i<=min(vec_len-1,idx+wnd_sz); i++)
    vec[i] = false;
}

inline void expand_invalid_frms( vector<bool>& valid, int k )
{
  vector<bool> valid_new = valid;
  
  int nfrm = (int) valid.size();
  for( int pos=1; pos<nfrm-1; pos++ )
  {
    if( !valid[pos] )
      for(int i=max(0,pos-k); i<=min(nfrm-1,pos+k); i++)
        valid_new[i] = false;
  }
  
  valid = valid_new;
}


#endif
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/include/hecate/hist_opencv.hpp">
/*
 * Compute histogram of [x] using OpenCV
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_HIST_OPENCV_HPP
#define HECATE_HIST_OPENCV_HPP

#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>

#if CV_MAJOR_VERSION > 2
#include <opencv2/imgproc/types_c.h>
#endif

using namespace cv;
using namespace std;

namespace hecate {
  
  
  inline void print( const Mat x, const string filename )
  {
    ofstream myfile;
    myfile.open( filename );
    myfile << x;
    myfile.close();
  }
  
  inline void calc_gray_hist( const Mat& img, Mat& hist, int nbins=128 )
  {
    // Gray histogram
    float _range_val_gry[] = {0,256};
    const float* _range_gry = {_range_val_gry};
    
    calcHist( &img, 1, 0, Mat(), hist, 1, &nbins, &_range_gry, true, false);
    normalize( hist, hist );
  }
  
  inline void calc_color_hist( const Mat& img, Mat& hist, int nbins=128 )
  {
    // Color histogram
    float _range_val_clr[] = {0,256};
    const float* _range_clr = {_range_val_clr};
    
    // CV_BGR2HSV, CV_BGR2HLS, CV_BGR2YCrCb
    Mat img_cvt;
    cvtColor( img, img_cvt, CV_BGR2HSV );
    
    vector<Mat> planes;
    split( img_cvt, planes );
    
    if( !hist.data )
      hist = Mat( 3*nbins, 1, CV_32F, Scalar(0,0,0)[0] );
    
    Mat hist0( hist, Rect(0,0*nbins,1,nbins) );
    Mat hist1( hist, Rect(0,1*nbins,1,nbins) );
    Mat hist2( hist, Rect(0,2*nbins,1,nbins) );
    
    calcHist( &planes[0], 1, 0, Mat(), hist0, 1, &nbins, &_range_clr, true, false);
    calcHist( &planes[1], 1, 0, Mat(), hist1, 1, &nbins, &_range_clr, true, false);
    calcHist( &planes[2], 1, 0, Mat(), hist2, 1, &nbins, &_range_clr, true, false);
    
    normalize( hist0, hist0 );
    normalize( hist1, hist1 );
    normalize( hist2, hist2 );
  }
  
  
  inline void orientation( const Mat& Gx, const Mat& Gy, Mat& ori )
  {
    double alpha = 180.0 / 3.14159265358979323846264338327950288419716939937510;
    
    ori = Mat( Gx.rows, Gx.cols, CV_32F, Scalar(0,0,0)[0] );
    for(int r=0; r<Gx.rows; r++) {
      for(int c=0; c<Gx.cols; c++) {
        double deg = atan2(Gy.at<float>(r,c), Gx.at<float>(r,c)) * alpha;
        deg = (deg>=0) ? deg : deg + 360.0;
        deg = (deg<180.0) ? deg : deg - 180.0;
        ori.at<float>(r,c) = deg;
      }
    }
  }
  
  
  inline void calc_edge_hist( const Mat& Gx, const Mat& Gy, Mat& hist, int nbins_ori=16, int nbins_mag=16 )
  {
    // Edge histogram
    float _range_val_ori[] = {0,180};
    float _range_val_mag[] = {0,256};
    const float* _range_ori = {_range_val_ori};
    const float* _range_mag = {_range_val_mag};
    
    Mat ori, mag;
    orientation( Gx, Gy, ori );
    cv::magnitude( Gx, Gy, mag );
    
    if( !hist.data )
      hist = Mat( nbins_ori+nbins_mag, 1, CV_32F, Scalar(0,0,0)[0] );
    
    Mat hist_ori( hist, Rect(0,0,1,nbins_ori) );
    Mat hist_mag( hist, Rect(0,nbins_ori,1,nbins_mag) );
    
    calcHist( &ori, 1, 0, Mat(), hist_ori, 1, &nbins_ori, &_range_ori, true, false );
    calcHist( &mag, 1, 0, Mat(), hist_mag, 1, &nbins_mag, &_range_mag, true, false );
    
    normalize( hist_ori, hist_ori );
    normalize( hist_mag, hist_mag );
  }
  
  inline void calc_edge_hist( const Mat& img_gray, Mat& hist, int nbins_ori=16, int nbins_mag=16 )
  {
    Mat Gx, Gy;
    Scharr( img_gray, Gx, CV_32F, 1, 0 ); // ddepth, dx, dy
    Scharr( img_gray, Gy, CV_32F, 0, 1 );
    
    calc_edge_hist( Gx, Gy, hist, nbins_ori, nbins_mag );
  }
  
  
  inline void calc_pyr_gray_hist( const Mat& img, Mat& hist, int nbins=128, int level=2)
  {
    int w = img.cols;
    int h = img.rows;
    
    int npatches = 0;
    for(int i=0; i<level; i++)
      npatches += pow(4,i);
    
    int hist_sz = nbins;
    
    if( !hist.data )
      hist = Mat( hist_sz*npatches, 1, CV_32F, Scalar(0,0,0)[0] );
    
    int patch = 0;
    for(int l=0; l<level; l++) {
      for(int x=0; x<pow(2,l); x++) {
        for(int y=0; y<pow(2,l); y++) {
          int p_width  = floor( w/pow(2,l) );
          int p_height = floor( h/pow(2,l) );
          int p_x = x*p_width;
          int p_y = y*p_height;
          Mat patch_img( img, Rect(p_x,p_y,p_width,p_height) );
          Mat patch_hist( hist, Rect(0,patch*hist_sz,1,hist_sz) );
          calc_gray_hist( patch_img, patch_hist, nbins );
          patch++;
        }
      }
    }
  }
  
  
  inline void calc_pyr_color_hist( const Mat& img, Mat& hist, int nbins=128, int level=2)
  {
    int w = img.cols;
    int h = img.rows;
    
    int npatches = 0;
    for(int i=0; i<level; i++)
      npatches += pow(4,i);
    
    int hist_sz = 3 * nbins;
    
    if( !hist.data )
      hist = Mat( hist_sz*npatches, 1, CV_32F, Scalar(0,0,0)[0] );
    
    int patch = 0;
    for(int l=0; l<level; l++) {
      for(int x=0; x<pow(2,l); x++) {
        for(int y=0; y<pow(2,l); y++) {
          int p_width  = floor( w/pow(2,l) );
          int p_height = floor( h/pow(2,l) );
          int p_x = x*p_width;
          int p_y = y*p_height;
          Mat patch_img( img, Rect(p_x,p_y,p_width,p_height) );
          Mat patch_hist( hist, Rect(0,patch*hist_sz,1,hist_sz) );
          calc_color_hist( patch_img, patch_hist, nbins );
          patch++;
        }
      }
    }
  }
  
  
  inline void calc_pyr_edge_hist( const Mat& img, Mat& hist, int nbins_ori=16, int nbins_mag=16, int level=2)
  {
    int w = img.cols;
    int h = img.rows;
    
    int npatches = 0;
    for(int i=0; i<level; i++)
      npatches += pow(4,i);
    
    int hist_sz = nbins_ori + nbins_mag;
    
    if( !hist.data )
      hist = Mat( hist_sz*npatches, 1, CV_32F, Scalar(0,0,0)[0] );
    
    int patch = 0;
    for(int l=0; l<level; l++) {
      for(int x=0; x<pow(2,l); x++) {
        for(int y=0; y<pow(2,l); y++) {
          int p_width  = floor( w/pow(2,l) );
          int p_height = floor( h/pow(2,l) );
          int p_x = x*p_width;
          int p_y = y*p_height;
          Mat patch_img( img, Rect(p_x,p_y,p_width,p_height) );
          Mat patch_hist( hist, Rect(0,patch*hist_sz,1,hist_sz) );
          calc_edge_hist( patch_img, patch_hist, nbins_ori, nbins_mag );
          patch++;
        }
      }
    }
  }
  
  
  inline void calc_pyr_edge_hist( const Mat& Gx, const Mat& Gy, Mat& hist, int nbins_ori=16, int nbins_mag=16, int level=2)
  {
    int w = Gx.cols;
    int h = Gx.rows;
    
    int npatches = 0;
    for(int i=0; i<level; i++)
      npatches += pow(4,i);
    
    int hist_sz = nbins_ori + nbins_mag;
    
    if( !hist.data )
      hist = Mat( hist_sz*npatches, 1, CV_32F, Scalar(0,0,0)[0] );
    
    int patch = 0;
    for(int l=0; l<level; l++) {
      for(int x=0; x<pow(2,l); x++) {
        for(int y=0; y<pow(2,l); y++) {
          int p_width  = floor( w/pow(2,l) );
          int p_height = floor( h/pow(2,l) );
          int p_x = x*p_width;
          int p_y = y*p_height;
          Mat patch_Gx( Gx, Rect(p_x,p_y,p_width,p_height) );
          Mat patch_Gy( Gy, Rect(p_x,p_y,p_width,p_height) );
          Mat patch_hist( hist, Rect(0,patch*hist_sz,1,hist_sz) );
          calc_edge_hist( patch_Gx, patch_Gy, patch_hist, nbins_ori, nbins_mag );
          patch++;
        }
      }
    }
  }
  
}

#endif
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/include/hecate/image_metrics.hpp">
/*
 * Various image metrics
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_IMAGE_METRICS_HPP
#define HECATE_IMAGE_METRICS_HPP

#include <math.h>
#include <stdio.h>
#include <cmath>
#include <string>
#include <vector>

#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>

#include <hecate/hist_opencv.hpp>

using namespace cv;
using namespace std;

namespace hecate {
  
  
#define VALIDATE(x) ( std::isnan(x) ) ? 0 : x
  
  /*------------------------------------------------------------------------
   Contrast is measured as the standard deviation of the pixel intensities.
   RMS contrast does not depend on the angular frequency content or the
   spatial distribution of contrast in the image
   https://en.wikipedia.org/wiki/Contrast_(vision)#RMS_contrast
   ------------------------------------------------------------------------*/
  inline double calc_rms_contrast( const Mat& gray_img )
  /*-----------------------------------------------------------------------*/
  
  {
    Mat I;
    gray_img.convertTo( I, CV_32FC1 );
    Scalar mu = cv::mean( I );
    I = I - mu[0];
    return VALIDATE(cv::norm(I)/sqrt(I.rows*I.cols));
  }
  
  /*------------------------------------------------------------------------
   Sharpness is measured as the sum of magnitude in frequency domain
   ------------------------------------------------------------------------*/
  inline double calc_sharpness( const Mat& gray_img )
  /*-----------------------------------------------------------------------*/
  {
    Mat img;
    gray_img.convertTo( img, CV_32FC1 );
    img *= 1./255;
    
    Mat dx, dy;
    Sobel( img, dx, img.type(), 1, 0, 3 );
    Sobel( img, dy, img.type(), 0, 1, 3 );
    magnitude( dx, dy, dx );
    
    int npixels = gray_img.rows * gray_img.cols;
    return VALIDATE(cv::sum(dx)[0] / npixels);
  }
  
  
  /*------------------------------------------------------------------------
   Brightness is measured as the relative luminance in colorimetric spaces
   https://en.wikipedia.org/wiki/Relative_luminance
   ------------------------------------------------------------------------*/
  inline double calc_brightness( const Mat& img )
  /*-----------------------------------------------------------------------*/
  {
    vector<Mat> bgr;
    split( img, bgr );
    for(size_t j=0; j<bgr.size(); j++)
      bgr[j].convertTo(bgr[j],CV_32F);
    
    // compute perceived brightness
    Mat img_pb = (0.2126*bgr[2] + 0.7152*bgr[1] + 0.0722*bgr[0])/255.0;
    return VALIDATE(mean( img_pb )[0]);
  }
  
  /*------------------------------------------------------------------------
   Uniformness is measured as the ratio between the 5% percentile pixel
   intensity histograms and the rest.
   ------------------------------------------------------------------------*/
  inline double calc_uniformity( const Mat& gray_img, int nbins=128 )
  /*-----------------------------------------------------------------------*/
  {
    double val = 0.0;
    
    Mat ghist;
    hecate::calc_gray_hist( gray_img, ghist, nbins );
    if( cv::sum(ghist)[0] == 0 ) {
      val = 1.0;
    }
    else {
      Mat hist_sorted;
      cv::sort( ghist, hist_sorted, CV_SORT_EVERY_COLUMN|CV_SORT_DESCENDING );
      hist_sorted /= cv::sum( hist_sorted )[0];
      for(int j=0; j<(int)(0.05*nbins); j++)
        val += (double) hist_sorted.at<float>(j);
    }
    return VALIDATE(val);
  }
  
  /*------------------------------------------------------------------------
   Symmetry is measured as the difference between edge orientation & magnitude
   histograms of the left and right halves.
   ------------------------------------------------------------------------*/
  inline double calc_asymmetry( const Mat& gray_img )
  /*-----------------------------------------------------------------------*/
  {
    Mat img_l( gray_img, Rect(0,0,gray_img.cols/2,gray_img.rows) );
    Mat img_r( gray_img, Rect(gray_img.cols/2,0,gray_img.cols/2,gray_img.rows) );
    
    Mat hist_l, hist_r;
    hecate::calc_edge_hist( img_l, hist_l );
    hecate::calc_edge_hist( img_r, hist_r );
    
    return VALIDATE((double)cv::norm( hist_l-hist_r ));
  }
  
  /*------------------------------------------------------------------------
   Third Saliency is measured as the residual saliency on the resized image,
   then collects the average saliency for each sub-window. It's an indicator
   of the informativeness of each window, but also of the general distribution
   of the content in the image.
   ------------------------------------------------------------------------*/
  inline vector<double> calc_third_saliency( const Mat& gray_img )
  {
    const int w = 3; // divide 128-by-128 image into 3-by-3 patches
    
    // 0-1 normalize & resize to 128-by-128
    Mat img;
    gray_img.convertTo( img, CV_32FC1 ); img *= 1./255;
    cv::resize( img, img, cv::Size(128,128), 0, 0, cv::INTER_AREA );
    
    //real is img image, im is zero
    Mat planes[]  = {Mat_<double>(img),               Mat::zeros(img.size(),CV_32FC1)};
    Mat planes2[] = {Mat::zeros(img.size(),CV_32FC1), Mat::zeros(img.size(),CV_32FC1)};
    Mat planesr[] = {Mat::zeros(img.size(),CV_32FC1), Mat::zeros(img.size(),CV_32FC1)};
    
    Mat complexI, magI, phasem;
    merge( planes, 2, complexI ); // Merges for FT
    dft( complexI, complexI );    //Forward DFT
    split( complexI, planes );    // planes[0] = Re(DFT(I), planes[1] = Im(DFT(I))
    magnitude( planes[0], planes[1], magI );    //DFT magnitude (amplitude)
    phase( planes[0], planes[1], phasem );      //DFT phase
    
    //log spectral amplitude
    cv::log( magI, magI );
    
    Mat smooth, kernel;
    smooth = Mat::zeros( img.size(), CV_32FC1 );
    kernel = Mat::zeros( Size(10,10), CV_32FC1 );
    kernel += Scalar::all( 0.01 ); //kernel for average filtering ( 0.01=1/(10*10) )
    
    //smoothed spectrum with average filtering
    cv::filter2D( magI, smooth, CV_32FC1, kernel, Point(-1,-1), 0, BORDER_REPLICATE );
    
    Mat diff;
    cv::subtract( magI, smooth, diff ); //spectral residual (log domain)
    cv::exp( diff, diff );              //spectral residual (real domain)
    
    //recover real and im part of the DFT after the residual
    polarToCart( diff, phasem, planes2[0], planes2[1] );
    
    //invert the DFT (we are back in the pixel domain! We have just created a Saliency Component)
    Mat result;
    merge( planes2, 2, complexI );
    dft( complexI, result, DFT_INVERSE+DFT_SCALE );
    split( result, planesr );                       // planes[0] = Re(DFT(I), planes[1] = Im(DFT(I))
    magnitude( planesr[0], planesr[1], result );	// sqrt(Re(DFT(I))^2 + Im(DFT(I))^2)
    
    normalize( result, result, 0, 2, cv::NORM_MINMAX );
    
    //compute the window dimensions
    float cx = result.cols/w;
    float cy = result.rows/w;
    vector<double> features;
    
    //local mean for each window
    for( int a=0; a<w; ++a ) {
      for( int b=0; b<w; ++b ) {
        Mat temp = result(Rect(cx*a, cy*b, cx, cy));
        double val = mean( temp )[0];
        features.push_back( VALIDATE(val) );
      }
    }
    
    return features;
  }
  /*-----------------------------------------------------------------------*/
  
  /*------------------------------------------------------------------------
   Entropy is measured -sum(p.*log2(p)), which is a statistical measure of
   randomness that can be used to characterize the texture of the imput image.
   http://www.mathworks.com/help/images/ref/entropy.html?refresh=true
   ------------------------------------------------------------------------*/
  inline double calc_entropy( const Mat& gray_img, int nbins=256 )
  /*-----------------------------------------------------------------------*/
  {
    double val=0.0;
    
    Mat ghist;
    hecate::calc_gray_hist( gray_img, ghist, nbins );
    for(int i=0; i<nbins; i++) {
      if( ghist.at<float>(i)!=0 )
        val -= ghist.at<float>(i) * log2(ghist.at<float>(i));
    }
    return VALIDATE(val);
  }
  
  
  /*------------------------------------------------------------------------
   Contrast balance is measured as the l2 distance between an original
   image and contrast-equalized image.
   ------------------------------------------------------------------------*/
  inline double calc_contrast_balance( const Mat& img )
  /*-----------------------------------------------------------------------*/
  {
    double res = 0;
    
    vector<Mat> hsv_planes;
    split( img, hsv_planes );
    
    //for each channel
    for (int pl=0; pl < 3; ++pl)
    {
      //equalize the histogram
      Mat img_hist_equalized;
      equalizeHist( hsv_planes[pl], img_hist_equalized );
      
      //compute the diff between original and equalized histograms
      res += cv::norm( hsv_planes[pl], img_hist_equalized ) /
      (double)(img.rows*img.cols);
    }
    
    //the larger the difference, the larger the contrast error. so we negate
    return VALIDATE(-res);
  }
  
  
  /*------------------------------------------------------------------------
   Exposure balance is measured as an absolute value of the skewness
   of the luminance histogram.
   ------------------------------------------------------------------------*/
  inline double calc_exposure_balance( const Mat& img )
  /*-----------------------------------------------------------------------*/
  {
    vector<Mat> hsv_planes;
    split( img, hsv_planes );
    
    /// Establish the number of bins
    const int histSize = 256;
    
    /// Set the ranges (for B,G,R)
    float range[] = { 0, 256 };
    const float *histRange = { range };
    
    cv::Mat hist;
    double res = 0;
    for (int pl=0; pl < 3; ++pl)
    {
      /// Compute the histograms:
      cv::calcHist( &hsv_planes[pl], 1, 0, cv::Mat(), hist, 1, &histSize, &histRange,
                   /*uniform: */true, /*accumulate: */false );
      cv::Scalar sump = cv::sum( hist );
      
      double mean = (double) sump[0] / hist.rows;
      
      cv::Mat prod;
      cv::multiply( (hist-mean), (hist-mean), prod);
      cv::Scalar sums = cv::sum( prod );
      
      cv::multiply( prod, (hist-mean), prod);
      cv::Scalar sumskew = cv::sum( prod );
      
      double result[2];
      result[0] = sqrt( (double) sums[0] / hist.rows );
      result[1] = (double) sumskew[0] / (hist.rows * result[0]*result[0]*result[0]);
      
      //absolute value of the skewness gives an idea of how much
      //the histogram of colors is incorrect
      res += std::abs( result[1] );
    }
    
    // the larger the skew, the larger the exposure error
    return VALIDATE(-res / 3);
  }
  
  /*------------------------------------------------------------------------
   JPEG quality is measured using the no-reference quality estimation of
   Z. Wang, H. R. Sheikh, and A. C. Bovik. No-reference perceptual quality
   assessment of jpeg compressed images. In ICIP, 2002.
   ------------------------------------------------------------------------*/
  inline double calc_jpeg_quality( const Mat& gray_img )
  /*-----------------------------------------------------------------------*/
  {
    // Convert to grayscale image with 64bit doubles
    cv::Mat img;
    gray_img.convertTo( img, CV_32FC1 );
    
    const int m = img.rows;
    const int n = img.cols;
    
    if (m<16 || n<16)
    {
      return -2.0;
    }
    
    // feature extraction: horizontal features
    Mat dh, dh1, dh2;
    dh1 = img( Rect(1, 0, n-1, m) );
    dh2 = img( Rect(0, 0, n-1, m) );
    dh = dh1 - dh2;
    
    double sum = 0;
    int count = 0;
    double sumz = 0;
    for (int i=0; i < m; ++i) {
      for (int j=0; j < n-2; ++j) {
        if ((j+1)%8==0 && j>0 && (j+1)<8*floor(n/8))
        {
          sum += std::abs( dh.at<double>(i,j) );
          count++;
        }
        double signval = copysign( 1.0, dh.at<double>(i,j) ) *
        copysign( 1.0, dh.at<double>(i,j+1) );
        if (signval < 0)
          sumz += 1;
      }
    }
    
    double bh = sum / count;
    double ah = (8.0 * mean( cv::abs(dh) )[0] - bh) / 7;
    double zh = sumz / (m * (n-2));
    
    // feature extraction: vertical features
    Mat dv1, dv2, dv;
    dv1 = img( Rect(0, 1, n, m-1) );
    dv2 = img( Rect(0, 0, n, m-1) );
    dv = dv1 - dv2;
    
    sum = 0;
    count = 0;
    sumz = 0;
    for (int i=0; i < m-2; ++i) {
      for (int j=0; j < n; ++j) {
        if ((i+1)%8==0 && i>0 && (i+1)<8*floor(m/8))
        {
          sum += std::abs( dv.at<double>(i,j) );
          count++;
        }
        double signval = copysign( 1.0, dv.at<double>(i,j) ) *
        copysign( 1.0, dv.at<double>(i,j+1) );
        if (signval < 0)
          sumz += 1;
      }
    }
    
    double bv = sum / count;
    double av = (8.0 * mean( cv::abs(dv) )[0] - bv) / 7;
    double zv = sumz / (n * (m-2));
    
    //combined features
    double B = (bh + bv) / 2;
    double A = (ah + av) / 2;
    double Z = (zh + zv) / 2;
    
    // Quality Prediction
    const double alpha = -245.8909;
    const double beta = 261.9373;
    const double gamma1 = -239.8886;
    const double gamma2 = 160.1664;
    const double gamma3 = 64.2859;
    
    double score = alpha + beta *
    std::pow( B, (gamma1/10000) ) *
    std::pow( A, (gamma2/10000) ) *
    std::pow( Z, (gamma3/10000) );
    
    return VALIDATE(score);
  }
  
}
#endif
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/include/hecate/knapsack.hpp">
/*
 * 0/1 Knapsack solver
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_KNAPSACK_HPP
#define HECATE_KNAPSACK_HPP

#include <stdio.h>

namespace hecate {
  
  template <typename T>
  inline T Tmax(T a, T b) {return (a>b) ? a : b; };
  
  template <typename T>
  inline void solve_01knapsack( const vector<T>& value, const vector<int>& weight,
                               const int budget, vector<bool>& solution)
  {
    int n = (int)value.size();
    solution.resize(n, false);
    
    // recursion
    vector<vector<T> > V( n+1, vector<T>(budget+1,0) );
    for( int i=1; i<=n; i++ )
      for( int w=1; w<=budget; w++ )
        V[i][w] = ( weight[i-1]>w )
        ? V[i-1][w] : Tmax( V[i-1][w], V[i-1][w-weight[i-1]] + value[i-1] );
    
    // backtrack
    int w = budget;
    for( int i=n; i>0; i-- ) {
      if( V[i][w]!=V[i-1][w] && V[i][w]==V[i-1][w-weight[i-1]]+value[i-1] ) {
        solution[i-1] = true;
        w -= weight[i-1];
      }
    }
  }
  
}
#endif
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/include/hecate/shot_range.hpp">
/*
 * Shot range definition
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_SHOT_RANGE_HPP
#define HECATE_SHOT_RANGE_HPP

#include <string>
#include <vector>

#include <hecate/sort.hpp>

namespace hecate {
  
  /*
   */
  class Range {
  public:
    int start;
    int end;
    vector<int> v_idx; // store indices (keyframe index)
    
  public:
    Range(int s, int e): start(s), end(e) {};
    
    inline int length() const { return end-start+1; };
    
    inline void print() const {
      printf("range(%d:%d) (%d) [", start, end, length() );
      for(size_t i=0; i<v_idx.size(); i++) {
        printf("%d", v_idx[i]);
        if( i+1<v_idx.size() )
          printf(",");
      }
      printf("]\n");
    };
  };
  
  /*
   */
  class ShotRange: public Range {
  public:
    vector<Range> v_range;
    
  public:
    ShotRange(int s, int e): Range(s,e) {};
    
    inline void print() const {
      printf("shot_range(%d:%d) (%d) [", start, end, length() );
      for(size_t i=0; i<v_idx.size(); i++) {
        printf("%d", v_idx[i]);
        if( i+1<v_idx.size() )
          printf(",");
      }
      printf("]\n");
      
      for(size_t i=0; i<v_range.size(); i++) {
        printf("  sub_");
        v_range[i].print();
      }
    };
  };
  
  /*
   */
  class Tag {
  public:
    string label;
    double score;
    
  public:
    Tag(string& l, double s): label(l), score(s) {};
    
    inline void print() const {
      printf("(%s,%f)", label.c_str(), score);
    }
  };
  
  /*
   */
  class RangeTag: public Range {
  public:
    vector<Tag> v_tag;
  
  public:
    RangeTag(int s, int e): Range(s,e) {};
    RangeTag(Range r): Range(r.start,r.end) {
      v_idx=r.v_idx;
    };
    
    inline void print() const {
      printf("range(%d:%d) (%d) [", start, end, length() );
      for(size_t i=0; i<v_idx.size(); i++) {
        printf("%d", v_idx[i]);
        if( i+1<v_idx.size() )
          printf(",");
      }
      printf("], tags: ");
      for(size_t i=0; i<v_tag.size(); i++)
        v_tag[i].print();
      printf("\n");
    };
    
    inline void sort() {
      vector<double> v_scores;
      for(size_t i=0; i<v_tag.size(); i++)
        v_scores.push_back( v_tag[i].score );
      vector<double> v_srtval;
      vector<size_t> v_srtidx;
      hecate::sort( v_scores, v_srtval, v_srtidx );
      vector<Tag> v_tag_new;
      for(size_t i=0; i<v_srtidx.size(); i++)
        v_tag_new.push_back( v_tag[v_srtidx[v_srtidx.size()-1-i]] );
      v_tag = v_tag_new;
    }
  };
  
  /*
   */
  class ShotRangeTag: public Range {
  public:
    vector<RangeTag> v_range_tag;
    
  public:
    ShotRangeTag(int s, int e): Range(s,e) {};
    ShotRangeTag(ShotRange& sr): Range(sr.start,sr.end) {
      v_idx = sr.v_idx;
      for(size_t i=0; i<sr.v_range.size(); i++) {
        RangeTag rt( sr.v_range[i] );
        v_range_tag.push_back( rt );
      }
    };
    
    inline void print() {
      printf("shot_range_tag(%d:%d) (%d) [", start, end, length() );
      for(size_t i=0; i<v_idx.size(); i++) {
        printf("%d", v_idx[i]);
        if( i+1<v_idx.size() )
          printf(",");
      }
      printf("]\n");
      
      for(size_t i=0; i<v_range_tag.size(); i++) {
        printf("  sub_");
        v_range_tag[i].print();
      }
    };
    
    inline void sort() {
      for(size_t i=0; i<v_range_tag.size(); i++)
        v_range_tag[i].sort();
    };
  };
  
}
#endif
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/include/hecate/sort.hpp">
/*
 * MATLAB-like sort
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_SORT_HPP
#define HECATE_SORT_HPP

#include <vector>
#include <algorithm>

namespace hecate {
  
  // Act like matlab's [Y,I] = SORT(X)
  // Input:
  //   unsorted  unsorted vector
  // Output:
  //   sorted     sorted vector, allowed to be same as unsorted
  //   index_map  an index map such that sorted[i] = unsorted[index_map[i]]
  template <class T>
  void sort(
            std::vector<T> &unsorted,
            std::vector<T> &sorted,
            std::vector<size_t> &index_map);
  
  // Act like matlab's Y = X[I]
  // where I contains a vector of indices so that after,
  // Y[j] = X[I[j]] for index j
  // this implies that Y.size() == I.size()
  // X and Y are allowed to be the same reference
  template< class T >
  void reorder(
               std::vector<T> & unordered,
               std::vector<size_t> const & index_map,
               std::vector<T> & ordered);
  
  ////////////////////////////////////////////////////////////////////////////////
  // Implementation
  ////////////////////////////////////////////////////////////////////////////////
  
  
  // Comparison struct used by sort
  template<class T> struct index_cmp
  {
    index_cmp(const T arr) : arr(arr) {}
    bool operator()(const size_t a, const size_t b) const
    {
      return arr[a] < arr[b];
    }
    const T arr;
  };
  
  template <class T>
  inline void sort(
            std::vector<T> & unsorted,
            std::vector<T> & sorted,
            std::vector<size_t> & index_map)
  {
    // Original unsorted index map
    index_map.resize(unsorted.size());
    for(size_t i=0;i<unsorted.size();i++)
    {
      index_map[i] = i;
    }
    // Sort the index map, using unsorted for comparison
    sort(
         index_map.begin(),
         index_map.end(),
         index_cmp<std::vector<T>& >(unsorted));
    
    sorted.resize(unsorted.size());
    reorder(unsorted,index_map,sorted);
  }
  
  // This implementation is O(n), but also uses O(n) extra memory
  template< class T >
  inline void reorder(
               std::vector<T> & unordered,
               std::vector<size_t> const & index_map,
               std::vector<T> & ordered)
  {
    // copy for the reorder according to index_map, because unsorted may also be
    // sorted
    std::vector<T> copy = unordered;
    ordered.resize(index_map.size());
    for(unsigned int i = 0; i<index_map.size();i++)
    {
      ordered[i] = copy[index_map[i]];
    }
  }
  
}
#endif
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/include/hecate/time.hpp">
/*
 * Time util
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_TIME_HPP
#define HECATE_TIME_HPP

#include <stdio.h>

#include <ctime>      // display date and time
#include <cmath>      // floor
#include <chrono>
#include <string>

namespace hecate {
  
  typedef std::chrono::high_resolution_clock Clock;
  typedef std::chrono::milliseconds milliseconds;
  
  inline double elapsed_time_ms( Clock::time_point from)
  {
    Clock::time_point now = Clock::now();
    milliseconds ms = std::chrono::duration_cast<milliseconds>( now - from );
    return (double)ms.count();
  }
  
  inline double print_elapsed_time( Clock::time_point from, const char* prefix)
  {
    int msec = (int) elapsed_time_ms(from);
    int sec = msec/1000;
    printf("%s: Elapsed time %02d:%02d:%04d\n", prefix, sec/60, sec%60, msec%1000);
    
    return msec / 1000.0;
  }
  
  inline std::string second2string(double sec, const std::string& format) {
    char buf[128];
    int hh, mm, ss, mss;
    hh  = (int) floor( sec/3600 );
    mm  = (int) floor( sec/60 ) % 60;
    ss  = (int) sec % 60;
    mss = (int) 10000*(sec - floor(sec));
    if( format == "hh:mm:ss.mss" ) {
      sprintf( buf, "%02d:%02d:%02d.%04d", hh,mm,ss,mss );
    }
    else if( format == "mm:ss.mss" ) {
      sprintf( buf, "%02d:%02d.%04d", 60*hh+mm,ss,mss );
    }
    std::string ret = buf;
    return ret;
  }
}
#endif
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/include/hecate/video_parser.hpp">
/*
 * Video Parser
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_VIDEO_PARSER_HPP
#define HECATE_VIDEO_PARSER_HPP

#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <getopt.h>
#include <sys/stat.h> // mkdir
#include <unistd.h>   // access() function

#include <ctime>      // display date and time
#include <iostream>   // for standard I/O
#include <fstream>    // for file I/O
#include <string>     // for strings
#include <iomanip>    // for controlling float print precision
#include <sstream>    // string to number conversion
#include <chrono>
#include <limits>
#include <numeric>

// OpenMP library
#if defined(_OPENMP)
#include <omp.h>
#endif

// OpenCV library
#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>

#if CV_MAJOR_VERSION > 3
#include <opencv2/videoio/legacy/constants_c.h>
#endif

#include "hecate/sort.hpp"
#include "hecate/gflseg.hpp"
#include "hecate/gapstat.hpp"
#include "hecate/shot_range.hpp"
#include "hecate/hist_opencv.hpp"
#include "hecate/image_metrics.hpp"

using namespace std;
using namespace cv;

namespace hecate {
  
  // video metadata struct
  struct video_metadata {
    int nframes;
    int width;
    int height;
    double duration; // in seconds
    double fps;
  };
  
  struct parser_params {
    int step_sz;
    double fltr_begin_sec;
    double fltr_end_sec;
    double max_duration; // in seconds
    bool gfl;      // use group-fused lasso to refine boundaries
    bool fltr_lq;  // filter low-quality frames
    bool fltr_rdt; // filter redundant frames
    bool debug;
    bool ignore_rest; // if video is too long, ignore the rest (true) or
                      // adjust step_sz (false). for vidtag this should be
                      // false, while for hecate this should be true
    
    parser_params():
    step_sz(1),
    fltr_begin_sec(0),
    fltr_end_sec(0),
    max_duration(-1),
    gfl(false),
    fltr_lq(true),
    fltr_rdt(true),
    debug(false),
    ignore_rest(false)
    {};
  };
  
  inline void print_video_metadata( const string filename,
                                    const hecate::video_metadata m ) {
    printf("%s\n  seconds=%.2f, nframes=%d, fps=%.2f, resolution=%dx%d\n",
           filename.c_str(), m.duration, m.nframes, m.fps, m.width, m.height);
  };
  
  class VideoParser {
  public:
    VideoParser();
    
    /* Perform video parsing */
    // max_duration is there to handle too long videos
    //   (100K frms ~= 1 hr long with 30 fps)
    // filter_first and filter_last is there to filter out
    //   a few frames from the beginning and at the end
    //   to manually handle logos, ending credits, etc.
    vector<hecate::ShotRange> parse_video(const string& in_video,
                                       hecate::parser_params opt);
    
    /* Get the number of valid frames */
    int get_nfrm_valid();
    
    /* Display video with shot boundary information */
    void play_video_filtered(const string& in_video,
                             int step_sz=1,
                             int max_frm_len=360);
    
    /* Get a vector of booleans representing valid frames */
    inline void get_frm_valid(vector<bool>& vec) {vec=_v_frm_valid;}
    
    /* Get effective step size */
    inline int get_effective_step_size() {return _step_sz;}
    
    /* Get extracted features */
    inline const Mat get_frame_features() {return _X_feat;}
    inline const Mat get_frame_diff_features() {return _X_diff;}
    
    
  private:
    /* Read video into the memory */
    int read_video(const string& in_video,
                   int step_sz=1,
                   double max_duration=30*60,
                   bool ignore_rest=false,
                   int max_frm_len=160);
    
    /* Filter first end last few frames */
    void filter_heuristic(double fltr_begin_sec=0,
                          double fltr_end_sec=0);
    
    /* Filter out low-quality frames */
    void filter_low_quality(double thrsh_bright=0.075,
                            double thrsh_sharp=0.08,
                            double thrsh_uniform=0.80 );
    
    /* Filter out frames during transition */
    void filter_transition(double thrsh_diff=0.50,
                           double thrsh_ecr=0.10 );
    
    /* Filter out redundant frames */
    void filter_redundant_and_obtain_subshots();
    
    /* Update shot ranges, filter out shots if too short */
    void update_shot_ranges(int min_shot_len=5);

    /* Perform post processing. Break up shots if too long */
    void post_process(double min_shot_sec=2.0, bool gfl=false);
    
    /* Perform SBD using heuristics: add next big diff if
     the new shot length is longer than min_shot_len */
    void sbd_heuristic(vector<double> v_diff, vector<int>& jump,
                       int njumps, int min_shot_len );
    
    // Helper functions
    
    /* Extract pyramid of histogram features */
    void extract_histo_features(int pyr_level=2,
                                bool omit_filtered=true,
                                int nbin_color_hist=128,
                                int nbin_edge_ori_hist=8,
                                int nbin_edge_mag_hist=8);
    
    void mark_invalid( vector<bool>& vec, int idx, int wnd_sz=0 );
    void mark_invalid( vector<bool>& vec, vector<string>& vec2,
                      int idx, const string msg, int wnd_sz=0 );
    
    void release_memory();
    
    
  public:
    hecate::video_metadata meta;
    vector<bool> _v_frm_valid;    // filtered frames
    vector<string> _v_frm_log;    // filtered frames msgs (debug)
    
  private:
    bool _debug;
    bool _display;
    int _step_sz;
    int _nfrm_total;   // number of frames BEFORE sampling
    int _nfrm_given;   // number of frames AFTER sampling
    int _video_width;
    int _video_height;
    double _video_fps;
    double _video_sec;
    
    Mat _X_feat; // frame-wise feature representation
    Mat _X_diff; // n-by-1 frame-by-frame difference first-order derivative
    Mat _X_ecr;  // n-by-1 ecr first-order derivative
    
    vector<Mat> _v_frm_rgb;       // rgb frames
    vector<Mat> _v_frm_gray;      // gray-scale frames
    
    vector<hecate::ShotRange> _v_shot_ranges;
  };
}


#endif
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/src/hecate/gflseg.cpp">
/*
 * GFLSEG Group Fused LASSO Change Point Detection solver
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 *
 * Implementation is based on:
 *   Kevin Bleakley and Jean-Philippe Vert.
 *     "The group fused lasso for multiple change-point detection."
 *   arXiv preprint arXiv:1106.4199 (2011).
 */

#include "hecate/gflseg.hpp"

using namespace std;
using namespace cv;
using namespace hecate;

void Segmenter::gflseg(const Mat& X, vector<int>& jumps, int k, double theta)
{
  double epsilon = 1e-9;
  
  // group fused LASSO solver
  vector<int> jmp1;
  vector<double> lambda;
  gflars( X, jmp1, lambda, k, epsilon );
  
  // DP optimizer
  vector<vector<int> > jmp2;
  Mat rse;
  int kbest = 0;
  dpseg( X, jmp1, jmp2, rse, kbest, theta, -1 );
  
  // return the optimal solution
  jumps.resize( (int)jmp2[kbest].size(), 0 );
  for( size_t i=0; i<jmp2[kbest].size(); i++)
    jumps[i] = jmp2[kbest][i];
  //jumps[jmp2[kbest].size()] = X.rows-1; // last index
};


void Segmenter::dpseg(const Mat& X, const vector<int>& cp, vector<vector<int> >& jumps,
                      Mat& rse, int& kbest, double theta, int kmax )
{
  int n = X.rows; // the length of the signal X
  int p = X.cols; // the dimension of the signal X
  
  // Prevent the likelihood from diverging too much
  if( kmax<0 )
    kmax = min((int)cp.size(), (int)floor(n/10));
  
  vector<int>::iterator it;
  vector<int> cp_srt = cp;
  std::sort( cp_srt.begin(), cp_srt.end() );
  
  // Compute boundaries of the smallest intervals considered
  // b = sort(union([0],union([n],option.candidatechangepoints)));
  vector<int> b(2+cp.size());
  vector<int> edge = {-1, n-1};
  it = set_union( edge.begin(), edge.end(), cp_srt.begin(), cp_srt.end(), b.begin() );
  b.resize( it-b.begin() );
  std::sort( b.begin(), b.end() );
  
  
  // k is the number of such intervals
  int k = (int)b.size()-1;
  
  
  // Compute the k-by-k matrix J such that J(i,j) for i<=j is the RSE when
  // intervals i-to-j are merged.
  //
  // According to Picard,
  // "J(i,j) is the cost of the path connecting i-to-j in k steps (k segments)"
  // http://pbil.univ-lyon1.fr/members/fpicard/franckpicard_fichiers/pdf/aCGH-stat.pdf
  Mat J( k,   k, X.type(), Scalar(0,0,0)[0] );
  Mat S( n+1, p, X.type(), Scalar(0,0,0)[0] ); // cumsum of the rows of X
  Mat v( n+1, 1, X.type(), Scalar(0,0,0)[0] ); // cumsum of squared norm of the rows of X
  
  // S = [zeros(1,size(X,2));cumsum(X)]; % cumsum of the rows
  Mat Ssub = S( Rect(0,1,p,n) ); cumsum( X, Ssub );
  
  // v = [0;cumsum(sum(X.*X,2))]; % cumsum of squared norm of the rows
  Mat vsub = v( Rect(0,1,1,n) );
  cv::reduce( X.mul(X), vsub, 1, CV_REDUCE_SUM );
  cumsum( vsub, vsub );
  
  for( int i=0; i<k; i++ ) {
    for( int j=i; j<k; j++ ) {
      int Istart = b[i]+1;
      int Iend = b[j+1];
      // Regularization term: 1/length * ||s[end]-s[start]||^2_2
      double penalty = pow(cv::norm(S.row(Iend+1)-S.row(Istart)),2.0)/(Iend-Istart+1);
      J.at<double>(i,j) = v.at<double>(Iend+1)-v.at<double>(Istart)-penalty;
    }
  }
  
  //
  // DP recursion
  //
  
  // V(i,j) is the best RSE for segmenting intervals 1 to j with at most i-1 change-points
  Mat V( kmax+1, k, X.type(), Scalar(0,0,0)[0] );
  Mat jumpmat( kmax, k, CV_32S, Scalar(-1,0,0)[0] );
  
  // With no change-points, V(1,j) is just the precomputed RSE for intervals 1 to j
  J.row(0).copyTo( V.row(0) );
  
  // The recursive formula
  // NOTE: minidx/maxidx in minMaxIdx are very, very confusing to use!
  int minidx[2]; double minval;
  for( int ki=0; ki<kmax; ki++ ) {
    for( int j=ki+1; j<k; j++ ) {
      Mat tmp = V(Rect(ki,ki,j-ki,1)) + J(Rect(j,ki+1,1,j-ki)).t();
      minMaxIdx( tmp, &minval, 0, minidx, 0 ); // row matrix
      V.at<double>(ki+1,j) = minval;
      jumpmat.at<int>(ki,j) = minidx[1]+ki;
    }
  }
  
  
  // Optimal segmentations
  for( int ki=0; ki<kmax; ki++ )
  {
    vector<int> jump_ki(ki+1, 0);
    jump_ki[ki] = jumpmat.at<int>( ki,k-1 );
    for( int i=ki-1; i>=0; i-- )
      jump_ki[i] = jumpmat.at<int>(i,jump_ki[i+1]);
    jumps.push_back( jump_ki );
  }
  
  
  // Convert interval index back to the last position before the jump
  for( int ki=0; ki<kmax; ki++ )
    for( size_t i=0; i<jumps[ki].size(); i++ )
      jumps[ki][i] = b[ 1+jumps[ki][i] ];
  
  
  // RSE as a fuction of the number of change-points
  V.col(k-1).copyTo( rse );
  
  
  //
  // Based on DP table, find the optimal number of change-points
  //
  
  // log-likelihood is -n/2*(J-log(n)+1+log(2*pi));
  Mat JJ; cv::log( rse, JJ );
  
  // normalize
  // >> JJtild = (JJ(Km)-JJ) / (JJ(Km)-JJ(1)) * (Km-1) + 1;
  int Km = JJ.rows;
  Mat JJtild = (JJ.at<double>(Km-1)-JJ) / (JJ.at<double>(Km-1)-JJ.at<double>(0)) * (Km-1) + 1;
  
  
  // find the inflexion point
  // >> res.kbest = max(find(diff(diff(Jtild))>option.threshold))+1;
  Mat dJJtild(Km-1,1,X.type(),Scalar(0,0,0)[0]);
  Mat ddJJtild(Km-2,1,X.type(),Scalar(0,0,0)[0]);
  for(int i=0; i<Km-1; i++)
    dJJtild.at<double>(i) = JJtild.at<double>(i+1) - JJtild.at<double>(i);
  for(int i=0; i<Km-2; i++)
    ddJJtild.at<double>(i) = dJJtild.at<double>(i+1) - dJJtild.at<double>(i);
  
  kbest = 0;
  for( int i=0; i<Km-2; i++ )
    if( ddJJtild.at<double>(i)>theta && i>kbest )
      kbest = i;
};


void Segmenter::gflars(const Mat& X, vector<int>& jumps,
                       vector<double>& lambda, const int k, const double epsilon)
{
  int n = X.rows; // the length of the signal X
  int p = X.cols; // the dimension of the signal X
  
  jumps.clear();
  lambda.clear();
  
  // Default weight w(i) = sqrt(n/(i*(n-i)))
  Mat weights( n-1, 1, X.type() );
  for( int i=0; i<n-1; i++ )
    weights.at<double>(i)= sqrt((double)n/((i+1)*(n-i-1)));
  
  // Auxilary variable to use MATLAB-like sort function. The variable vjmps
  // should always be synced with vector<int> jumps.
  vector<int> vsrtval;    // contains sorted values
  vector<size_t> vsrtidx; // contains sorted indices
  
  //
  // Initialize cHat = W'*X
  Mat cHat;
  leftmultiplybyXt(X,weights,cHat);
  
  vector<int> A; // Active set indices (sorted in an ascending order)
  Mat cHatSub; // Used to access cHat(A,:)
  
  //
  // Main loop to find the successive jumps
  for( int iter=0; iter<k; iter++ )
  {
    // Compute row-wise norms of cHat
    // >> cHatSquareNorm = sum(cHat.^2,2);
    Mat cHatSquareNorm;
    norm2sq( cHat, cHatSquareNorm, 1 ); // 0:col, 1:row-wise
    
    // >> [bigcHat,besti]=max(cHatSquareNorm);
    int besti[2];
    double bigcHat;
    minMaxIdx( cHatSquareNorm, 0, &bigcHat, 0, besti ); // col matrix
    
    //
    // In the first iteration, we add the most correlated feature to the
    // active set. For the other iterations, this is already done at the
    // end of the previous iteration
    if( iter==0 ) {
      jumps.push_back( besti[0] );
    }
    
    // Resize active set vector and cHatSub matrix
    A.resize( iter+1, 0 );
    cHatSub = Mat( iter+1, p, X.type(), Scalar(0,0,0)[0] );
    
    
    //
    // Compute the descent direction W = inv(X(:,A)'*X(:,A))*cHat(A,:)
    Mat W; // size of (iter+1)-by-p
    
    // >> [A,I]=sort(res.jump(1:iter));
    hecate::sort( jumps, A, vsrtidx );
    get_submatrix_row( cHat, cHatSub, A );
    
    // >> w = leftmultiplybyinvXAtXA(n,A,cHat(A,:),weights);
    leftmultiplybyinvXAtXA(cHatSub,A,weights,n,W);
    
    // >> B = multiplyXtXbysparse(n,A,w,weights);
    Mat B;
    multiplyXtXbysparse(W,A,weights,n,B);
    
    //
    // Compute the descent step
    //   For each i we find the largest possible step alpha by solving:
    //      norm(cHat(i,:)-alpha*B(i,:)) = norm(cHat(j,:)-alpha*B(j,:))
    //      where j is in the active set.
    //   We write it as a second order polynomial
    //      a1(i)*alpha^2 - 2* a2(i)*alpha + a3(i)
    
    Mat a1,a2,a3;
    Mat a1sub, a2sub, a3sub;
    Mat tmp1, tmp2, tmp3;
    vector<int> subset;
    
    // >> a1 = bigcHat - sum(B.^2,2);
    cv::reduce( B.mul(B), a1, 1, CV_REDUCE_SUM );
    a1 = bigcHat - a1;
    
    // >> a2 = bigcHat - sum(B.*cHat,2);
    cv::reduce( B.mul(cHat), a2, 1, CV_REDUCE_SUM );
    a2 = bigcHat - a2;
    
    // >> a3 = bigcHat - cHatSquareNorm;
    a3 = bigcHat - cHatSquareNorm;
    
    //
    // Now we solve it
    // >> gammaTemp = zeros(2*(n-1),1);
    Mat gammaTemp( 2*(n-1), 1, X.type(), Scalar(0,0,0)[0] );
    
    // First, those where we really have a second-order polynomial
    // >> subset = find(a1 > EPSILON);
    for( int i=0; i<a1.rows; i++ )
      if( a1.at<double>(i)>epsilon )
        subset.push_back(i);
    
    if( !subset.empty() )
    {
      get_subvector( a1, a1sub, subset );
      get_subvector( a2, a2sub, subset );
      get_subvector( a3, a3sub, subset );
      
      // tmp1 = sqrt( a2(subset).^2 - a1(subset).*a3(subset) )
      cv::sqrt( a2sub.mul(a2sub)-a1sub.mul(a3sub), tmp1);
      
      // >> gammaTemp(subset)
      // = (a2(subset) + sqrt( a2(subset).^2 - a1(subset).*a3(subset) )) ./ a1(subset);
      cv::divide( a2sub + tmp1, a1sub, tmp2);
      for( size_t i=0; i<subset.size(); i++ )
        gammaTemp.at<double>(subset[i]) = tmp2.at<double>(i);
      
      // >> gammaTemp(subset+n-1)
      // = (a2(subset) - sqrt( a2(subset).^2 - a1(subset).*a3(subset) )) ./ a1(subset);
      cv::divide( a2sub - tmp1, a1sub, tmp2);
      for( size_t i=0; i<subset.size(); i++ )
        gammaTemp.at<double>(subset[i]+n-1) = tmp2.at<double>(i);
      
      subset.clear();
    }
    
    //
    // then those where the quadratic term vanishes and we have a
    // first-order polynomial
    // >> subset = find((a1 <= EPSILON) & (a2 > EPSILON));
    for( int i=0; i<a1.rows; i++ )
      if( a1.at<double>(i)<=epsilon && a2.at<double>(i)>epsilon )
        subset.push_back(i);
    
    if( !subset.empty() )
    {
      get_subvector( a1, a1sub, subset );
      get_subvector( a2, a2sub, subset );
      get_subvector( a3, a3sub, subset );
      
      // >> gammaTemp(subset)     = a3(subset) ./ (2*a2(subset));
      // >> gammaTemp(subset+n-1) = a3(subset) ./ (2*a2(subset));
      cv::divide( a3sub, 2*a2sub, tmp2 );
      for( size_t i=0; i<subset.size(); i++ )
        gammaTemp.at<double>(subset[i]) = gammaTemp.at<double>(subset[i]+n-1) = tmp2.at<double>(i);
      
      subset.clear();
    }
    
    
    //
    // Finally the active set should not be taken into account, as well as
    // those for which the computation gives dummy solutions
    // >> maxg=max(gammaTemp)+1;
    double maxg; minMaxIdx(gammaTemp, 0, &maxg); maxg+=1.0;
    
    // >> subset = find((a1 <= EPSILON) & (a2 <= EPSILON));
    for( int i=0; i<a1.rows; i++ )
      if( a1.at<double>(i)<=epsilon && a2.at<double>(i)<=epsilon )
        subset.push_back(i);
    
    if( !subset.empty() )
    {
      // >> gammaTemp(subset) = maxg;
      // >> gammaTemp(n+subset) = maxg;
      for( size_t i=0; i<subset.size(); i++ )
        gammaTemp.at<double>(subset[i]) = gammaTemp.at<double>(subset[i]+n) = maxg;
      subset.clear();
    }
    
    // >> gammaTemp(A) = maxg;
    // >> gammaTemp(n+A-1) = maxg;
    for( size_t i=0; i<A.size(); i++ )
      gammaTemp.at<double>(A[i]) = gammaTemp.at<double>(A[i]+n-1) = maxg;
    
    // >> gammaTemp(gammaTemp<=0)=maxg;
    // >> gammaTemp(imag(gammaTemp)~=0) = maxg;
    for( int i=0; i<gammaTemp.rows; i++ )
      if( gammaTemp.at<double>(i)<=0 || gammaTemp.at<double>(i)!=gammaTemp.at<double>(i) )
        gammaTemp.at<double>(i) = maxg;
    
    //
    // Now we can take the minimum
    // >> [gamma,nexttoadd]=min(gammaTemp);
    double gamma;
    int nexttoadd[2];
    minMaxIdx( gammaTemp, &gamma, 0, nexttoadd, 0); // col matrix
    
    //
    // Update
    // >> res.value{iter} = zeros(iter,p);
    // >> res.value{iter}(I,:) = gamma*w;
    // >> if iter>1
    // >>     res.value{iter}(1:(iter-1),:) = res.value{iter}(1:(iter-1),:) + res.value{iter-1};
    // >> end
    
    // >> res.lambda(iter)=sqrt(bigcHat);
    lambda.push_back( sqrt(bigcHat) );
    
    // >> if iter<k
    // >>     res.jump(iter+1) = 1+mod(nexttoadd-1,n-1);
    // >>     cHat = cHat-gamma*a;
    // >> end
    if( iter+1<k ) {
      jumps.push_back( nexttoadd[0]%(n-1) );
      cHat = cHat - gamma*B;
    }
  }
};


// X is n-by-p, w is (n-1)-by-1, R is (n-1)-by-p
void Segmenter::leftmultiplybyXt(const Mat& X, const Mat& w, Mat& R)
{
  int n = X.rows;
  int p = X.cols;
  
  R = Mat( n-1, p, X.type() );
  
  // R = ([1:n-1]'*U(end,:)/n - U(1:end-1,:)) .* w(:,ones(1,p));
  Mat U; cumsum( X, U );
  
  // llt = [1:n-1]'
  Mat llt( n-1, 1, X.type() );
  for( int r=0; r<n-1; r++ )
    llt.at<double>(r) = (double)(r+1);
  
  Mat lt = llt*U.row(n-1)/n - U(Rect(0,0,p,n-1));
  for( int c=0; c<p; c++ )
    R.col(c) = lt.col(c).mul(w);
};



// X is a-by-p, w is (n-1)-by-1, R is a-by-p, ind is a-by-1, where 1<=a<=(n-1)
void Segmenter::leftmultiplybyinvXAtXA(const Mat& X, const vector<int>& ind,
                                       const Mat& w, const int n, Mat& R)
{
  int a = X.rows;
  int p = X.cols;
  R = Mat( a, p, X.type(), Scalar(0,0,0)[0] );
  
  if( a>0 )
  {
    // >> u = diff([0;ind;n])
    // Note: we convert C++ index system (zero-base) to MATLAB (one-base)
    Mat u( a+1, 1, X.type() );
    u.at<double>(0) = ind[0]+1; // [2 0 1] becomes [3 1 2]
    u.at<double>(a) = n - (ind[a-1]+1);
    for( int i=1; i<a; i++ )
      u.at<double>(i) = ind[i] - ind[i-1];
    
    // >> val = val ./ w(ind,ones(1,p))
    Mat val;  X.copyTo(val);
    Mat wsub; get_subvector(w, wsub, ind);
    for( int c=0; c<p; c++ )
      cv::divide( val.col(c), wsub, val.col(c) );
    
    // >> delta = diff( [zeros(1,p); val; zeros(1,p)] ) ./ u(:,ones(1,p))
    Mat delta( a+1, p, X.type(), Scalar(0,0,0)[0] );
    delta.row(0) = val.row(0)+0.0;
    delta.row(a) = -val.row(a-1);
    for( int r=1; r<a; r++ )
      delta.row(r) = val.row(r) - val.row(r-1);
    for( int c=0; c<p; c++ )
      cv::divide( delta.col(c), u, delta.col(c) );
    
    // >> R = - diff( delta )
    for(int r=0; r<a; r++)
      R.row(r) = delta.row(r) - delta.row(r+1);
    
    // >> R = R ./ w(ind,ones(1,p))
    for(int c=0; c<p; c++)
      cv::divide( R.col(c), wsub, R.col(c) );
  }
};



void Segmenter::multiplyXtXbysparse(const Mat& X, const vector<int>& ind,
                                    const Mat& w, const int n, Mat& R)
{
  int a = X.rows;
  int p = X.cols;
  
  R = Mat( n-1, p, X.type(), Scalar(0,0,0)[0] );
  if( a>0 )
  {
    Mat wsub; get_subvector(w, wsub, ind);
    Mat val; X.copyTo(val);
    
    // First multiply beta by the weights
    // >> val = val .* w(ind,ones(1,p));
    for(int c=0; c<p; c++)
      val.col(c) = val.col(c).mul(wsub);
    
    //  compute the matrix s of increments of r
    // >> S = zeros(n-1,p);
    Mat S( n-1, p, X.type(), Scalar(0,0,0)[0] );
    
    // >> S(ind,:) = val;
    for( size_t i=0; i<ind.size(); i++ )
      val.row(i).copyTo(S.row(ind[i]));
    
    // >> S = flipud(cumsum(flipud(S)));
    flip(S,S,0); cumsum(S,S); flip(S,S,0);
    
    // >> u = ind' * val; // don't forget to add ones
    Mat indv( 1, a, X.type() );
    for( size_t i=0; i<ind.size(); i++ )
      indv.at<double>(i) = (double)(ind[i]+1);
    Mat u = indv * val;
    
    // >> S = S - u(ones(n-1,1),:)/n;
    for( int r=0; r<n-1; r++ )
      S.row(r) = S.row(r) - u/n;
    
    // then make the cumsum
    // >> R = cumsum(S);
    cumsum( S, R );
    
    // then multiply the rows by the weights
    // >> R = R .* w(:,ones(1,p));
    for( int c=0; c<p; c++ )
      R.col(c) = R.col(c).mul(w);
  }
};
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/src/hecate/hecate_highlight.cpp">
/*
 * HECTATE Video Processing Library - Highlight
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#include "hecate/hecate.hpp"

using namespace std;
using namespace cv;


void detect_highlight_shots( hecate_params& opt, hecate::video_metadata& meta,
                            const vector<hecate::ShotRange>& v_shot_range,
                            const Mat& X, const Mat& diff,
                            vector<hecate::Range>& v_highlight_range)
{
  if( opt.gif && opt.mov ) {
    fprintf( stderr, "Fatal Error in detect_highlight_shots():"
            "opt.gif and opt.mov cannot be true at the same time.\n" );
    exit(-1);
  }
  
  v_highlight_range.clear();

  const int minK = 5;
  const int maxK = 30;

  ////////////////////////////////////////////////////////////////////////////
  //
  // Discard shots that are too short or too static
  //
  ////////////////////////////////////////////////////////////////////////////

  int min_shot_len, max_shot_len, min_num_shot;
  if( opt.mov ) {
    double addrate_min = 0.5 * sqrt(max(0.0,(double)opt.lmov-15.0)/45.0);
    double addrate_max = sqrt(max(0.0,(double)opt.lmov-15.0)/45.0);
    min_shot_len = floor((3.0+addrate_min) * meta.fps / opt.step_sz);
    max_shot_len = round((1.0+addrate_max) * min_shot_len);
    min_num_shot = ceil( opt.lmov / 3.0 );
    if( opt.debug ) {
      printf("detect_highlight_shots(): "
             "min_shot_len=%d, max_shot_len=%d, min_num_shot=%d, "
             "addrate_min=%f, addrate_max=%f\n",
             min_shot_len, max_shot_len, min_num_shot,
             addrate_min, addrate_max);
    }
  }
  else {
    min_shot_len = floor(1.5 * meta.fps / opt.step_sz);
    max_shot_len = ceil (4.5 * meta.fps / opt.step_sz);
    min_num_shot = opt.ngif;
  }

  // Active set containing candidates for highlight shots
  vector<hecate::Range> v_candidates;
  for(size_t i=0; i<v_shot_range.size(); i++) {
    hecate::Range shot(v_shot_range[i].start, v_shot_range[i].end);
    shot.v_idx = v_shot_range[i].v_idx;
    int shot_len = shot.length();
    double avg_diff=0;
    for(int i=shot.start; i<=shot.end; i++)
      avg_diff += diff.at<double>(i);
    avg_diff/=shot.length();
    
    // Discard if too short.
    if( shot_len < min_shot_len ) {
      //printf("Discard SHORT (shot_len=%d, avg_diff=%f) ", shot_len, avg_diff); shot.print();
      continue;
    }
    
    // Discard if too static
    if( avg_diff < 0.05 ) {
      //printf("Discard STATIC (shot_len=%d, avg_diff=%f) ", shot_len, avg_diff); shot.print();
      continue;
    }
    
    // Add the shot
    v_candidates.push_back( shot );
  }

  // If there's not enough shots, merged adjacent shots and add them
  if( (int)v_candidates.size() < min_num_shot ) {
    if( opt.debug ) {
      printf("detect_highlight_shots(): "
             "Not enough candidate shots (current=%d/%d, min=%d)\n",
             (int)v_candidates.size(), (int)v_shot_range.size(), min_num_shot);
    }
    for(size_t i=0; i<v_shot_range.size(); i++) {
      // Merge shots until it's longer than min_shot_len
      size_t j=i;
      int cumlen=0;
      while( (j+1)<v_shot_range.size() ) {
        cumlen += v_shot_range[j].length();
        if( cumlen<min_shot_len ) { j++; } else { break; }
      }
      // Construct a shot
      hecate::Range shot(v_shot_range[i].start, v_shot_range[j].end);
      shot.v_idx.clear();
      for(size_t k=i; k<=j; k++)
        shot.v_idx.insert( shot.v_idx.end(),
            v_shot_range[k].v_idx.cbegin(), v_shot_range[k].v_idx.cend());

      // Check if this shot is already in v_candidates
      bool exists = false;
      for( size_t k=0; k<v_candidates.size(); k++ ) {
        if( v_candidates[k].start >= shot.start &&
           v_candidates[k].start <= shot.end ) {
          exists = true; break;
        }
      }
      if( !exists && shot.length() >= min_shot_len ) {
        v_candidates.push_back( shot );
      }
      i = j+1;
    }

    // Sort candidate shots in a chronogical order
    vector<hecate::Range> v_candidates_tmp;
    vector<int> v_shot_nsrt; // shots in non-sorted order
    for( size_t i=0; i<v_candidates.size(); i++ )
      v_shot_nsrt.push_back( v_candidates[i].start );
    // sort wrt frame index in an ascending order
    vector<size_t> v_srt_idx; // contains idx
    vector<int> v_srt_val; // contains value (start frame idx)
    hecate::sort( v_shot_nsrt, v_srt_val, v_srt_idx );
    for(size_t i=0; i<v_srt_idx.size(); i++) {
      v_candidates_tmp.push_back( v_candidates[v_srt_idx[i]] );
    }
    v_candidates = v_candidates_tmp;
  }
  
  
  // Shorten shots if too long.
  // Prefer static shot; potentially reduces jitter
  for(size_t i=0; i<v_candidates.size(); i++) {
    hecate::Range shot = v_candidates[i];
    int shot_len = shot.length();
    if( shot_len > max_shot_len ) {
      while( shot_len > max_shot_len ) {
        Scalar mu, sigma, mu2, sigma2;
        meanStdDev( diff(Rect(0,shot.start+1,1,shot.length()-1)), mu, sigma );
        meanStdDev( diff(Rect(0,shot.start,  1,shot.length()-1)), mu2, sigma2 );
        if( sigma[0] < sigma2[0] )
          shot.start++;
        else
          shot.end--;
        shot_len = shot.length();
      }
    }
    v_candidates[i] = shot;
  }
  
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Group visually simimlar shots
  //
  // Represent each shot as a piece-wise constant multi-dimensional signal
  // Then run kmeans (k=#nshots_highlight).
  //
  ////////////////////////////////////////////////////////////////////////////
  
  // Prepare data for kmeans
  // Compute piece-wise constant feature representation
  Mat km_data( (int)v_candidates.size(), X.cols, X.type() );
  for( size_t shotid=0; shotid<v_candidates.size(); shotid++ ) {
    hecate::Range s = v_candidates[shotid];
    Mat Xsub = X( Rect(0, s.start, X.cols, s.length()) );
    cv::reduce( Xsub, km_data.row(shotid), 0, CV_REDUCE_AVG );
  }
  
  // Perform k-means (repeat 5 times)
  Mat km_lbl; // integer row vector; stores cluster IDs for every sample.
  Mat km_ctr; // one row per each cluster center.
  int km_k = min(maxK, min((int)v_candidates.size(), max(minK, min_num_shot)));
  hecate::perform_kmeans( km_data, km_lbl, km_ctr, km_k, 5 );
  
  // measure cluster size
  vector<int> v_shotlen;
  for(size_t i=0; i<v_candidates.size(); i++) {
    v_shotlen.push_back( v_candidates[i].length() );
  }
  vector<int> clust_sz(km_k,0);
  for(int i=0; i<km_lbl.rows; i++)
    clust_sz[ km_lbl.at<int>(i) ] += v_shotlen[i];
  
  // sort wrt cluster size in an ascending order
  vector<size_t> v_srt_idx; // contains cluster id
  vector<int> v_srt_val;    // contains cluster size
  hecate::sort( clust_sz, v_srt_val, v_srt_idx );
  
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Shot evaluation
  //
  // Criteria: prefer the most dynamic shot among others within the same cluster
  //
  ////////////////////////////////////////////////////////////////////////////
  
  // Pre-compute per-shot diff score avg & stddev
  Mat shot_diff_avg(v_candidates.size(), 1, diff.type(), Scalar(0,0,0)[0]);
  Mat shot_diff_std(v_candidates.size(), 1, diff.type(), Scalar(0,0,0)[0]);
  for( size_t shotid=0; shotid<v_candidates.size(); shotid++ ) {
    Scalar mu, sigma;
    hecate::Range s = v_candidates[shotid];
    meanStdDev( diff(Rect(0,s.start,1,s.length())), mu, sigma );
    shot_diff_avg.at<double>(shotid) = (double) mu[0];
    shot_diff_std.at<double>(shotid) = (double) sigma[0];
  }

  vector<int> v_shot_len;
  vector<double> v_shot_score;
  for(size_t i=0; i<v_candidates.size(); i++) {
    v_shot_len.push_back( v_candidates[i].length() );
    v_shot_score.push_back( 0.0 );
  }

  // Start with the largest cluster
  for(int i=0; i<km_k; i++)
  {
    int k = v_srt_idx[km_k-i-1];
    hecate::Range best_range(-1,-1);
    double best_val = -numeric_limits<double>::max();
    
    // Collect IDs & scores of the shots in the k-th cluster
    vector<int> v_tmp_shotid;
    vector<double> v_tmp_score;
    for(int shotid=0; shotid<km_lbl.rows; shotid++) {
      int lbl = km_lbl.at<int>(shotid);
      if( lbl==k ) {
        double val = shot_diff_avg.at<double>(shotid);
        if( val > best_val ) {
          best_range = v_candidates[shotid];
          best_val = val;
        }
        v_tmp_shotid.push_back( shotid );
        v_tmp_score.push_back( val );
      }
    }
    
    // If GIF mode, add shots here
    if( opt.gif ) {
      if( best_range.start>=0 && best_range.length()>0 )
        v_highlight_range.push_back( best_range );
      if( (int)v_highlight_range.size() >= opt.ngif )
        break;
    }
    
    // If MOV mode, store shot scores
    if( opt.mov ) {
      // Sort wrt avg_diff score, ascending order
      vector<size_t> v_srt_idx2;
      vector<double> v_srt_val2;
      hecate::sort( v_tmp_score, v_srt_val2, v_srt_idx2 );
      
      // Record normalized scores
      for( size_t i=0; i<v_srt_idx2.size(); i++ ) {
        // if prefer dynamic, higher avg_diff gets priority
        int order = (opt.prefer_dynamic) ? v_srt_idx2.size()-1-i : i;
        v_shot_score[v_tmp_shotid[v_srt_idx2[order]]] = 100.0/(1.0+(double(i)));
      }
    }
  }
  
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Shot selection
  //
  // Criteria: prefer the most dynamic shot among others within the same cluster
  //
  ////////////////////////////////////////////////////////////////////////////
  
  // Return all available segments
  if ( opt.gif ) {
    if( opt.gifall ) {
      v_highlight_range = v_candidates;
    }
  }
  
  if( opt.mov ) {
    int budget = floor(opt.lmov * meta.fps / opt.step_sz);
    budget += (int)(0.5 * max_shot_len); // buffer
    
    // solve 0/1 knapsack
    vector<bool> sol;
    hecate::solve_01knapsack( v_shot_score, v_shot_len, budget, sol );
    
    // merge shots if only they are only half a second apart
    int merge_thrsh = ceil(0.5 * meta.fps / opt.step_sz);
    for( size_t i=0; i<sol.size(); i++ ) {
      if( sol[i] ) {
        hecate::Range r = v_candidates[i];
        if( v_highlight_range.empty() ) {
          v_highlight_range.push_back( v_candidates[i] );
        }
        else {
          int dist = r.start - v_highlight_range[v_highlight_range.size()-1].end + 1;
          if( dist < merge_thrsh )
            v_highlight_range[v_highlight_range.size()-1].end = r.end;
          else
            v_highlight_range.push_back( v_candidates[i] );
        }
      }
    }
  }

  for(size_t i=0; i<v_highlight_range.size(); i++) {
    v_highlight_range[i].start *= opt.step_sz;
    v_highlight_range[i].end *= opt.step_sz;
  }
  
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Post Processing
  //
  // Ensures summary video length is exactly the same as required
  //
  ////////////////////////////////////////////////////////////////////////////
  
  // Ensures highlight ranges sums up to exactly target length
  if( opt.mov ) {
    int target = round(opt.lmov * meta.fps);
    int curlen = 0;
    for(size_t i=0; i<v_highlight_range.size(); i++) {
      curlen += v_highlight_range[i].length();
    }
    //printf("target=%d, cur=%d\n", target, curlen);
    if( curlen!=target ) {
      // If summary is too long
      while( curlen>target ) {
        // Pick a random shot
        int idx = rand() % (int) v_highlight_range.size();
        hecate::Range shot = v_highlight_range[idx];
        // Remove frame that reduces stddev of the shot by the most
        Scalar mu, sigma, mu2, sigma2;
        meanStdDev( diff(Rect(0,shot.start+1,1,shot.length()-1)), mu, sigma );
        meanStdDev( diff(Rect(0,shot.start,1,shot.length()-1)), mu2, sigma2 );
        if( sigma[0] < sigma2[0] )
          v_highlight_range[idx].start++;
        else
          v_highlight_range[idx].end--;
        curlen--;
      }
      // If video is longer than target, but summary is too short
      int shot_edge_buf = 10;
      int failed_attempt = 0;
      while( curlen<target ) {
        // Pick a random shot
        int idx = rand() % (int) v_highlight_range.size();
        hecate::Range shot = v_highlight_range[idx];
        
        // Add frame that increases stddev of the shot by the least
        bool failed = false;
        if( v_highlight_range[idx].start<shot_edge_buf ) {
          if( idx+1<v_highlight_range.size() && v_highlight_range[idx+1].start >
             v_highlight_range[idx].end+1+shot_edge_buf ) {
              v_highlight_range[idx].end++;
          }
          else {
            failed = true;
          }
        }
        else if( v_highlight_range[idx].end>meta.nframes-shot_edge_buf ) {
          if( idx>0 && v_highlight_range[idx-1].end <
             v_highlight_range[idx].start-1-shot_edge_buf ) {
            v_highlight_range[idx].start--;
          }
          else {
            failed = true;
          }
        }
        else {
          Scalar mu, sigma, mu2, sigma2;
          meanStdDev( diff(Rect(0,shot.start-1,1,shot.length()+1)), mu, sigma );
          meanStdDev( diff(Rect(0,shot.start,1,shot.length()+1)), mu2, sigma2 );
          if( sigma[0] < sigma2[0] ) {
            if( v_highlight_range[idx-1].end <
               v_highlight_range[idx].start-1-shot_edge_buf ) {
              v_highlight_range[idx].start--;
            }
            else {
              failed = true;
            }
          }
          else {
            if( v_highlight_range[idx+1].start >
               v_highlight_range[idx].end+1+shot_edge_buf) {
              v_highlight_range[idx].end++;
            }
            else {
              failed = true;
            }
          }
        }
        if( !failed )
          curlen++;
        else
          failed_attempt++;
        if( failed_attempt>10*(int)v_highlight_range.size() ) {
          if( opt.debug ) {
            printf("Failed to meet the target length in video summary\n");
          }
          break;
        }
      }
    }
    //curlen = 0;
    //for(size_t i=0; i<v_highlight_range.size(); i++)
    //  curlen += v_highlight_range[i].length();
    //printf("target=%d, cur=%d\n", target, curlen);
  }
}


////////////////////////////////////////////////////////////////////////////
//
// Highlight clip generation
//
////////////////////////////////////////////////////////////////////////////

void generate_highlight_clips( hecate_params& opt, vector<hecate::Range>& v_highlight_range )
{
  if( opt.gif && opt.mov ) {
    fprintf( stderr, "Fatal Error in generate_highlight_clips():"
            "opt.gif and opt.mov cannot be true at the same time.\n" );
    exit(-1);
  }
  
  // prefix for hiddden files generated during execution
  const char *cdot = "__tmp__";
  
  string filename = hecate::get_filename( std::string(opt.in_video) );
  
  VideoCapture vr( opt.in_video );
  double fps = vr.get(CV_CAP_PROP_FPS);
  vr.release();
  
  // Sort shots in chronological order
  vector<int> v_shot_nsrt; // shots in non-sorted order
  for( size_t i=0; i<v_highlight_range.size(); i++ )
    v_shot_nsrt.push_back( v_highlight_range[i].start );
  
  // sort wrt frame index in an ascending order
  vector<size_t> v_srt_idx; // contains idx
  vector<int> v_srt_val; // contains value (start frame idx)
  hecate::sort( v_shot_nsrt, v_srt_val, v_srt_idx );
  
  // For concatenating vieos clips
  char filelist[512];
  sprintf( filelist, "%s/%s%s_seg.txt",
          opt.out_dir.c_str(), cdot, filename.c_str() );
  FILE *ptr_filelist = fopen( filelist, "w+" );
  
  // Parse ttml-format caption, if provided
  vector<hecate::tcc> ttml;
  if( !opt.caption.empty() ) {
    parse_ttml( opt.caption, ttml );
    if( ttml.empty() ) {
      fprintf( stderr, "generate_animated_gifs: "
              "Caption file %s cannot be read\n", opt.caption.c_str() );
    }
    // Convert second to frame index
    for(size_t i=0; i<ttml.size(); i++) {
      ttml[i].start *= fps;
      ttml[i].end *= fps;
    }
  }
  
  // GENERATE CLIPS
  char cmd[1024];
  char infile[512];
  char outfile[512];
  
  for( size_t i=0; i<v_highlight_range.size(); i++ )
  {
    int shotid = v_srt_idx[i];
    hecate::Range r = v_highlight_range[shotid];
    double sec_from = (double) (r.start+1) / fps;
    double sec_duration = (double) (r.end-r.start) / fps;
    string start_pos = hecate::second2string( sec_from, "hh:mm:ss.mss" );
    string duration = hecate::second2string( sec_duration, "hh:mm:ss.mss" );
    
    // --------------------- VIDEO CLIP GENERATOR ---------------------
    if( opt.mov )
    {
      // Crop video segment
      sprintf( outfile, "%s/%s%s_seg%03d.mp4",
              opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
      hecate::ffmpeg_video_crop( opt.in_video, std::string(outfile),
                             start_pos, duration, opt.mov_width_px );
      
      // Apply video fade-in/out
      sprintf( infile, "%s/%s%s_seg%03d.mp4",
              opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
      sprintf( outfile, "%s/%s%s_segV%03d.mp4",
              opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
      if( opt.fade ) {
        hecate::ffmpeg_video_fade( std::string(infile), std::string(outfile),
                               r.end-r.start+1,i==0 );
      }
      else {
        sprintf( cmd, "mv %s %s", infile, outfile ); system( cmd );
      }
      
      // Apply audio fade-in/out
      sprintf( infile, "%s/%s%s_segV%03d.mp4",
              opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
      sprintf( outfile, "%s/%s%s_segAV%03d.mp4",
              opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
      hecate::ffmpeg_audio_fade( std::string(infile), std::string(outfile),
                             sec_duration, fps );
      
      // Log filename for concat
      fprintf( ptr_filelist, "file %s%s_segAV%03d.mp4\n",
              cdot, filename.c_str(), shotid);
    }
    // --------------------- VIDEO CLIP GENERATOR ---------------------
    
    // --------------------- GIF CLIP GENERATOR ---------------------
    if( opt.gif ) {
      if( opt.gifsum )
      {
        // Crop video segment
        sprintf( outfile, "%s/%s%s_seg%03d.mp4",
                opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
        hecate::ffmpeg_video_crop( opt.in_video, std::string(outfile),
                               start_pos, duration, opt.mov_width_px );
        
        // Convert video to gif
        sprintf( infile, "%s", outfile );
        sprintf( outfile, "%s/%s_%02d.gif",
                opt.out_dir.c_str(), filename.c_str(), shotid);
        hecate::ffmpeg_video2gif( std::string(infile), std::string(outfile),
                              "", "", opt.gif_fps, opt.gif_width_px );
        
        // Log filename for concat
        fprintf( ptr_filelist, "file %s%s_seg%03d.mp4\n",
                cdot, filename.c_str(), shotid);
      }
      else
      {
        // Convert video to gif, direct memory access without cropping
        sprintf( outfile, "%s/%s_%02d.gif",
                opt.out_dir.c_str(), filename.c_str(), shotid);
        hecate::ffmpeg_video2gif( opt.in_video, std::string(outfile),
                              start_pos, duration, opt.gif_fps,
                              opt.gif_width_px );
      }
    }
    // --------------------- GIF CLIP GENERATOR ---------------------
  }
  
  // Close filelist
  fclose( ptr_filelist );
  
  if( opt.mov )
  {
    // Concatenate segments
    sprintf( outfile, "%s/%s_sum.mp4",
            opt.out_dir.c_str(), filename.c_str() );
    hecate::ffmpeg_video_concat( filelist, outfile );
  }
  
  if( opt.gif && opt.gifsum )
  {
    // Concatenate segments
    sprintf( outfile, "%s/%s%s_segsum.mp4",
            opt.out_dir.c_str(), cdot, filename.c_str() );
    hecate::ffmpeg_video_concat( filelist, outfile );
    
    // Convert video to gif
    sprintf( infile, "%s", outfile );
    sprintf( outfile, "%s/%s_sum.gif",
            opt.out_dir.c_str(), filename.c_str());
    hecate::ffmpeg_video2gif( std::string(infile), std::string(outfile),
                          "", "", opt.gif_fps, opt.gif_width_px );
  }
  
  // Clean up
  sprintf( cmd, "rm %s/%s%s_seg*.*",
          opt.out_dir.c_str(), cdot, filename.c_str() );
  system( cmd );
}
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/src/hecate/hecate_main.cpp">
/*
 * HECTATE Video Processing Library - Main
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#include "hecate/hecate.hpp"

using namespace std;
using namespace cv;

void run_hecate( hecate_params& opt, vector<int>& v_thumb_idx,
                 vector<hecate::Range>& v_gif_range,
                 vector<hecate::Range>& v_mov_range)
{
  if( !hecate::file_exists(opt.in_video) ) {
    fprintf(stderr, "File not exist: %s\n", opt.in_video.c_str());
    return;
  }
  
  v_thumb_idx.clear();
  v_gif_range.clear();
  v_mov_range.clear();

  hecate::Clock::time_point t0;
  hecate::VideoParser parser;
  
  vector<hecate::ShotRange> v_shot_range;
  Mat histo_features;
  Mat diff_features;
  
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Parse video
  //
  ////////////////////////////////////////////////////////////////////////////
  
  if( opt.debug ) {
    printf("run_hecate: Video segmentation and keyframe extraction\n");
    t0 = hecate::Clock::now();
  }

  hecate::parser_params parser_opt;
  parser_opt.step_sz = opt.step_sz;
  parser_opt.gfl = opt.gfl;
  parser_opt.fltr_begin_sec = ( opt.fltr_begin_sec<0 )
      ? max(0.5, 0.05 * parser.meta.duration) : opt.fltr_begin_sec;
  parser_opt.fltr_end_sec = ( opt.fltr_end_sec<0 )
      ? max(0.5, 0.10 * parser.meta.duration) : opt.fltr_end_sec;
  parser_opt.max_duration = opt.max_duration;
  parser_opt.ignore_rest = (opt.max_duration>0); // ignore parts after max_nfrms
  parser_opt.debug = opt.debug;
  
  // PARSE
  v_shot_range = parser.parse_video( opt.in_video, parser_opt );
  if( v_shot_range.empty() ) {
    fprintf(stderr, "run_hecate: Failed to parse the video\n");
    return;
  }
  
  histo_features = parser.get_frame_features();
  diff_features  = parser.get_frame_diff_features();
  opt.step_sz    = parser.get_effective_step_size();
  
  // If video is shorter than desired summary length
  if( opt.mov && opt.lmov >= parser.meta.duration ) {
    fprintf( stderr, "run_hecate: Video duration is %.2f seconds, "
            "shorter than the requested summary of length %.2f seconds.\n"
            "\tVideo summarization is disabled.",
            parser.meta.duration, (double)opt.lmov);
    opt.mov = false;
  }
  
  // Check desired resolution of output
  if( opt.jpg_width_px<0 || opt.jpg_width_px > parser.meta.width ) {
    //fprintf( stderr, "run_hecate: Forcing jpg_width_px to %d\n",parser.meta.width);
    opt.jpg_width_px = parser.meta.width;
  }
  if( opt.gif_width_px<0 || opt.gif_width_px > parser.meta.width ) {
    //fprintf( stderr, "run_hecate: Forcing gif_width_px to %d\n",parser.meta.width);
    opt.gif_width_px = parser.meta.width;
  }
  if( opt.mov_width_px<0 || opt.mov_width_px > parser.meta.width ) {
    //fprintf( stderr, "run_hecate: Forcing mov_width_px to %d\n",parser.meta.width);
    opt.mov_width_px = parser.meta.width;
  }
  
  if( opt.debug ) {
    hecate::print_elapsed_time( t0, "run_hecate" );
    hecate::print_video_metadata( opt.in_video, parser.meta );
  }

  
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Analyze video
  //
  ////////////////////////////////////////////////////////////////////////////
  
  // Print shot info
  if( opt.info_shot ) {
    printf("shots: ");
    for(size_t i=0; i<v_shot_range.size(); i++) {
      printf("[%d:%d]", v_shot_range[i].start, v_shot_range[i].end);
      if( i<v_shot_range.size()-1 )
        printf(",");
    }
    printf("\n");
  }
  
  // Print keyframe indices
  if( opt.info_keyfrm ) {
    vector<int> keyfrms;
    for(size_t i=0; i<v_shot_range.size(); i++) {
      for(size_t j=0; j<v_shot_range[i].v_idx.size(); j++) {
        keyfrms.push_back(v_shot_range[i].v_idx[j]);
      }
    }
    
    printf("keyframes: [");
    for(size_t i=0; i<keyfrms.size(); i++) {
      printf("%d", keyfrms[i]);
      if( i<keyfrms.size()-1 )
        printf(",");
    }
    printf("]\n");
  }
  
  // Thumbnail extraction module
  if( opt.jpg ) {
    if( opt.debug ) {
      printf("run_hecate: Video keyframe detection\n");
      t0 = hecate::Clock::now();
    }
    
    detect_thumbnail_frames( opt, parser.meta, v_shot_range,
                             histo_features, diff_features,
                             v_thumb_idx);
    
    if( opt.debug ) {
      hecate::print_elapsed_time( t0, "run_hecate" );
    }
  }
  
  // GIF generation module
  if( opt.gif ) {
    if( opt.debug ) {
      printf("run_hecate: Video highlight detection for GIF creation\n");
      t0 = hecate::Clock::now();
    }
    
    bool mov = opt.mov;
    opt.mov = false;
    detect_highlight_shots( opt, parser.meta, v_shot_range,
                            histo_features, diff_features, v_gif_range );
    opt.mov = mov;
    if( opt.debug ) {
      hecate::print_elapsed_time( t0, "run_hecate" );
    }
  }
  
  // Video summarization module
  if( opt.mov ) {
    if( opt.debug ) {
      printf("run_hecate: Video highlight detection for summarization\n");
      t0 = hecate::Clock::now();
    }
    
    bool gif = opt.gif;
    opt.gif = false;
    detect_highlight_shots( opt, parser.meta, v_shot_range,
                            histo_features, diff_features, v_mov_range );
    opt.gif = gif;
    if( opt.debug ) {
      hecate::print_elapsed_time( t0, "run_hecate" );
    }
  }
}
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/src/hecate/hecate_thumbnail.cpp">
/*
 * HECATE Video Processing Library - Thumbnail
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#include "hecate/hecate.hpp"

using namespace std;
using namespace cv;

////////////////////////////////////////////////////////////////////////////
//
// Select most representative frames (thumbnails)
//
// Perform k-means++ (k=#thumbnails) over valid frames
// Thumbnails are selected by sorting clusters by their size and
//   selecting a frame from the longest subshot
//
////////////////////////////////////////////////////////////////////////////

void detect_thumbnail_frames( hecate_params& opt, hecate::video_metadata& meta,
                              const vector<hecate::ShotRange>& v_shot_range,
                              const Mat& X, const Mat& diff,
                              vector<int>& v_thumb_idx)
{
  v_thumb_idx.clear();

  const int minK = 5;   // min #clusters
  const int maxK = 30;  // max #clusters
  const int nfrm = meta.nframes;

  vector<bool> v_frm_valid(nfrm,false);
  for(size_t i=0; i<v_shot_range.size(); i++) {
    for(size_t j=0; j<v_shot_range[i].v_idx.size(); j++) {
      v_frm_valid[v_shot_range[i].v_idx[j]] = true;
    }
  }

  int nfrm_valid = accumulate(v_frm_valid.begin(),v_frm_valid.end(),0);
  if( nfrm_valid <= 1 ) {
    // If there's no valid frame, pick one most still frame
    int minidx=-1;
    double minval=numeric_limits<double>::max();
    for( int i=0; i<nfrm; i++ ) {
      double val = diff.at<double>(i);
      if( val<minval ) {
        minval = val;
        minidx = i;
      }
    }
    v_thumb_idx.push_back( minidx );
  }
  else if( nfrm_valid <= opt.njpg ) {
    // If not enough frames are left,
    // include all remaining keyframes sorted by shot length
    vector<int> v_shot_len;
    vector<int> v_keyfrm_idx;
    for(size_t i=0; i<v_shot_range.size(); i++) {
      int max_subshot_id=-1;
      int max_subshot_len=-1;
      for(size_t j=0; j<v_shot_range[i].v_range.size(); j++) {
        int shotlen = v_shot_range[i].v_range[j].length();
        if( shotlen>max_subshot_len ) {
          max_subshot_len = shotlen;
          max_subshot_id = j;
        }
      }
      v_shot_len.push_back(max_subshot_len);
      v_keyfrm_idx.push_back(v_shot_range[i].v_range[max_subshot_id].v_idx[0]);
    }

    // Include keyframes sorted by shot length
    vector<size_t> v_srt_idx;  // contains sorted indices
    vector<int> v_srt_val;     // contains sorted values
    hecate::sort( v_shot_len, v_srt_val, v_srt_idx );
    for(size_t i=0; i<v_srt_idx.size(); i++)
      v_thumb_idx.push_back( v_keyfrm_idx[v_srt_idx[v_srt_idx.size()-1-i]] );
  }
  else {
    vector<int> v_valid_frm_idx;
    vector<int> v_valid_frm_shotlen;
    for(size_t i=0; i<v_shot_range.size(); i++) {
      for(size_t j=0; j<v_shot_range[i].v_range.size(); j++) {
        v_valid_frm_idx.push_back( v_shot_range[i].v_range[j].v_idx[0] );
        v_valid_frm_shotlen.push_back( v_shot_range[i].v_range[j].length() );
      }
    }

    Mat km_data(nfrm_valid, X.cols, X.type());
    for(size_t i=0; i<v_valid_frm_idx.size(); i++) {
      X.row(v_valid_frm_idx[i]).copyTo( km_data.row(i) );
    }

    // Perform k-means (repeat 5 times)
    Mat km_lbl; // integer row vector; stores cluster IDs for every sample.
    Mat km_ctr; // one row per each cluster center.
    int km_k = min(maxK, min(nfrm_valid, max(minK, opt.njpg)));
    hecate::perform_kmeans( km_data, km_lbl, km_ctr, km_k, 5 );

    // For k-means with gap statistics
    //vector<int> Kset;
    //for(int i=km_k; i<=min(nfrm_valid,(int)(2*km_k)); i++)
    //  Kset.push_back( i );
    //km_k = hecate::perform_kmeans_gs( km_data, km_lbl, km_ctr, Kset, 3, 500 );

    // measure cluster size
    vector<int> clust_sz(km_k,0);
    for(int i=0; i<km_lbl.rows; i++)
      clust_sz[ km_lbl.at<int>(i) ] += v_valid_frm_shotlen[i];

    // sort wrt cluster size in an ascending order
    vector<size_t> v_srt_idx; // contains cluster id
    vector<int> v_srt_val;    // contains cluster size
    hecate::sort( clust_sz, v_srt_val, v_srt_idx );

    // obtain thumbnails -- the most still frame per cluster
    for(int i=0; i<km_k; i++) {
      int diff_min_idx = -1;
      double diff_min_val = numeric_limits<double>::max();
      for(int j=0; j<km_lbl.rows; j++) {
        if( km_lbl.at<int>(j) == v_srt_idx[km_k-i-1] ) {
          double mean_diff_j = diff.at<double>(v_valid_frm_idx[j]);
          if( mean_diff_j<diff_min_val ) {
            diff_min_idx = j;
            diff_min_val = mean_diff_j;
          }
        }
      }
      // Convert back to the real index
      v_thumb_idx.push_back( v_valid_frm_idx[diff_min_idx] );
    }
  }

  for(size_t i=0; i<v_thumb_idx.size(); i++)
    v_thumb_idx[i] *= opt.step_sz;
}



////////////////////////////////////////////////////////////////////////////
//
// Thumbnail generation
//
////////////////////////////////////////////////////////////////////////////
void generate_thumbnails( hecate_params& opt, vector<int>& v_thumb_idx )
{
  char strbuf[256];
  int njpg_cnt = 0;
  int frm_idx = 0;

  string filename = hecate::get_filename( std::string(opt.in_video) );

  VideoCapture vr( opt.in_video );
  double rsz_ratio = (double)(2+opt.jpg_width_px)/vr.get(CV_CAP_PROP_FRAME_WIDTH);
  while( njpg_cnt < (int)v_thumb_idx.size() )
  {
    Mat frm; vr>>frm;
    if( frm.empty() ) break;

    // Check if the current frame is in the selected thumbnail list
    int rank = -1;
    for( size_t i=0; i<v_thumb_idx.size(); i++ ) {
      if( frm_idx==v_thumb_idx[i] ) {
        rank = (int)i;
        break;
      }
    }

    // Save that thumbnail
    if( rank>=0 && rank<opt.njpg ) {
      resize( frm, frm, Size(), rsz_ratio, rsz_ratio, CV_INTER_LINEAR );
      frm = frm(Rect(0,0,frm.cols-2,frm.rows));
      sprintf( strbuf, "%s/%s_%02d.jpg",
              opt.out_dir.c_str(), filename.c_str(), rank );
      imwrite( strbuf, frm );
      njpg_cnt++;
    }

    if (njpg_cnt >= opt.njpg) {
        break;
    }

    frm_idx++;
  }
  vr.release();
}
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/src/hecate/video_parser.cpp">
/*
 * Video Parser
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#include "hecate/video_parser.hpp"

using namespace std;
using namespace cv;
using namespace hecate;

/*-----------------------------------------------------------------------*/
VideoParser::VideoParser()
/*-----------------------------------------------------------------------*/
{
  _debug = false;
  _display = false;
  
  _nfrm_total = 0;
  _nfrm_given = 0;
  
  _v_shot_ranges.clear();
}

/*-----------------------------------------------------------------------*/
void VideoParser::release_memory()
/*-----------------------------------------------------------------------*/
{
  _v_frm_rgb.clear();
  _v_frm_gray.clear();
}

/*-----------------------------------------------------------------------*/
vector<hecate::ShotRange> VideoParser::parse_video(const string& in_video,
                                                hecate::parser_params opt)
/*-----------------------------------------------------------------------*/
{
  _debug = opt.debug;
  
  int ret = read_video( in_video, opt.step_sz, opt.max_duration,
                       opt.ignore_rest );
  if( ret<0 ) {
    fprintf( stderr, "VideoParser: Failed to open input video: %s\n",
            in_video.c_str());
    return vector<hecate::ShotRange>();
  }
  
  // Record metadata
  meta.nframes  = _nfrm_total;
  meta.width    = _video_width;
  meta.height   = _video_height;
  meta.fps      = _video_fps;
  meta.duration = _video_sec;
  
  // Frame filtering
  if( opt.fltr_begin_sec>.0 || opt.fltr_end_sec>.0 )
    filter_heuristic(opt.fltr_begin_sec, opt.fltr_end_sec);
  
  if( opt.fltr_lq )
    filter_low_quality();
  
  filter_transition();
  
  // Extract feature representation
  extract_histo_features();
  
  // Post-process (break up shots if too long)
  double min_shot_len_sec = 2.0;
  post_process(min_shot_len_sec, opt.gfl);
  
  release_memory();
  
  // Store shot information
  update_shot_ranges();
  
  // Subshot detection; subshot info is stored during this step
  if( opt.fltr_rdt )
    filter_redundant_and_obtain_subshots();
  
  if( _display )
    play_video_filtered( in_video, 2, 360 );
  
  // Produce result
  return _v_shot_ranges;
}

/*------------------------------------------------------------------------
 Read input video and store as RGB and GRAY formats.
 ------------------------------------------------------------------------*/
int VideoParser::read_video( const string& in_video, int step_sz,
                            double max_duration, bool ignore_rest,
                            int max_frm_len)
/*-----------------------------------------------------------------------*/
{
  if( _debug )
    printf("VideoParser: read_video(\"%s\", \n\tstep_sz=%d, "
           "max_duration=%.2f, max_frm_len=%d, ignore_rest=%d)\n",
           in_video.c_str(), step_sz, max_duration, max_frm_len, ignore_rest);
  
  VideoCapture vr( in_video );
  if( !vr.isOpened() ) {
    return -1;
  }
  
  _nfrm_total   = vr.get(CV_CAP_PROP_FRAME_COUNT);
  _video_width  = vr.get(CV_CAP_PROP_FRAME_WIDTH);
  _video_height = vr.get(CV_CAP_PROP_FRAME_HEIGHT);
  _video_fps    = max(1.0, vr.get(CV_CAP_PROP_FPS));
  if( _video_fps!=_video_fps )
    _video_fps = 29.97;
  
  int max_nfrms = (max_duration<0)
  ? _nfrm_total : round(max_duration*_video_fps);
  
  // need to store _step_sz for computing min_shot_len in sbg_gflseg()
  _step_sz = step_sz;
  if( step_sz>10 ) {
    _step_sz = 10;
    fprintf( stderr, "VideoParser: The maximum step size is 10"
            " (provided is %d)\n", step_sz );
  }
  // if video is too long, and ignore_rest is false, adjust step size
  if( !ignore_rest && max_nfrms > 0 && _nfrm_total > max_nfrms ) {
    _step_sz = ceil( _nfrm_total/max_nfrms );
    fprintf( stderr, "VideoParser: Video too long (%d frames),"
            "increasing step size to %d\n", _nfrm_total, step_sz );
  }
  _step_sz = max(1, _step_sz);
  
  int maxlen = max( _video_width, _video_height );
  double rsz_ratio = (maxlen>max_frm_len)
  ? (double) max_frm_len / maxlen : -1.0;
  
  // Read RGB frames
  _nfrm_total=0; // reset because vr.get is known to be inaccurate
  while( true )
  {
    Mat frm;
    vr >> frm;
    if( frm.empty() ) break;
    
    if( _nfrm_total % _step_sz == 0 ) {
      if( rsz_ratio>0 )
        resize( frm, frm, Size(), rsz_ratio, rsz_ratio, CV_INTER_LINEAR );
      _v_frm_rgb.push_back( frm );
      
      // if video is too long, and ignore_rest is true, cut the rest
      if( ignore_rest && _nfrm_total>=max_nfrms ) {
        if( _debug )
          printf("VideoParser: video too long, "
                 "cutting at (%d)-th frame\n", _nfrm_total);
        break;
      }
    }
    _nfrm_total++;
  }
  vr.release();
  
  _nfrm_given = (int) _v_frm_rgb.size();
  _video_sec  = (double)_nfrm_total/_video_fps;
  
  // RGB2GRAY
  _v_frm_gray.assign( _nfrm_given, Mat() );
  
#pragma omp parallel for
  for( int i=0; i<_nfrm_given; i++ )
  {
    Mat frm_gray;
    cvtColor( _v_frm_rgb[i], frm_gray, CV_BGR2GRAY );
    GaussianBlur( frm_gray, frm_gray, Size(3,3), 0, 0 );
    frm_gray.copyTo( _v_frm_gray[i] );
  }
  
  _v_frm_valid.assign( _nfrm_given, true );
  _v_frm_log.assign( _nfrm_given, " " );
  
  _X_diff = Mat( _nfrm_given, 1, CV_64F, Scalar(0,0,0)[0] );
  _X_ecr  = Mat( _nfrm_given, 1, CV_64F, Scalar(0,0,0)[0] );
  
  return 0;
}


/*------------------------------------------------------------------------
 Manually invalidate first and last frames (heuristic)
 ------------------------------------------------------------------------*/
void VideoParser::filter_heuristic(double fltr_begin_sec, double fltr_end_sec)
/*-----------------------------------------------------------------------*/
{
  int fltr_begin_nfrms = ceil(fltr_begin_sec * _video_fps / (double)_step_sz);
  int fltr_end_nfrms = ceil(fltr_end_sec * _video_fps / (double)_step_sz);
  
  for(int i=0; i<fltr_begin_nfrms; i++)
    mark_invalid(_v_frm_valid, _v_frm_log, i, "[Begin]");
  for(int i=0; i<fltr_end_nfrms; i++)
    mark_invalid(_v_frm_valid, _v_frm_log, _nfrm_total-1-i, "[End]");
}


/*------------------------------------------------------------------------
 Use a collection of heuristics to filter out low-quality frames.
 ------------------------------------------------------------------------*/
void VideoParser::filter_low_quality( double thrsh_bright,
                                     double thrsh_sharp,
                                     double thrsh_uniform )
/*-----------------------------------------------------------------------*/
{
  // filter at most n percent of the total frames
  int nfrm_nperc = (int)(0.15*_nfrm_given);
  
  vector<double> v_brightness(_nfrm_given,0.0);
  vector<double> v_sharpness(_nfrm_given,0.0);
  vector<double> v_uniformity(_nfrm_given,0.0);
  
#pragma omp parallel for
  for( int i=0; i<_nfrm_given; i++ ) {
    v_brightness[i] = hecate::calc_brightness( _v_frm_rgb[i]  );
    v_sharpness[i]  = hecate::calc_sharpness(  _v_frm_gray[i] );
    v_uniformity[i] = hecate::calc_uniformity( _v_frm_gray[i] );
  }
  
  vector<size_t> v_srt_idx; // contains sorted indices
  vector<double> v_srt_val; // contains sorted values
  
  // DARK frame detection
  hecate::sort( v_brightness, v_srt_val, v_srt_idx );
  for( int i=0; i<nfrm_nperc; i++ )
    if( v_srt_val[i] <= thrsh_bright )
      mark_invalid(_v_frm_valid, _v_frm_log, v_srt_idx[i], "[Dark]");
  
  // BLURRY frame detection
  hecate::sort( v_sharpness, v_srt_val, v_srt_idx );
  for( int i=0; i<nfrm_nperc; i++ )
    if( v_srt_val[i] <= thrsh_sharp )
      mark_invalid(_v_frm_valid, _v_frm_log, v_srt_idx[i], "[Blurry]");
  
  // UNIFORM frame detection
  hecate::sort( v_uniformity, v_srt_val, v_srt_idx );
  for( int i=0; i<nfrm_nperc; i++ )
    if( v_srt_val[_nfrm_given-i-1] >= thrsh_uniform )
      mark_invalid(_v_frm_valid, _v_frm_log, v_srt_idx[_nfrm_given-i-1], "[Uniform]");
}


/*------------------------------------------------------------------------
 Frames around shot boundaries are usually low-quality, filter them out
 Use two SBD methods: frame-by-frame difference and ECR
 ------------------------------------------------------------------------*/
void VideoParser::filter_transition( double thrsh_diff, double thrsh_ecr )
/*-----------------------------------------------------------------------*/
{
  int nfrm_nperc = (int)(0.10*_nfrm_given); // n percent of the total frames
  
  vector<double> v_diff(_nfrm_given, 0.0);
  vector<double> v_ecr(_nfrm_given, 0.0);
  
  // sort wrt cluster size in an ascending order
  vector<size_t> v_srt_idx; // contains sorted indices
  vector<double> v_srt_val;    // contains sorted values
  
  // compute the first-order derivative frame-by-frame difference
  int img_sz = _v_frm_gray[0].cols * _v_frm_gray[0].rows;
#pragma omp parallel for
  for( int i=1; i<_nfrm_given-1; i++ ) {
    v_diff[i] = (double) (cv::norm( (_v_frm_rgb[i]-_v_frm_rgb[i-1]) )
                          + cv::norm( (_v_frm_rgb[i]-_v_frm_rgb[i+1]) )) / (2.0*img_sz);
    _X_diff.at<double>(i) = v_diff[i];
  }
  
  // compute edge-change-ratio (ECR)
  {
    int dl_sz = 5; // dilute size
    Mat dl_elm = getStructuringElement(MORPH_CROSS,
                                       Size(2*dl_sz+1, 2*dl_sz+1),
                                       Point(dl_sz, dl_sz));
    
    // Pre-compute edge & edge dilation
    vector<Mat> v_edge( _nfrm_given, Mat() );    // edge images
    vector<Mat> v_edge_dl( _nfrm_given, Mat() ); // edge-diluted images
    
#pragma omp parallel for
    for(int i=0; i<_nfrm_given; i++)
    {
      Mat tmp;
      double theta = threshold(_v_frm_gray[i],tmp,0,255,CV_THRESH_BINARY|CV_THRESH_OTSU);
      Canny( _v_frm_gray[i], v_edge[i], theta, 1.2*theta);
      dilate( v_edge[i], v_edge_dl[i], dl_elm );
      v_edge[i] -= 254; v_edge_dl[i] -= 254;
    }
    
    // Transition detection using ECR (edge change ratio)
#pragma omp parallel for
    for(int i=1; i<_nfrm_given; i++)
    {
      double rho_out, rho_in;
      rho_out = 1.0 - min(1.0,sum(v_edge[i-1].mul(v_edge_dl[i]))[0]/max(1e-6,sum(v_edge[i-1])[0]));
      rho_in  = 1.0 - min(1.0,sum(v_edge_dl[i-1].mul(v_edge[i]))[0]/max(1e-6,sum(v_edge[i-1])[0]));
      
      v_ecr[i] = max(rho_out,rho_in); // edge change ratio
      _X_ecr.at<double>(i) = v_ecr[i];
    }
  }
  
  // CUT detection
  hecate::sort( v_diff, v_srt_val, v_srt_idx );
  for( int i=0; i<nfrm_nperc; i++ )
    if( v_srt_val[_nfrm_given-i-1] >= thrsh_diff )
      mark_invalid(_v_frm_valid, _v_frm_log, v_srt_idx[_nfrm_given-i-1], "[Cut]" );
  
  // TRANSITION detection (cut, fade, dissolve, wipe)
  hecate::sort( v_ecr, v_srt_val, v_srt_idx );
  for( int i=0; i<nfrm_nperc; i++ )
    if( v_srt_val[_nfrm_given-i-1] >= thrsh_ecr )
      mark_invalid(_v_frm_valid, _v_frm_log, v_srt_idx[_nfrm_given-i-1], "[ECR]" );
}



/*------------------------------------------------------------------------
 Perform change point detection either by solving group-fused LASSO of
 "The group fused Lasso for multiple change-point detection" (2011) by
 Kevin Bleakley and Jean-Philippe Vert, or by using heuristics
 -----------------------------------------------------------------------*/
void VideoParser::post_process(double min_shot_sec, bool gfl)
/*-----------------------------------------------------------------------*/
{
  hecate::Segmenter seg;
  int start_idx=-1, end_idx=-1, shotlen=-1;
  int min_shot_len = min_shot_sec * _video_fps / _step_sz;
  int max_shot_len = 3 * min_shot_len;
  double thrsh_gfl = 0.25;
  
  for( size_t i=0; i<_v_frm_valid.size(); i++ )
  {
    if( start_idx<0 && _v_frm_valid[i] ) {
      start_idx = i;
    }
    if( start_idx>=0 && (!_v_frm_valid[i] || i+1==_v_frm_valid.size()) )
    {
      end_idx = i;
      shotlen = end_idx-start_idx+1;
      if( shotlen >= max_shot_len )
      {
        int njumps = floor(shotlen/min_shot_len);
        vector<int> jump;
        
        // Solve group-fused LASSO
        if( gfl ) {
          Mat Xsub( shotlen, _X_feat.cols, _X_feat.type() );
          for( int r=start_idx; r<=end_idx; r++ ) {
            _X_feat.row(r).copyTo( Xsub.row(r-start_idx) );
          }
          Xsub.convertTo(Xsub,CV_64F);
          
          seg.gflseg( Xsub, jump, njumps, thrsh_gfl );
        }
        // Use heuristics
        else {
          vector<double> v_diff;
          for(int i=start_idx; i<=end_idx; i++) {
            v_diff.push_back( _X_diff.at<double>(i) );
          }
          sbd_heuristic( v_diff, jump, njumps, min_shot_len );
        }
        
        for(size_t k=0; k<jump.size(); k++) {
          mark_invalid(_v_frm_valid, _v_frm_log, start_idx+jump[k]-1, "[GFL]" );
          mark_invalid(_v_frm_valid, _v_frm_log, start_idx+jump[k], "[GFL]" );
        }
        
        if( _debug )
          printf("segmenter: %s (seqlen=%d (%d:%d),"
                 "nJumpsEst=%d, nJumps=%d, theta=%.2f)\n",
                 (gfl) ? "gflseg" : "heuristic",  shotlen, start_idx, end_idx,
                 njumps, (int)jump.size(), thrsh_gfl);
        
      }
      start_idx = end_idx = -1;
    }
  }
}

/*-----------------------------------------------------------------------*/
void VideoParser::sbd_heuristic(vector<double> v_diff, vector<int>& jump,
                                int njumps, int min_shot_len )
/*-----------------------------------------------------------------------*/
{
  vector<size_t> v_srt_idx;
  vector<double> v_srt_val; // contains sorted values
  hecate::sort( v_diff, v_srt_val, v_srt_idx );
  for(int i=(int)v_srt_val.size()-1; i>=0; i--) {
    bool add = true;
    if (((unsigned) v_srt_idx[i] + 1 < min_shot_len) ||
        ((unsigned) v_diff.size() - v_srt_idx[i] < min_shot_len)) {
      add = false;
    } else {
      for (size_t j = 0; j < jump.size(); j++) {
        int len = abs(jump[j] - (int) v_srt_idx[i]) + 1;
        if (len < min_shot_len) {
          add = false;
          break;
        }
      }
    }
    if( add ) {
      jump.push_back( (int)v_srt_idx[i] );
    }
    if( (int)jump.size() == njumps ) {
      break;
    }
  }
};

/*-----------------------------------------------------------------------*/
void VideoParser::extract_histo_features(int pyr_level, bool omit_filtered,
                                         int nbin_color, int nbin_edge_ori,
                                         int nbin_edge_mag)
/*-----------------------------------------------------------------------*/
{
  int npatches = 0;
  for(int l=0; l<pyr_level; l++)
    npatches += pow(4,l);
  
  int nbin_edge = nbin_edge_ori + nbin_edge_mag;
  Mat X_color_hist = Mat( npatches*3*nbin_color, _nfrm_given, CV_32F, Scalar(0,0,0)[0] );
  Mat X_edge_hist  = Mat( npatches*nbin_edge, _nfrm_given, CV_32F, Scalar(0,0,0)[0] );
  
#pragma omp parallel for
  for(int i=0; i<_nfrm_given; i++)
  {
    if( omit_filtered && !_v_frm_valid[i] ) continue;
    
    Mat color_hist;
    hecate::calc_pyr_color_hist( _v_frm_rgb[i], color_hist, nbin_color, pyr_level );
    color_hist.copyTo( X_color_hist.col(i) );
    
    Mat edge_hist;
    hecate::calc_pyr_edge_hist( _v_frm_gray[i], edge_hist, nbin_edge_ori, nbin_edge_mag, pyr_level );
    edge_hist.copyTo( X_edge_hist.col(i) );
    
  }
  
  // Transpose X_gray/edge_hist, X_hist = horzcat( X_color_hist, X_edge_hist )
  X_color_hist = X_color_hist.t();
  X_edge_hist = X_edge_hist.t();
  hconcat( X_color_hist, X_edge_hist, _X_feat );
}


/*-----------------------------------------------------------------------*/
void VideoParser::filter_redundant_and_obtain_subshots()
/*-----------------------------------------------------------------------*/
{
  if( _v_shot_ranges.empty() )
    update_shot_ranges();
  
  // Generate data matrix for kmeans, consider only valid frames
  int nfrm_valid = get_nfrm_valid();
  if( nfrm_valid==0 ) {
    return;
  }

  Mat km_data( nfrm_valid, _X_feat.cols, _X_feat.type() );
  vector<int> v_idxmap( nfrm_valid, 0 );
  
  int row=0;
  for(int i=0; i<_nfrm_given; i++)
  {
    if( _v_frm_valid[i] ) {
      _X_feat.row(i).copyTo(km_data.row(row));
      v_idxmap[row] = i;
      row++;
    }
  }
  
  //
  // Perform k-means
  int ncluster = min(nfrm_valid/2, (int)_v_shot_ranges.size());
  Mat km_lbl; // integer row vector; stores cluster IDs for every sample.
  Mat km_ctr; // One row per each cluster center.
  hecate::perform_kmeans( km_data, km_lbl, km_ctr, ncluster );
  
  //
  // convert km_lbl to v_frm_clusterid
  vector<int> v_frm_clusterid(_nfrm_given,-1);
  for(int i=0; i<km_lbl.rows; i++)
    v_frm_clusterid[ v_idxmap[i] ] = km_lbl.at<int>(i);
  
  //
  // Pick the most "still" frame from every sub-shot within each shot
  for(size_t shotid=0; shotid<_v_shot_ranges.size(); shotid++)
  {
    int sb0 = _v_shot_ranges[shotid].start;
    int sb1 = _v_shot_ranges[shotid].end;
    
    // Identify sub-shots (per kmeans result)
    int ssb0=-1, ssb1=-1, lbl=-1;
    for( int j=sb0; j<=sb1; j++ )
    {
      if( _v_frm_valid[j] ) {
        if( ssb0<0 ) { // enter a new sub-shot area
          ssb0 = j;
          lbl = v_frm_clusterid[j];
        }
        ssb1 = j;
      }
      if( ssb0>=0 && (v_frm_clusterid[j]!=lbl || j==sb1) )  // exit the current sub-shot area
      {
        int diff_min_idx=-1;
        double diff_min_val = numeric_limits<double>::max();
        for( int k=ssb0; k<=ssb1; k++ )
        {
          double diff_k = _X_diff.at<double>(k);
          if( diff_k < diff_min_val )
          {
            diff_min_idx = k;
            diff_min_val = diff_k;
          }
        }
        
        // Store subshot with keyframe index
        hecate::Range r(ssb0, ssb1);
        r.v_idx.push_back( diff_min_idx );
        _v_shot_ranges[shotid].v_idx.push_back( diff_min_idx );
        _v_shot_ranges[shotid].v_range.push_back( r );
        
        // Filter out redundant frames
        for( int k=ssb0; k<=ssb1; k++ )
          if( k!=diff_min_idx )
            mark_invalid(_v_frm_valid, _v_frm_log, k, "[Redundant]");
        
        // reset sub-shot area
        ssb0 = ssb1 = lbl = -1;
      }
    }
    
    // reset shot area
    sb0 = sb1 = -1;
  }
}


/*-----------------------------------------------------------------------*/
void VideoParser::update_shot_ranges( int min_shot_len )
/*-----------------------------------------------------------------------*/
{
  _v_shot_ranges.clear();
  
  int sb0=0, sb1=-1;
  for( int i=0; i<_nfrm_given; i++ )
  {
    if( _v_frm_valid[i] ) {
      // enter a new shot area
      if( sb0<0 ) sb0 = i;
      sb1 = i;
    }
    
    // exit the current shot area
    if( sb0>=0 && sb1>=0 && (!_v_frm_valid[i] || i+1==_nfrm_given) )
    {
      hecate::ShotRange r( sb0, sb1 );
      if( r.length()>min_shot_len ) {
        _v_shot_ranges.push_back( r );
      }
      else {
        for(int j=sb0; j<=sb1; j++ )
          mark_invalid( _v_frm_valid, _v_frm_log, j, "[Short]" );
      }
      sb0 = sb1 = -1;
    }
  }
}


/*-----------------------------------------------------------------------*/
int VideoParser::get_nfrm_valid()
/*-----------------------------------------------------------------------*/
{
  return (int) accumulate( _v_frm_valid.begin(), _v_frm_valid.end(), 0 );
}


/*-----------------------------------------------------------------------*/
void VideoParser::mark_invalid( vector<bool>& vec, int idx, int wnd_sz )
/*-----------------------------------------------------------------------*/
{
  int vec_len = (int)vec.size();
  for(int i=max(0,idx-wnd_sz); i<=min(vec_len-1,idx+wnd_sz); i++) {
    vec[i] = false;
  }
}

/*-----------------------------------------------------------------------*/
void VideoParser::mark_invalid( vector<bool>& vec, vector<string>& vec2,
                               int idx, const string msg, int wnd_sz )
/*-----------------------------------------------------------------------*/
{
  int vec_len = (int)vec.size();
  for(int i=max(0,idx-wnd_sz); i<=min(vec_len-1,idx+wnd_sz); i++) {
    vec[i] = false;
    vec2[i] = msg;
  }
}



/*-----------------------------------------------------------------------*/
void VideoParser::play_video_filtered( const string& in_video,
                                      int step_sz, int max_frm_len )
/*-----------------------------------------------------------------------*/
{
  printf("\nDebug mode: Displaying shot segmentation results...\n");
  
  // Debug visualization
  const char* WND = "DEBUG";
  namedWindow( WND ,1 );
  
  Mat frm;
  double debug_rsz_ratio = (double)max_frm_len/_video_width;
  
  VideoCapture vr( in_video );
  vr >> frm;
  resize( frm, frm, Size(), debug_rsz_ratio, debug_rsz_ratio, CV_INTER_LINEAR );
  vr.set( CV_CAP_PROP_POS_FRAMES, 0 );
  
  Size sz = frm.size();
  Mat frm_lr( sz.height, 2*sz.width, CV_8UC3 );
  Mat frm_l(frm_lr, Rect(0,0,sz.width,sz.height));
  Mat frm_r(frm_lr, Rect(sz.width,0,sz.width,sz.height));
  frm_lr.setTo(Scalar(0));
  
  for( int i=0; i<_nfrm_given; i++)
  {
    for( int j=0; j<step_sz; j++ ) {
      vr >> frm;
      if( frm.empty() ) break;
    }
    if( frm.empty() ) break;
    resize( frm, frm, Size(), debug_rsz_ratio, debug_rsz_ratio, CV_INTER_LINEAR );
    
    std::stringstream s;
    s << _v_frm_log[i];
    putText(frm, s.str(), Point2f(5,30), FONT_HERSHEY_PLAIN, 1.3, Scalar(255,0,255,255), 2);
    
    if( _v_frm_log[i].length()<2 ) {
      frm.copyTo( frm_l );
    }
    else {
      frm.copyTo( frm_r );
    }
    
    imshow( WND, frm_lr );
    if( waitKey(_video_fps)>=0 ) break;
  }
  vr.release();
  destroyWindow( WND );
}
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/src/tools/hecate.cpp">
/*
 * HECATE Yahoo Video Processing Library - Binary
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#include "hecate/hecate.hpp"

using namespace std;
using namespace cv;

int main( int argc, char** argv )
{
  hecate_copyright();
  if( argc<3 )
    hecate_usage();
  
  // Read input params
  hecate_params opt;
  hecate_parse_params( argc, argv, opt );
  
  // Run VIDSUM
  vector<int> v_thumb_idx;
  vector<hecate::Range> v_gif_range;
  vector<hecate::Range> v_mov_range;
  run_hecate( opt, v_thumb_idx, v_gif_range, v_mov_range );
  
  // Print debugging info
  if( opt.debug ) {
    if( opt.jpg ) {
      printf("hecate: thumbnail indices: [ ");
      for(size_t i=0; i<v_thumb_idx.size(); i++)
        printf("%d ", v_thumb_idx[i]);
      printf("]\n");
    }
    if( opt.gif ) {
      printf("hecate: gif shot ranges:\n");
      for(int i=0; i<v_gif_range.size(); i++)
        v_gif_range[i].print();
    }
    if( opt.mov ) {
      printf("hecate: mov shot ranges:\n");
      for(int i=0; i<v_mov_range.size(); i++)
        v_mov_range[i].print();
    }
  }
  
  // Produce results
  if( opt.jpg ) {
    generate_thumbnails( opt, v_thumb_idx );
  }
  
  if( opt.gif ) {
    bool mov = opt.mov;
    opt.mov = false;
    generate_highlight_clips( opt, v_gif_range );
    opt.mov = mov;
  }
  
  if( opt.mov ) {
    bool gif = opt.gif;
    opt.gif = false;
    generate_highlight_clips( opt, v_mov_range );
    opt.gif = gif;
  }
}
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/LICENSE">
Apache License
Version 2.0, January 2004

http://www.apache.org/licenses/

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.
"License" shall mean the terms and conditions for use, reproduction, and distribution as defined by 
Sections 1 through 9 of this document.

"Licensor" shall mean the copyright owner or entity authorized by the copyright owner that is granting 
the License.

"Legal Entity" shall mean the union of the acting entity and all other entities that control, are 
controlled by, or are under common control with that entity. For the purposes of this definition, 
"control" means (i) the power, direct or indirect, to cause the direction or management of such entity, 
whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding 
shares, or (iii) beneficial ownership of such entity.

"You" (or "Your") shall mean an individual or Legal Entity exercising permissions granted by this License.

"Source" form shall mean the preferred form for making modifications, including but not limited to software 
source code, documentation source, and configuration files.

"Object" form shall mean any form resulting from mechanical transformation or translation of a Source form, 
including but not limited to compiled object code, generated documentation, and conversions to other media types.

"Work" shall mean the work of authorship, whether in Source or Object form, made available under the License, 
as indicated by a copyright notice that is included in or attached to the work (an example is provided in 
the Appendix below).

"Derivative Works" shall mean any work, whether in Source or Object form, that is based on (or derived from) 
the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, 
as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not 
include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work 
and Derivative Works thereof.

"Contribution" shall mean any work of authorship, including the original version of the Work and any 
modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to 
Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to 
submit on behalf of the copyright owner. For the purposes of this definition, "submitted" means any form of 
electronic, verbal, or written communication sent to the Licensor or its representatives, including but not 
limited to communication on electronic mailing lists, source code control systems, and issue tracking systems 
that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but 
excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner 
as "Not a Contribution."

"Contributor" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been 
received by Licensor and subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby 
grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license 
to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute 
the Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby 
grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated 
in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer 
the Work, where such license applies only to those patent claims licensable by such Contributor that are 
necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work 
to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including 
a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the 
Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under 
this License for that Work shall terminate as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any 
medium, with or without modifications, and in Source or Object form, provided that You meet the following 
conditions:

You must give any other recipients of the Work or Derivative Works a copy of this License; and
You must cause any modified files to carry prominent notices stating that You changed the files; and
You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, 
trademark, and attribution notices from the Source form of the Work, excluding those notices that do not 
pertain to any part of the Derivative Works; and
If the Work includes a "NOTICE" text file as part of its distribution, then any Derivative Works that You 
distribute must include a readable copy of the attribution notices contained within such NOTICE file, 
excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the 
following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source 
form or documentation, if provided along with the Derivative Works; or, within a display generated by the 
Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file 
are for informational purposes only and do not modify the License. You may add Your own attribution notices 
within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, 
provided that such additional attribution notices cannot be construed as modifying the License. 

You may add Your own copyright statement to Your modifications and may provide additional or different 
license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such 
Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise 
complies with the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally 
submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this 
License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall 
supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding 
such Contributions.

6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or 
product names of the Licensor, except as required for reasonable and customary use in describing the origin 
of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the 
Work (and each Contributor provides its Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS 
OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, 
NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for 
determining the appropriateness of using or redistributing the Work and assume any risks associated with Your 
exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), 
contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) 
or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, 
special, incidental, or consequential damages of any character arising as a result of this License or out 
of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work 
stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such 
Contributor has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, 
You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other 
liability obligations and/or rights consistent with this License. However, in accepting such obligations, 
You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, 
and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred 
by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional 
liability.

END OF TERMS AND CONDITIONS
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/Makefile">
PROJECT := hecate

CONFIG_FILE := Makefile.config

# Explicitly check for the config file, otherwise make -k will proceed anyway.
ifeq ($(wildcard $(CONFIG_FILE)),)
	$(error $(CONFIG_FILE) not found. See $(CONFIG_FILE).example.)
endif
include $(CONFIG_FILE)

BUILD_DIR_LINK := $(BUILD_DIR)
ifeq ($(RELEASE_BUILD_DIR),)
	RELEASE_BUILD_DIR := .$(BUILD_DIR)_release
endif
ifeq ($(DEBUG_BUILD_DIR),)
	DEBUG_BUILD_DIR := .$(BUILD_DIR)_debug
endif

DEBUG ?= 0
ifeq ($(DEBUG), 1)
	BUILD_DIR := $(DEBUG_BUILD_DIR)
	OTHER_BUILD_DIR := $(RELEASE_BUILD_DIR)
else
	BUILD_DIR := $(RELEASE_BUILD_DIR)
	OTHER_BUILD_DIR := $(DEBUG_BUILD_DIR)
endif

# All of the directories containing code.
SRC_DIRS := $(shell find * -type d -exec bash -c "find {} -maxdepth 1 \
	\( -name '*.cpp' \) | grep -q ." \; -print)

# The target shared library name
LIB_BUILD_DIR := $(BUILD_DIR)/lib
STATIC_NAME := $(LIB_BUILD_DIR)/lib$(PROJECT).a
DYNAMIC_NAME := $(LIB_BUILD_DIR)/lib$(PROJECT).so

##############################
# Get all source files
##############################
# CXX_SRCS are the source files
ifeq ($(BUILD_TEXT), 1)
  CXX_SRCS := $(shell find src/$(PROJECT) -name "*.cpp")
else
  CXX_SRCS := $(filter-out src/$(PROJECT)/text.cpp, $(shell find src/$(PROJECT) -name "*.cpp"))
endif

# TOOL_SRCS are the source files for the tool binaries
ifeq ($(BUILD_TEXT), 1)
  TOOL_SRCS := $(shell find src/tools -name "*.cpp")
else
  TOOL_SRCS := $(filter-out src/tools/aesthetic_feature_extractor.cpp, $(shell find src/tools -name "*.cpp"))
endif

# BUILD_INCLUDE_DIR contains any generated header files we want to include.
BUILD_INCLUDE_DIR := $(BUILD_DIR)/src


##############################
# Derive generated files
##############################
# The generated files for protocol buffers
# The objects corresponding to the source files
# These objects will be linked into the final shared library, so we
# exclude the tool and test objects.
CXX_OBJS := $(addprefix $(BUILD_DIR)/, ${CXX_SRCS:.cpp=.o})
OBJS := $(CXX_OBJS)

# tool objects
TOOL_OBJS := $(addprefix $(BUILD_DIR)/, ${TOOL_SRCS:.cpp=.o})
TOOL_BUILD_DIR := $(BUILD_DIR)/tools

# Output files for automatic dependency generation
DEPS := ${CXX_OBJS:.o=.d}

# tool bins
TOOL_BINS := ${TOOL_OBJS:.o=}


##############################
# Derive compiler warning dump locations
##############################
WARNS_EXT := warnings.txt
CXX_WARNS := $(addprefix $(BUILD_DIR)/, ${CXX_SRCS:.cpp=.o.$(WARNS_EXT)})
TOOL_WARNS := $(addprefix $(BUILD_DIR)/, ${TOOL_SRCS:.cpp=.o.$(WARNS_EXT)})
ALL_CXX_WARNS := $(CXX_WARNS) $(TOOL_WARNS)
ALL_WARNS := $(ALL_CXX_WARNS)
NONEMPTY_WARN_REPORT := $(BUILD_DIR)/$(WARNS_EXT)


##############################
# Derive include and lib directories
##############################
INCLUDE_DIRS += $(BUILD_INCLUDE_DIR) ./include

LIBRARIES += opencv_core opencv_highgui opencv_imgproc
ifeq ($(OPENCV_VERSION), 3)
	LIBRARIES += opencv_imgcodecs opencv_videoio
endif

WARNINGS := -Wall -Wno-sign-compare


##############################
# Set build directories
##############################

DISTRIBUTE_DIR ?= distribute
DISTRIBUTE_SUBDIRS := $(DISTRIBUTE_DIR)/bin $(DISTRIBUTE_DIR)/lib
DIST_ALIASES := dist
ifneq ($(strip $(DISTRIBUTE_DIR)),distribute)
		DIST_ALIASES += distribute
endif

ALL_BUILD_DIRS := $(sort $(BUILD_DIR) $(addprefix $(BUILD_DIR)/, \
$(SRC_DIRS)) $(LIB_BUILD_DIR) $(DISTRIBUTE_SUBDIRS))


##############################
# Configure build
##############################

# Determine platform
UNAME := $(shell uname -s)
ifeq ($(UNAME), Linux)
	LINUX := 1
else ifeq ($(UNAME), Darwin)
	OSX := 1
endif

# Linux
ifeq ($(LINUX), 1)
	CXX ?= /usr/bin/g++
	GCCVERSION := $(shell $(CXX) -dumpversion | cut -f1,2 -d.)
	# older versions of gcc are too dumb to build boost with -Wuninitalized
	ifeq ($(shell echo | awk '{exit $(GCCVERSION) < 4.6;}'), 1)
		WARNINGS += -Wno-uninitialized
	endif
	# We will explicitly add stdc++ to the link target.
	LIBRARIES += stdc++
	COMMON_FLAGS += -fopenmp
endif

# OS X:
# clang++ instead of g++
ifeq ($(OSX), 1)
	CXX := /usr/bin/clang++
	# we need to explicitly ask for the rpath to be obeyed
	DYNAMIC_FLAGS := -install_name @rpath/lib$(PROJECT).so
	ORIGIN := @loader_path
else
	ORIGIN := \$$ORIGIN
endif

# Custom compiler
ifdef CUSTOM_CXX
	CXX := $(CUSTOM_CXX)
endif

# Debugging
ifeq ($(DEBUG), 1)
	COMMON_FLAGS += -std=c++0x -DDEBUG -g -O0
else
	COMMON_FLAGS += -std=c++0x -DNDEBUG -O2
endif

LIBRARY_DIRS += $(LIB_BUILD_DIR)

# Automatic dependency generation
CXXFLAGS += -MMD -MP

# Complete build flags.
COMMON_FLAGS += $(foreach includedir,$(INCLUDE_DIRS),-I$(includedir))
CXXFLAGS += -pthread -fPIC $(COMMON_FLAGS) $(WARNINGS)
LINKFLAGS += -pthread -fPIC $(COMMON_FLAGS) $(WARNINGS)

LDFLAGS += $(foreach librarydir,$(LIBRARY_DIRS),-L$(librarydir)) $(PKG_CONFIG) \
		$(foreach library,$(LIBRARIES),-l$(library))


##############################
# Define build targets
##############################
.PHONY: all lib tools clean $(DIST_ALIASES)

all: lib tools

lib: $(STATIC_NAME) $(DYNAMIC_NAME)

tools: $(TOOL_BINS)

$(ALL_WARNS): %.o.$(WARNS_EXT) : %.o

$(BUILD_DIR_LINK): $(BUILD_DIR)/.linked

# Create a target ".linked" in this BUILD_DIR to tell Make that the "build" link
# is currently correct, then delete the one in the OTHER_BUILD_DIR in case it
# exists and $(DEBUG) is toggled later.
$(BUILD_DIR)/.linked:
	@ mkdir -p $(BUILD_DIR)
	@ $(RM) $(OTHER_BUILD_DIR)/.linked
	@ $(RM) -r $(BUILD_DIR_LINK)
	@ ln -s $(BUILD_DIR) $(BUILD_DIR_LINK)
	@ touch $@

$(ALL_BUILD_DIRS): | $(BUILD_DIR_LINK)
	@ mkdir -p $@

$(DYNAMIC_NAME): $(OBJS) | $(LIB_BUILD_DIR)
	@ echo LD -o $@
	$(Q)$(CXX) -shared -o $@ $(OBJS) $(LINKFLAGS) $(LDFLAGS) $(DYNAMIC_FLAGS)

$(STATIC_NAME): $(OBJS) | $(LIB_BUILD_DIR)
	@ echo AR -o $@
	$(Q)ar rcs $@ $(OBJS)

$(BUILD_DIR)/%.o: %.cpp | $(ALL_BUILD_DIRS)
	@ echo CXX $<
	$(Q)$(CXX) $< $(CXXFLAGS) -c -o $@ 2> $@.$(WARNS_EXT) \
		|| (cat $@.$(WARNS_EXT); exit 1)
	@ cat $@.$(WARNS_EXT)

# Target for extension-less tool binaries
$(TOOL_BUILD_DIR)/%: $(TOOL_BUILD_DIR)/% | $(TOOL_BUILD_DIR)
	@ $(RM) $@
	@ ln -s $(abspath $<) $@

$(TOOL_BINS): % : %.o | $(DYNAMIC_NAME)
	@ echo CXX/LD -o $@
	$(Q)$(CXX) $< -o $@ $(LINKFLAGS) $(LDFLAGS) -l$(PROJECT)\
		-Wl,-rpath,$(ORIGIN)/../lib

clean:
	@- $(RM) -rf $(ALL_BUILD_DIRS)
	@- $(RM) -rf $(OTHER_BUILD_DIR)
	@- $(RM) -rf $(BUILD_DIR_LINK)
	@- $(RM) -rf $(DISTRIBUTE_DIR)

$(DIST_ALIASES): $(DISTRIBUTE_DIR)

$(DISTRIBUTE_DIR): all | $(DISTRIBUTE_SUBDIRS)
	# add include
	cp -r include $(DISTRIBUTE_DIR)/
	# add tool binaries
	cp $(TOOL_BINS) $(DISTRIBUTE_DIR)/bin
	# add libraries
	cp $(STATIC_NAME) $(DISTRIBUTE_DIR)/lib
	install -m 644 $(DYNAMIC_NAME) $(DISTRIBUTE_DIR)/lib

-include $(DEPS)
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/Makefile.config">
# Directories containing ffmpeg and opencv
INCLUDE_DIRS := /usr/local/include
LIBRARY_DIRS := /usr/local/lib

# Comment if you're using OpenCV 2.4
OPENCV_VERSION := 3

BUILD_DIR := build
DISTRIBUTE_DIR := distribute

# Uncomment for debugging.
# DEBUG := 1

# enable pretty build (comment to see full commands)
Q ?= @
</file>

<file path=".build_release/temp/hecate-master (1)/hecate-master/README.md">
# HECATE
Hecate [hek-uh-tee] is a video processing library that auto-magically generates thumbnails, animated GIFs, and video summaries from videos. This library is developed and maintained by Yahoo Research, New York.

The source code is Copyright 2016 Yahoo Inc. and is licensed under the terms of the Apache 2.0 License. See the [LICENSE](https://github.com/yahoo/hecate/blob/master/LICENSE) in the project root file for terms.

The technology behind this library is based on our research work. If you find this library useful in your work, we ask you to cite our research paper:
```
"To Click or Not To Click: Automatic Selection of Beautiful Thumbnails from Videos."
Yale Song, Miriam Redi, Jordi Vallmitjana, Alejandro Jaimes, 
Proceedings of the 25th ACM International on Conference on Information and Knowledge Management, CIKM 2016
```

## Installation
Hecate has one dependency: [OpenCV library](https://github.com/opencv/opencv) with an [FFMPEG](https://github.com/FFmpeg/FFmpeg) support. You will need to install the library properly before trying out Hecate!

Once you install the dependenct library correctly, follow the instruction below:
```
$ git clone https://github.com/yahoo/hecate.git
$ cd hecate
$ vim Makefile.config
 - Set INCLUDE_DIRS and LIBRARY_DIRS to where your 
   opencv library is installed. Usually under /usr/local.
 - If your OpenCV version is 2.4.x, comment out the line 
   OPENCV_VERSION := 3
 - Save and exit
$ make all
$ make distribute
```

Once you've successfully compiled hecate, it will generate a binary executable under `distribute/bin/`. Run the following command to check if everything works properly:
```
$ ./distribute/bin/hecate

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 HECATE Copyright 2016 Yahoo Inc.
   Licensed under the terms of the Apache 2.0 License.
   Developed by : Yale Song (yalesong@yahoo-inc.com)
   Built on  : 11:46:03 Aug 11 2016
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
USAGE: hecate -i infile [options]

  -i  --in_video      (string)    Input video file
  -o  --out_dir       (string)    Output directory (./output)
  -s  --step          (int)       Frame subsampling step size (1)
  -n  --njpg          (int)       Number of thumbnails to be generated (5)
  -q  --ngif          (int)       Number of GIFs to be generated (5)
  -r  --lmov          (int)       Length of video summary to be generated (in seconds) (15)
  -u  --jpg_width_px  (int)       Pixel width of thumbnail images (360)
  -v  --gif_width_px  (int)       Pixel width of animated GIFs (360)
  -w  --mov_width_px  (int)       Pixel width of summary video (360)
  --generate_jpg                  Generate thumbnail images
  --generate_gif                  Generate animated GIFs
  --generate_mov                  Generate a summary video
  --generate_gifsum               Generate animated GIFs summary
  --generate_gifall               Generate all possible animated GIFs
  --print_shot_info               Print shot boundary detection results
  --print_keyfrm_info             Print keyframe indices
```

Congratulations! You have successfully installed hecate!


## Get started
In order to get started, we will need a video file to play with. In this example, we will use the video ["The Spirit of '43" by Walt Disney](https://archive.org/details/TheSpiritOf43_56) from [The Internet Archive](https://archive.org). 

Let's download the video and save it as `examples/video.mp4`:
```
$ wget https://archive.org/download/TheSpiritOf43_56/The_Spirit_of__43_512kb.mp4 \
  --output-document examples/video.mp4 --no-check-certificate
```

Hecate provides three main functionalities through a binary executable `hecate`: Thumbnail extraction, GIF generation, and video summarization. There are various other functionalities the library provides, such as shot boundary detection and keyframe extraction. 

We will explain each case below.

### Shot boundary detection and keyframe extraction
Shot boundary detection and keyframe extraction are often the first steps towards various video processing methods. With Hecate, obtaining shot and keyframe information is easier than ever! Simply run the following command to get the result:
```
$ ./distribute/bin/hecate -i examples/video.mp4 --print_shot_info  --print_keyfrm_info
```

Below is the results we obtained on our dev machine (OS X 10.10 with OpenCV v3.1):
```
shots: [0:81],[84:93],[96:102],[108:270],[272:418],...,[9966:10131],[10135:10164]
keyframes: [52,85,98,128,165,208,242,259,265,273,...,10127,10141]
```
The units are frame indices (zero-based). You will notice that shot ranges are non-continuous; there are "gaps" between shots, e.g., two frames are missing between the first two shots [0:81] and [84:93]. This is normal and intentional: Hecate discards low-quality frames that aren't ideal in producing nicely looking thumbnails, animated GIFs, and video summaries. We refer to our CIKM 2016 paper for the rational behind our reason to invalidate low-quality frames.

### Thumbnail generation
Hecate uses computer vision to determine frames that are most "suitable" as video thumbnails. By suitable, we mean a frame that is the most relevant to the video content and that is the most beautiful in terms of computational aesthetics; technical details are explained in our CIKM 2016 paper.

You can generate thumbnail images using Hecate. Run the following command to generate one thumbnail image from the video.
```
$ ./distribute/bin/hecate -i examples/video.mp4 --generate_jpg --njpg 1
```
You will see the generated thumbnail image under the output directory (set as `output` by default; you can change this using the option `--out_dir YOUR_DIRECTORY`). On our dev machine we get this thumbnail image:

![alt text](https://github.com/yahoo/hecate/blob/master/examples/video_00.jpg "Hecate Thumbnail Image")

In the above example, we generated only one thumbnail image. Are you not satisfied with the thumbnail image? Hecate can generate any number of thunbmail images! Let's generate five thumbnail images.
```
$ ./distribute/bin/hecate -i examples/video.mp4 --generate_jpg --njpg 3
```

The output files are named `<video_filename>_<rank>.jpg`. The files are ranked by their quality (rank 0 means it's the best one).

### Animated GIF generation
Do you want to create animated GIFs from a video without the hassle of using manual tools? Hecate can automatically create them for you! Run the following command to create one animated GIF from the video.
```
$ ./distribute/bin/hecate -i examples/video.mp4 --generate_gif --ngif 1
```
On our dev machine, we get this animated GIF:

![alt text](https://github.com/yahoo/hecate/blob/master/examples/video_00.gif "Hecate Animated GIF")

You can, of course, create more than just one GIF by setting the paramter `--ngif N` with an appropriate number N. When there are multiple GIFs, you can also generate a "summary GIF" by concatenating them, using this command:
```
$ ./distribute/bin/hecate -i examples/video.mp4 --generate_gif --ngif 3 --generate_gifsum
```

If you'd rather want to obtain all available GIFs from the video, use the following command: 
```
$ ./distribute/bin/hecate -i examples/video.mp4 --generate_gifall
```

### Video summary generation
Last but not least, Hecate can summarize a video! Run the following command to create a video summary of length 15 seconds.
```
$ ./distribute/bin/hecate -i examples/video.mp4 --generate_mov --lmov 15
```
We included the video summary generated on our dev machine here: 
[https://github.com/yahoo/hecate/blob/master/examples/video_sum.mp4](https://github.com/yahoo/hecate/blob/master/examples/video_sum.mp4)


## Developer

Yale Song: [github](https://github.com/yalesong), [website](http://people.csail.mit.edu/yalesong)
</file>

<file path=".build_release/temp/ffmpeg_helper.hpp">
/*
 * Various helper functions using ffmpeg
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */


#ifndef HECATE_FFMPEG_HPP
#define HECATE_FFMPEG_HPP

#include <stdio.h>
#include <string.h>

#include <iostream>
#include <fstream>
#include <string>
#include <vector>

#include "hecate/file_helper.hpp"

#define BUF_S 256
#define BUF_M 512
#define BUF_L 1024

using namespace std;

namespace hecate {
  const string _ffmpeg = hecate::which("ffmpeg");
  const string _ffmarg = "-loglevel quiet -y";
  const int _lfade = 8; // fade-in/out duration (unit: frame)
  
  // Crop video segment & resize
  static inline void ffmpeg_video_crop(string in_file,
                                       string out_file,
                                       string start_time,
                                       string duration,
                                       int out_width_px)
  {
    in_file = escape_space(in_file);
    
    char filter[BUF_S];
    sprintf( filter, "'scale=%d:trunc(ow/a/2)*2'", out_width_px);
    
    char cmd[BUF_L];
    sprintf( cmd, "%s -ss %s -t %s -i %s -strict -2 -vf %s %s %s",
            _ffmpeg.c_str(), start_time.c_str(), duration.c_str(),
            in_file.c_str(), filter, out_file.c_str(), _ffmarg.c_str());
    
    system( cmd );
  };
  
  static inline void ffmpeg_video_concat(string in_filelist,
                                         string out_file)
  {
    char cmd[BUF_L];
    sprintf( cmd, "%s -f concat -i %s -c copy %s %s",
            _ffmpeg.c_str(), in_filelist.c_str(), out_file.c_str(),
            _ffmarg.c_str() );
    system( cmd );
  };
  
  // Audio fade in/out
  static inline void ffmpeg_audio_fade(string in_file,
                                       string out_file,
                                       double video_duration_sec,
                                       double video_fps)
  {
    in_file = escape_space(in_file);
    
    const double afade_sec = (double)2*_lfade/video_fps;
    const double afade_msec = (int)10000*(afade_sec-floor(afade_sec));
    
    double afos  = video_duration_sec - afade_sec; // audio fade-out start
    int afos_ss  = (int) afos; // NOTE: we don't compute modulo this time
    int afos_mss = (int) 10000*(afos - floor(afos));
    
    char filter[BUF_S];
    sprintf( filter, "'afade=t=in:ss=0:d=0.%04d,"
                      "afade=t=out:st=%d.%04d:d=0.%04d'",
            (int)afade_msec, afos_ss, afos_mss, (int)afade_msec);

    char cmd[BUF_L];
    sprintf( cmd, "%s -i %s -af %s %s %s", _ffmpeg.c_str(),
            in_file.c_str(), filter, out_file.c_str(), _ffmarg.c_str() );
    system( cmd );

  };
  
  // Video fade in/out
  static inline void ffmpeg_video_fade(string in_file,
                                       string out_file,
                                       int video_duration,
                                       bool out_only=false)
  {
    in_file = escape_space(in_file);
    
    char filter[BUF_S];
    if( out_only ) {
      sprintf( filter, "'fade=out:%d:%d'",
              video_duration-_lfade, _lfade);
    }
    else {
      sprintf( filter, "'fade=in:0:%d,fade=out:%d:%d'",
              _lfade, video_duration-_lfade, _lfade);
    }
    
    char cmd[BUF_L];
    sprintf( cmd, "%s -i %s -vf %s %s %s", _ffmpeg.c_str(),
            in_file.c_str(), filter, out_file.c_str(), _ffmarg.c_str());
    system( cmd );
  };
  
  
  // Based on http://blog.pkh.me/p/21-high-quality-gif-with-ffmpeg.html
  static inline void ffmpeg_video2gif(string in_file,
                                      string out_file,
                                      string start_time,
                                      string duration,
                                      int out_fps,
                                      int out_width_px)
  {
    in_file = escape_space(in_file);
    
    string out_dir = hecate::get_dir( std::string(out_file) );
    
    char filter[BUF_S];
    sprintf( filter, "fps=%d,scale=%d:-1:flags=lanczos", out_fps, out_width_px );
    
    char palette[BUF_M];
    sprintf( palette, "%s/palatte.png", out_dir.c_str() );
    
    char time_setup[BUF_S] = "";
    if( !start_time.empty() && !duration.empty() ) {
      sprintf( time_setup, "-ss %s -t %s",
              start_time.c_str(), duration.c_str() );
    }

    char cmd[BUF_L];
    
    // Create a palatte
    sprintf( cmd, "%s %s -i %s -vf '%s,palettegen=stats_mode=diff' %s %s",
            _ffmpeg.c_str(), time_setup,  in_file.c_str(), filter,
            _ffmarg.c_str(), palette );
    system( cmd );
    
    // Convert segment to gif
    sprintf( cmd, "%s %s -i %s -i %s -lavfi '%s [x]; [x][1:v] paletteuse' %s %s",
            _ffmpeg.c_str(), time_setup, in_file.c_str(), palette, filter,
            _ffmarg.c_str(), out_file.c_str());
    system( cmd );
    
    // Delete palette
    sprintf( cmd, "rm %s", palette );
    system( cmd );
  };
  
  
  
}
#endif
</file>

<file path=".build_release/temp/hecate_highlight.cpp">
/*
 * HECTATE Video Processing Library - Highlight
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#include "hecate/hecate.hpp"

using namespace std;
using namespace cv;


void detect_highlight_shots( hecate_params& opt, hecate::video_metadata& meta,
                            const vector<hecate::ShotRange>& v_shot_range,
                            const Mat& X, const Mat& diff,
                            vector<hecate::Range>& v_highlight_range)
{
  if( opt.gif && opt.mov ) {
    fprintf( stderr, "Fatal Error in detect_highlight_shots():"
            "opt.gif and opt.mov cannot be true at the same time.\n" );
    exit(-1);
  }
  
  v_highlight_range.clear();

  const int minK = 5;
  const int maxK = 30;

  ////////////////////////////////////////////////////////////////////////////
  //
  // Discard shots that are too short or too static
  //
  ////////////////////////////////////////////////////////////////////////////

  int min_shot_len, max_shot_len, min_num_shot;
  if( opt.mov ) {
    double addrate_min = 0.5 * sqrt(max(0.0,(double)opt.lmov-15.0)/45.0);
    double addrate_max = sqrt(max(0.0,(double)opt.lmov-15.0)/45.0);
    min_shot_len = floor((3.0+addrate_min) * meta.fps / opt.step_sz);
    max_shot_len = round((1.0+addrate_max) * min_shot_len);
    min_num_shot = ceil( opt.lmov / 3.0 );
    if( opt.debug ) {
      printf("detect_highlight_shots(): "
             "min_shot_len=%d, max_shot_len=%d, min_num_shot=%d, "
             "addrate_min=%f, addrate_max=%f\n",
             min_shot_len, max_shot_len, min_num_shot,
             addrate_min, addrate_max);
    }
  }
  else {
    min_shot_len = floor(1.5 * meta.fps / opt.step_sz);
    max_shot_len = ceil (4.5 * meta.fps / opt.step_sz);
    min_num_shot = opt.ngif;
  }

  // Active set containing candidates for highlight shots
  vector<hecate::Range> v_candidates;
  for(size_t i=0; i<v_shot_range.size(); i++) {
    hecate::Range shot(v_shot_range[i].start, v_shot_range[i].end);
    shot.v_idx = v_shot_range[i].v_idx;
    int shot_len = shot.length();
    double avg_diff=0;
    for(int i=shot.start; i<=shot.end; i++)
      avg_diff += diff.at<double>(i);
    avg_diff/=shot.length();
    
    // Discard if too short.
    if( shot_len < min_shot_len ) {
      //printf("Discard SHORT (shot_len=%d, avg_diff=%f) ", shot_len, avg_diff); shot.print();
      continue;
    }
    
    // Discard if too static
    if( avg_diff < 0.05 ) {
      //printf("Discard STATIC (shot_len=%d, avg_diff=%f) ", shot_len, avg_diff); shot.print();
      continue;
    }
    
    // Add the shot
    v_candidates.push_back( shot );
  }

  // If there's not enough shots, merged adjacent shots and add them
  if( (int)v_candidates.size() < min_num_shot ) {
    if( opt.debug ) {
      printf("detect_highlight_shots(): "
             "Not enough candidate shots (current=%d/%d, min=%d)\n",
             (int)v_candidates.size(), (int)v_shot_range.size(), min_num_shot);
    }
    for(size_t i=0; i<v_shot_range.size(); i++) {
      // Merge shots until it's longer than min_shot_len
      size_t j=i;
      int cumlen=0;
      while( (j+1)<v_shot_range.size() ) {
        cumlen += v_shot_range[j].length();
        if( cumlen<min_shot_len ) { j++; } else { break; }
      }
      // Construct a shot
      hecate::Range shot(v_shot_range[i].start, v_shot_range[j].end);
      shot.v_idx.clear();
      for(size_t k=i; k<=j; k++)
        shot.v_idx.insert( shot.v_idx.end(),
            v_shot_range[k].v_idx.cbegin(), v_shot_range[k].v_idx.cend());

      // Check if this shot is already in v_candidates
      bool exists = false;
      for( size_t k=0; k<v_candidates.size(); k++ ) {
        if( v_candidates[k].start >= shot.start &&
           v_candidates[k].start <= shot.end ) {
          exists = true; break;
        }
      }
      if( !exists && shot.length() >= min_shot_len ) {
        v_candidates.push_back( shot );
      }
      i = j+1;
    }

    // Sort candidate shots in a chronogical order
    vector<hecate::Range> v_candidates_tmp;
    vector<int> v_shot_nsrt; // shots in non-sorted order
    for( size_t i=0; i<v_candidates.size(); i++ )
      v_shot_nsrt.push_back( v_candidates[i].start );
    // sort wrt frame index in an ascending order
    vector<size_t> v_srt_idx; // contains idx
    vector<int> v_srt_val; // contains value (start frame idx)
    hecate::sort( v_shot_nsrt, v_srt_val, v_srt_idx );
    for(size_t i=0; i<v_srt_idx.size(); i++) {
      v_candidates_tmp.push_back( v_candidates[v_srt_idx[i]] );
    }
    v_candidates = v_candidates_tmp;
  }
  
  
  // Shorten shots if too long.
  // Prefer static shot; potentially reduces jitter
  for(size_t i=0; i<v_candidates.size(); i++) {
    hecate::Range shot = v_candidates[i];
    int shot_len = shot.length();
    if( shot_len > max_shot_len ) {
      while( shot_len > max_shot_len ) {
        Scalar mu, sigma, mu2, sigma2;
        meanStdDev( diff(Rect(0,shot.start+1,1,shot.length()-1)), mu, sigma );
        meanStdDev( diff(Rect(0,shot.start,  1,shot.length()-1)), mu2, sigma2 );
        if( sigma[0] < sigma2[0] )
          shot.start++;
        else
          shot.end--;
        shot_len = shot.length();
      }
    }
    v_candidates[i] = shot;
  }
  
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Group visually simimlar shots
  //
  // Represent each shot as a piece-wise constant multi-dimensional signal
  // Then run kmeans (k=#nshots_highlight).
  //
  ////////////////////////////////////////////////////////////////////////////
  
  // Prepare data for kmeans
  // Compute piece-wise constant feature representation
  Mat km_data( (int)v_candidates.size(), X.cols, X.type() );
  for( size_t shotid=0; shotid<v_candidates.size(); shotid++ ) {
    hecate::Range s = v_candidates[shotid];
    Mat Xsub = X( Rect(0, s.start, X.cols, s.length()) );
    cv::reduce( Xsub, km_data.row(shotid), 0, CV_REDUCE_AVG );
  }
  
  // Perform k-means (repeat 5 times)
  Mat km_lbl; // integer row vector; stores cluster IDs for every sample.
  Mat km_ctr; // one row per each cluster center.
  int km_k = min(maxK, min((int)v_candidates.size(), max(minK, min_num_shot)));
  hecate::perform_kmeans( km_data, km_lbl, km_ctr, km_k, 5 );
  
  // measure cluster size
  vector<int> v_shotlen;
  for(size_t i=0; i<v_candidates.size(); i++) {
    v_shotlen.push_back( v_candidates[i].length() );
  }
  vector<int> clust_sz(km_k,0);
  
  for(int i=0; i<km_lbl.rows; i++)
    clust_sz[ km_lbl.at<uint8_t>(i) ] += v_shotlen[i];
  
  // sort wrt cluster size in an ascending order
  vector<size_t> v_srt_idx; // contains cluster id
  vector<int> v_srt_val;    // contains cluster size
  hecate::sort( clust_sz, v_srt_val, v_srt_idx );
  
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Shot evaluation
  //
  // Criteria: prefer the most dynamic shot among others within the same cluster
  //
  ////////////////////////////////////////////////////////////////////////////
  
  // Pre-compute per-shot diff score avg & stddev
  Mat shot_diff_avg(v_candidates.size(), 1, diff.type(), Scalar(0,0,0)[0]);
  Mat shot_diff_std(v_candidates.size(), 1, diff.type(), Scalar(0,0,0)[0]);
  for( size_t shotid=0; shotid<v_candidates.size(); shotid++ ) {
    Scalar mu, sigma;
    hecate::Range s = v_candidates[shotid];
    meanStdDev( diff(Rect(0,s.start,1,s.length())), mu, sigma );
    shot_diff_avg.at<double>(shotid) = (double) mu[0];
    shot_diff_std.at<double>(shotid) = (double) sigma[0];
  }

  vector<int> v_shot_len;
  vector<double> v_shot_score;
  for(size_t i=0; i<v_candidates.size(); i++) {
    v_shot_len.push_back( v_candidates[i].length() );
    v_shot_score.push_back( 0.0 );
  }

  // Start with the largest cluster
  for(int i=0; i<km_k; i++)
  {
    int k = v_srt_idx[km_k-i-1];
    hecate::Range best_range(-1,-1);
    double best_val = -numeric_limits<double>::max();
    
    // Collect IDs & scores of the shots in the k-th cluster
    vector<int> v_tmp_shotid;
    vector<double> v_tmp_score;
    for(int shotid=0; shotid<km_lbl.rows; shotid++) {
      int lbl = km_lbl.at<int>(shotid);
      if( lbl==k ) {
        double val = shot_diff_avg.at<double>(shotid);
        if( val > best_val ) {
          best_range = v_candidates[shotid];
          best_val = val;
        }
        v_tmp_shotid.push_back( shotid );
        v_tmp_score.push_back( val );
      }
    }
    
    // If GIF mode, add shots here
    if( opt.gif ) {
      if( best_range.start>=0 && best_range.length()>0 )
        v_highlight_range.push_back( best_range );
      if( (int)v_highlight_range.size() >= opt.ngif )
        break;
    }
    
    // If MOV mode, store shot scores
    if( opt.mov ) {
      // Sort wrt avg_diff score, ascending order
      vector<size_t> v_srt_idx2;
      vector<double> v_srt_val2;
      hecate::sort( v_tmp_score, v_srt_val2, v_srt_idx2 );
      
      // Record normalized scores
      for( size_t i=0; i<v_srt_idx2.size(); i++ ) {
        // if prefer dynamic, higher avg_diff gets priority
        int order = (opt.prefer_dynamic) ? v_srt_idx2.size()-1-i : i;
        v_shot_score[v_tmp_shotid[v_srt_idx2[order]]] = 100.0/(1.0+(double(i)));
      }
    }
  }
  
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Shot selection
  //
  // Criteria: prefer the most dynamic shot among others within the same cluster
  //
  ////////////////////////////////////////////////////////////////////////////
  
  // Return all available segments
  if ( opt.gif ) {
    if( opt.gifall ) {
      v_highlight_range = v_candidates;
    }
  }
  
  if( opt.mov ) {
    int budget = floor(opt.lmov * meta.fps / opt.step_sz);
    budget += (int)(0.5 * max_shot_len); // buffer
    
    // solve 0/1 knapsack
    vector<bool> sol;
    hecate::solve_01knapsack( v_shot_score, v_shot_len, budget, sol );
    
    // merge shots if only they are only half a second apart
    int merge_thrsh = ceil(0.5 * meta.fps / opt.step_sz);
    for( size_t i=0; i<sol.size(); i++ ) {
      if( sol[i] ) {
        hecate::Range r = v_candidates[i];
        if( v_highlight_range.empty() ) {
          v_highlight_range.push_back( v_candidates[i] );
        }
        else {
          int dist = r.start - v_highlight_range[v_highlight_range.size()-1].end + 1;
          if( dist < merge_thrsh )
            v_highlight_range[v_highlight_range.size()-1].end = r.end;
          else
            v_highlight_range.push_back( v_candidates[i] );
        }
      }
    }
  }

  for(size_t i=0; i<v_highlight_range.size(); i++) {
    v_highlight_range[i].start *= opt.step_sz;
    v_highlight_range[i].end *= opt.step_sz;
  }
  
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Post Processing
  //
  // Ensures summary video length is exactly the same as required
  //
  ////////////////////////////////////////////////////////////////////////////
  
  // Ensures highlight ranges sums up to exactly target length
  if( opt.mov ) {
    int target = round(opt.lmov * meta.fps);
    int curlen = 0;
    for(size_t i=0; i<v_highlight_range.size(); i++) {
      curlen += v_highlight_range[i].length();
    }
    //printf("target=%d, cur=%d\n", target, curlen);
    if( curlen!=target ) {
      // If summary is too long
      while( curlen>target ) {
        // Pick a random shot
        if (v_highlight_range.empty())
        {
          curlen--;
          continue;
        }
        
        int idx = rand() % (int) v_highlight_range.size();
        hecate::Range shot = v_highlight_range[idx];
        // Remove frame that reduces stddev of the shot by the most
        Scalar mu, sigma, mu2, sigma2;
        meanStdDev( diff(Rect(0,shot.start+1,1,shot.length()-1)), mu, sigma );
        meanStdDev( diff(Rect(0,shot.start,1,shot.length()-1)), mu2, sigma2 );
        if( sigma[0] < sigma2[0] )
          v_highlight_range[idx].start++;
        else
          v_highlight_range[idx].end--;
        curlen--;
      }
      // If video is longer than target, but summary is too short
      int shot_edge_buf = 10;
      int failed_attempt = 0;
      while( curlen<target ) {
        // Pick a random shot
        if (v_highlight_range.empty())
        {
          curlen++;
          continue;
        }
        
        int idx = rand() % (int) v_highlight_range.size();
        hecate::Range shot = v_highlight_range[idx];
        
        // Add frame that increases stddev of the shot by the least
        bool failed = false;
        if( v_highlight_range[idx].start<shot_edge_buf ) {
          if( idx+1<v_highlight_range.size() && v_highlight_range[idx+1].start >
             v_highlight_range[idx].end+1+shot_edge_buf ) {
              v_highlight_range[idx].end++;
          }
          else {
            failed = true;
          }
        }
        else if( v_highlight_range[idx].end>meta.nframes-shot_edge_buf ) {
          if( idx>0 && v_highlight_range[idx-1].end <
             v_highlight_range[idx].start-1-shot_edge_buf ) {
            v_highlight_range[idx].start--;
          }
          else {
            failed = true;
          }
        }
        else {
          Scalar mu, sigma, mu2, sigma2;
          meanStdDev( diff(Rect(0,shot.start-1,1,shot.length()+1)), mu, sigma );
          meanStdDev( diff(Rect(0,shot.start,1,shot.length()+1)), mu2, sigma2 );
          if( sigma[0] < sigma2[0] ) {
            if( v_highlight_range[idx-1].end <
               v_highlight_range[idx].start-1-shot_edge_buf ) {
              v_highlight_range[idx].start--;
            }
            else {
              failed = true;
            }
          }
          else {
            if( v_highlight_range[idx+1].start >
               v_highlight_range[idx].end+1+shot_edge_buf) {
              v_highlight_range[idx].end++;
            }
            else {
              failed = true;
            }
          }
        }
        if( !failed )
          curlen++;
        else
          failed_attempt++;
        if( failed_attempt>10*(int)v_highlight_range.size() ) {
          if( opt.debug ) {
            printf("Failed to meet the target length in video summary\n");
          }
          break;
        }
      }
    }
    //curlen = 0;
    //for(size_t i=0; i<v_highlight_range.size(); i++)
    //  curlen += v_highlight_range[i].length();
    //printf("target=%d, cur=%d\n", target, curlen);
  }
}


////////////////////////////////////////////////////////////////////////////
//
// Highlight clip generation
//
////////////////////////////////////////////////////////////////////////////

void generate_highlight_clips( hecate_params& opt, vector<hecate::Range>& v_highlight_range )
{
  if( opt.gif && opt.mov ) {
    fprintf( stderr, "Fatal Error in generate_highlight_clips():"
            "opt.gif and opt.mov cannot be true at the same time.\n" );
    exit(-1);
  }
  
  // prefix for hiddden files generated during execution
  const char *cdot = "__tmp__";
  
  string filename = hecate::get_filename( std::string(opt.in_video) );
  
  VideoCapture vr( opt.in_video );
  double fps = vr.get(CV_CAP_PROP_FPS);
  vr.release();
  
  // Sort shots in chronological order
  vector<int> v_shot_nsrt; // shots in non-sorted order
  for( size_t i=0; i<v_highlight_range.size(); i++ )
    v_shot_nsrt.push_back( v_highlight_range[i].start );
  
  // sort wrt frame index in an ascending order
  vector<size_t> v_srt_idx; // contains idx
  vector<int> v_srt_val; // contains value (start frame idx)
  hecate::sort( v_shot_nsrt, v_srt_val, v_srt_idx );
  
  // For concatenating vieos clips
  char filelist[512];
  sprintf( filelist, "%s/%s%s_seg.txt",
          opt.out_dir.c_str(), cdot, filename.c_str() );
  FILE *ptr_filelist = fopen( filelist, "w+" );
  
  // Parse ttml-format caption, if provided
  vector<hecate::tcc> ttml;
  if( !opt.caption.empty() ) {
    parse_ttml( opt.caption, ttml );
    if( ttml.empty() ) {
      fprintf( stderr, "generate_animated_gifs: "
              "Caption file %s cannot be read\n", opt.caption.c_str() );
    }
    // Convert second to frame index
    for(size_t i=0; i<ttml.size(); i++) {
      ttml[i].start *= fps;
      ttml[i].end *= fps;
    }
  }
  
  // GENERATE CLIPS
  char cmd[1024];
  char infile[512];
  char outfile[512];
  
  for( size_t i=0; i<v_highlight_range.size(); i++ )
  {
    int shotid = v_srt_idx[i];
    hecate::Range r = v_highlight_range[shotid];
    double sec_from = (double) (r.start+1) / fps;
    double sec_duration = (double) (r.end-r.start) / fps;
    string start_pos = hecate::second2string( sec_from, "hh:mm:ss.mss" );
    string duration = hecate::second2string( sec_duration, "hh:mm:ss.mss" );
    
    // --------------------- VIDEO CLIP GENERATOR ---------------------
    if( opt.mov )
    {
      // Crop video segment
      sprintf( outfile, "%s/%s%s_seg%03d.mp4",
              opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
      hecate::ffmpeg_video_crop( opt.in_video, std::string(outfile),
                             start_pos, duration, opt.mov_width_px );
      
      // Apply video fade-in/out
      sprintf( infile, "%s/%s%s_seg%03d.mp4",
              opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
      sprintf( outfile, "%s/%s%s_segV%03d.mp4",
              opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
      if( opt.fade ) {
        hecate::ffmpeg_video_fade( std::string(infile), std::string(outfile),
                               r.end-r.start+1,i==0 );
      }
      else {
        sprintf( cmd, "mv %s %s", infile, outfile ); system( cmd );
      }
      
      // Apply audio fade-in/out
      sprintf( infile, "%s/%s%s_segV%03d.mp4",
              opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
      sprintf( outfile, "%s/%s%s_segAV%03d.mp4",
              opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
      hecate::ffmpeg_audio_fade( std::string(infile), std::string(outfile),
                             sec_duration, fps );
      
      // Log filename for concat
      fprintf( ptr_filelist, "file %s%s_segAV%03d.mp4\n",
              cdot, filename.c_str(), shotid);
    }
    // --------------------- VIDEO CLIP GENERATOR ---------------------
    
    // --------------------- GIF CLIP GENERATOR ---------------------
    if( opt.gif ) {
      if( opt.gifsum )
      {
        // Crop video segment
        sprintf( outfile, "%s/%s%s_seg%03d.mp4",
                opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
        hecate::ffmpeg_video_crop( opt.in_video, std::string(outfile),
                               start_pos, duration, opt.mov_width_px );
        
        // Convert video to gif
        sprintf( infile, "%s", outfile );
        sprintf( outfile, "%s/%s_%02d.gif",
                opt.out_dir.c_str(), filename.c_str(), shotid);
        hecate::ffmpeg_video2gif( std::string(infile), std::string(outfile),
                              "", "", opt.gif_fps, opt.gif_width_px );
        
        // Log filename for concat
        fprintf( ptr_filelist, "file %s%s_seg%03d.mp4\n",
                cdot, filename.c_str(), shotid);
      }
      else
      {
        // Convert video to gif, direct memory access without cropping
        sprintf( outfile, "%s/%s_%02d.gif",
                opt.out_dir.c_str(), filename.c_str(), shotid);
        hecate::ffmpeg_video2gif( opt.in_video, std::string(outfile),
                              start_pos, duration, opt.gif_fps,
                              opt.gif_width_px );
      }
    }
    // --------------------- GIF CLIP GENERATOR ---------------------
  }
  
  // Close filelist
  fclose( ptr_filelist );
  
  if( opt.mov )
  {
    // Concatenate segments
    sprintf( outfile, "%s/%s_sum.mp4",
            opt.out_dir.c_str(), filename.c_str() );
    hecate::ffmpeg_video_concat( filelist, outfile );
  }
  
  if( opt.gif && opt.gifsum )
  {
    // Concatenate segments
    sprintf( outfile, "%s/%s%s_segsum.mp4",
            opt.out_dir.c_str(), cdot, filename.c_str() );
    hecate::ffmpeg_video_concat( filelist, outfile );
    
    // Convert video to gif
    sprintf( infile, "%s", outfile );
    sprintf( outfile, "%s/%s_sum.gif",
            opt.out_dir.c_str(), filename.c_str());
    hecate::ffmpeg_video2gif( std::string(infile), std::string(outfile),
                          "", "", opt.gif_fps, opt.gif_width_px );
  }
  
  // Clean up
  sprintf( cmd, "rm %s/%s%s_seg*.*",
          opt.out_dir.c_str(), cdot, filename.c_str() );
  system( cmd );
}
</file>

<file path="docker/base.Dockerfile">
FROM debian:buster-slim

# System packages
RUN apt-get clean && apt-get update -y && apt-get upgrade -y

# install dependencies
RUN apt-get install -y git wget vim build-essential cmake pkg-config libavcodec-dev libavformat-dev libswscale-dev libv4l-dev libxvidcore-dev libx264-dev libgtk-3-dev libatlas-base-dev gfortran ffmpeg

# install opencv_contrib
RUN git clone https://github.com/opencv/opencv_contrib.git && \
    cd opencv_contrib && \
    git checkout 3.3.1 && \
    cd ..

# install opencv
RUN git clone https://github.com/opencv/opencv.git && \
    cd opencv && \
    git checkout 3.3.1 && \
    sed -i "43i #define AV_CODEC_FLAG_GLOBAL_HEADER (1 << 22)\n#define CODEC_FLAG_GLOBAL_HEADER AV_CODEC_FLAG_GLOBAL_HEADER\n#define AVFMT_RAWPICTURE 0x0020" modules/videoio/src/cap_ffmpeg_impl.hpp && \
    mkdir build
    
RUN cd /opencv/build && \
    cmake -D CMAKE_BUILD_TYPE=RELEASE \
    -D CMAKE_INSTALL_PREFIX=/usr/local \
    -D INSTALL_C_EXAMPLES=ON \
    -D OPENCV_EXTRA_MODULES_PATH=/opencv_contrib/modules \
    -D BUILD_EXAMPLES=ON \
    -D WITH_FFMPEG=1 \
    -D ENABLE_FAST_MATH=1 \
    -D WITH_LAPACK=OFF .. && \
    make -j2 && \
    make install && export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib>>~/.bashrc

# install hecate
RUN git clone https://github.com/yahoo/hecate.git && \
    cd hecate && \
    make all && \
    make distribute

RUN echo "export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib">>~/.bashrc

# references
# # ref: https://cerebrumedge.com/blog/entry/compiling-opencv-with-cuda-and-ffmpeg-on-ubuntu-16.04#:~:text=FFMpeg%20and%20OpenCV,OPENCV_SOURCE_CODE%2F3rdparty%2Fffmpeg%2F.
# https://stackoverflow.com/questions/46884682/error-in-building-opencv-with-ffmpeg
# https://stackoverflow.com/questions/12335848/opencv-program-compile-error-libopencv-core-so-2-4-cannot-open-shared-object-f
</file>

<file path="docker/build.sh">
# Builds images
docker build -f base.Dockerfile -t hecate-core .
docker run --name hecate -it hecate-core
</file>

<file path="docker/README.md">
# HECATE - DOCKER INSTALLATION


## Installation

First you need to install docker on your local computer, see following [tutorial](https://docs.docker.com/install/linux/docker-ce/ubuntu/#set-up-the-repository). Note, for running the docker properly you have be logged as superuser otherwise you will face many partial issues which sometimes does not make much sense.

Check your installation using
```
docker -v
```

Once you install the docker correctly, follow the instruction below:
```
$ git clone https://github.com/yahoo/hecate.git
$ cd hecate/docker
$ ./build.sh
```

Now the hecate CLI should open up for you or else you may need to:
```
docker exec -it hecate bash
```

Once you've successfully compiled hecate, it will generate a binary executable under `distribute/bin/`. Run the following command to check if everything works properly:
```
$ cd hecate
$ ./distribute/bin/hecate

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 HECATE Copyright 2016 Yahoo Inc.
   Licensed under the terms of the Apache 2.0 License.
   Developed by : Yale Song (yalesong@yahoo-inc.com)
   Built on  : 11:46:03 Aug 11 2016
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
USAGE: hecate -i infile [options]

  -i  --in_video      (string)    Input video file
  -o  --out_dir       (string)    Output directory (./output)
  -s  --step          (int)       Frame subsampling step size (1)
  -n  --njpg          (int)       Number of thumbnails to be generated (5)
  -q  --ngif          (int)       Number of GIFs to be generated (5)
  -r  --lmov          (int)       Length of video summary to be generated (in seconds) (15)
  -u  --jpg_width_px  (int)       Pixel width of thumbnail images (360)
  -v  --gif_width_px  (int)       Pixel width of animated GIFs (360)
  -w  --mov_width_px  (int)       Pixel width of summary video (360)
  --generate_jpg                  Generate thumbnail images
  --generate_gif                  Generate animated GIFs
  --generate_mov                  Generate a summary video
  --generate_gifsum               Generate animated GIFs summary
  --generate_gifall               Generate all possible animated GIFs
  --print_shot_info               Print shot boundary detection results
  --print_keyfrm_info             Print keyframe indices
```

Congratulations! You have successfully installed hecate!


## Docker Developer

Sayantan Mandal: [github](https://github.com/smandal047)

##
</file>

<file path=".dccache">
[{"/Users/adam/Developer/vcs/github.twardoch/pub/hecate/include/hecate/cc_parser.hpp":"1","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/include/hecate/ffmpeg_helper.hpp":"2","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/include/hecate/file_helper.hpp":"3","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/include/hecate/gapstat.hpp":"4","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/include/hecate/gflseg.hpp":"5","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/include/hecate/hecate.hpp":"6","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/include/hecate/hist_opencv.hpp":"7","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/include/hecate/image_metrics.hpp":"8","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/include/hecate/knapsack.hpp":"9","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/include/hecate/shot_range.hpp":"10","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/include/hecate/sort.hpp":"11","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/include/hecate/time.hpp":"12","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/include/hecate/video_parser.hpp":"13","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/src/hecate/gflseg.cpp":"14","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/src/hecate/hecate_highlight.cpp":"15","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/src/hecate/hecate_main.cpp":"16","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/src/hecate/hecate_thumbnail.cpp":"17","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/src/hecate/video_parser.cpp":"18","/Users/adam/Developer/vcs/github.twardoch/pub/hecate/src/tools/hecate.cpp":"19"},[6349,1598330503000,"20"],[5045,1598330503000,"21"],[5343,1598330503000,"22"],[4670,1598330503000,"23"],[7560,1598330503000,"24"],[12565,1598330503000,"25"],[7312,1598330503000,"26"],[13496,1598330503000,"27"],[1142,1598330503000,"28"],[3573,1598330503000,"29"],[2670,1598330503000,"30"],[1538,1598330503000,"31"],[6454,1598330503000,"32"],[15629,1598330503000,"33"],[20470,1598330503000,"34"],[5480,1598330503000,"35"],[6165,1598330503000,"36"],[21649,1598330503000,"37"],[1584,1598330503000,"38"],"b8beb40b91e3a98b66e74dd6959773dcdde96355ceaa67817d1fda68b195ffcb","4b222a15b7931de36fa5d6ae39e2feec1a2c7162ea7da033f3ecd8e446662b9d","042552a9d6d43d5180d9e39f5c8561475330e58f9e7573563c240aae976999f7","2dd788ece5171b9b0902f257b4cbc818b1cd49b5d802422b32a574965ffa26c6","0f3637e649cdbf28265135c0ebc5572cc9a680a667db363d4e1c9f4e039d5773","53cb9cd2e87c42d5d77a999dd4f819f1c336381de594c791a173dd860abeb09e","5cc986a79c2b28ea2e394af7ce916ffa6ae2d60559a06dc8c7148a94179cb157","30160fcd704c2b8a56c5f6c2dfebc60d628ed69a29a8f16e66d39de9d14269ff","9f5f5f7dd8a2e0726ddf50676a3b610aa1746fd30c9c0be6fc7c2d9de694593d","3b825bb5cb70d6f4efc0b114e449459f64a953928a046945578eb085cbc7f0eb","99c1dda0fc0c39c9c89a0002034a6eba759740e0ad749e77f6e7ebd426126b4b","2538099273beea513c394859d3525437a4b2143c1cc3d2066a4719c99921eb0d","8584d8301bf3def523dc9bf130fae86432a0e1a564dc45ea22e2cdfd7eccb2ba","1b8b4cf23480fc098ce56be210a539f058d63bad3aeafc0ba077b8fa9699e5ab","78a5a2ac9b2c93c352a29ff5f2059ec8b8a2bf12e6170c8ba433c79476689b00","5d88a9fb3389369b72ada1a6194d1e9f26bba47f1a156a4ef5fb002fa15aaae7","911de8019a22aa25b41294c89540eaabf100dedb152cf3a2a3851e0b5860ec75","c1ec157fd82d4cb6362aaab8d67122fd275fca97715bbba6c35758790c399297","ae5e54b8f4825fbbf3b49dbedad216871bdac317d509231c58355aebb110b3e9"]
</file>

<file path="Makefile">
PROJECT := hecate

CONFIG_FILE := Makefile.config

# Explicitly check for the config file, otherwise make -k will proceed anyway.
ifeq ($(wildcard $(CONFIG_FILE)),)
	$(error $(CONFIG_FILE) not found. See $(CONFIG_FILE).example.)
endif
include $(CONFIG_FILE)

BUILD_DIR_LINK := $(BUILD_DIR)
ifeq ($(RELEASE_BUILD_DIR),)
	RELEASE_BUILD_DIR := .$(BUILD_DIR)_release
endif
ifeq ($(DEBUG_BUILD_DIR),)
	DEBUG_BUILD_DIR := .$(BUILD_DIR)_debug
endif

DEBUG ?= 0
ifeq ($(DEBUG), 1)
	BUILD_DIR := $(DEBUG_BUILD_DIR)
	OTHER_BUILD_DIR := $(RELEASE_BUILD_DIR)
else
	BUILD_DIR := $(RELEASE_BUILD_DIR)
	OTHER_BUILD_DIR := $(DEBUG_BUILD_DIR)
endif

# All of the directories containing code.
SRC_DIRS := $(shell find * -type d -exec bash -c "find {} -maxdepth 1 \
	\( -name '*.cpp' \) | grep -q ." \; -print)

# The target shared library name
LIB_BUILD_DIR := $(BUILD_DIR)/lib
STATIC_NAME := $(LIB_BUILD_DIR)/lib$(PROJECT).a
DYNAMIC_NAME := $(LIB_BUILD_DIR)/lib$(PROJECT).so

##############################
# Get all source files
##############################
# CXX_SRCS are the source files
ifeq ($(BUILD_TEXT), 1)
  CXX_SRCS := $(shell find src/$(PROJECT) -name "*.cpp")
else
  CXX_SRCS := $(filter-out src/$(PROJECT)/text.cpp, $(shell find src/$(PROJECT) -name "*.cpp"))
endif

# TOOL_SRCS are the source files for the tool binaries
ifeq ($(BUILD_TEXT), 1)
  TOOL_SRCS := $(shell find src/tools -name "*.cpp")
else
  TOOL_SRCS := $(filter-out src/tools/aesthetic_feature_extractor.cpp, $(shell find src/tools -name "*.cpp"))
endif

# BUILD_INCLUDE_DIR contains any generated header files we want to include.
BUILD_INCLUDE_DIR := $(BUILD_DIR)/src


##############################
# Derive generated files
##############################
# The generated files for protocol buffers
# The objects corresponding to the source files
# These objects will be linked into the final shared library, so we
# exclude the tool and test objects.
CXX_OBJS := $(addprefix $(BUILD_DIR)/, ${CXX_SRCS:.cpp=.o})
OBJS := $(CXX_OBJS)

# tool objects
TOOL_OBJS := $(addprefix $(BUILD_DIR)/, ${TOOL_SRCS:.cpp=.o})
TOOL_BUILD_DIR := $(BUILD_DIR)/tools

# Output files for automatic dependency generation
DEPS := ${CXX_OBJS:.o=.d}

# tool bins
TOOL_BINS := ${TOOL_OBJS:.o=}


##############################
# Derive compiler warning dump locations
##############################
WARNS_EXT := warnings.txt
CXX_WARNS := $(addprefix $(BUILD_DIR)/, ${CXX_SRCS:.cpp=.o.$(WARNS_EXT)})
TOOL_WARNS := $(addprefix $(BUILD_DIR)/, ${TOOL_SRCS:.cpp=.o.$(WARNS_EXT)})
ALL_CXX_WARNS := $(CXX_WARNS) $(TOOL_WARNS)
ALL_WARNS := $(ALL_CXX_WARNS)
NONEMPTY_WARN_REPORT := $(BUILD_DIR)/$(WARNS_EXT)


##############################
# Derive include and lib directories
##############################
INCLUDE_DIRS += $(BUILD_INCLUDE_DIR) ./include

LIBRARIES += opencv_core opencv_highgui opencv_imgproc
ifeq ($(OPENCV_VERSION), 3)
	LIBRARIES += opencv_imgcodecs opencv_videoio
endif

WARNINGS := -Wall -Wno-sign-compare


##############################
# Set build directories
##############################

DISTRIBUTE_DIR ?= distribute
DISTRIBUTE_SUBDIRS := $(DISTRIBUTE_DIR)/bin $(DISTRIBUTE_DIR)/lib
DIST_ALIASES := dist
ifneq ($(strip $(DISTRIBUTE_DIR)),distribute)
		DIST_ALIASES += distribute
endif

ALL_BUILD_DIRS := $(sort $(BUILD_DIR) $(addprefix $(BUILD_DIR)/, \
$(SRC_DIRS)) $(LIB_BUILD_DIR) $(DISTRIBUTE_SUBDIRS))


##############################
# Configure build
##############################

# Determine platform
UNAME := $(shell uname -s)
ifeq ($(UNAME), Linux)
	LINUX := 1
else ifeq ($(UNAME), Darwin)
	OSX := 1
endif

# Linux
ifeq ($(LINUX), 1)
	CXX ?= /usr/bin/g++
	GCCVERSION := $(shell $(CXX) -dumpversion | cut -f1,2 -d.)
	# older versions of gcc are too dumb to build boost with -Wuninitalized
	ifeq ($(shell echo | awk '{exit $(GCCVERSION) < 4.6;}'), 1)
		WARNINGS += -Wno-uninitialized
	endif
	# We will explicitly add stdc++ to the link target.
	LIBRARIES += stdc++
	COMMON_FLAGS += -fopenmp
endif

# OS X:
# clang++ instead of g++
ifeq ($(OSX), 1)
	CXX := /usr/bin/clang++
	# we need to explicitly ask for the rpath to be obeyed
	DYNAMIC_FLAGS := -install_name @rpath/lib$(PROJECT).so
	ORIGIN := @loader_path
else
	ORIGIN := \$$ORIGIN
endif

# Custom compiler
ifdef CUSTOM_CXX
	CXX := $(CUSTOM_CXX)
endif

# Debugging
ifeq ($(DEBUG), 1)
	COMMON_FLAGS += -std=c++0x -DDEBUG -g -O0
else
	COMMON_FLAGS += -std=c++0x -DNDEBUG -O2
endif

LIBRARY_DIRS += $(LIB_BUILD_DIR)

# Automatic dependency generation
CXXFLAGS += -MMD -MP

# Complete build flags.
COMMON_FLAGS += $(foreach includedir,$(INCLUDE_DIRS),-I$(includedir))
CXXFLAGS += -pthread -fPIC $(COMMON_FLAGS) $(WARNINGS)
LINKFLAGS += -pthread -fPIC $(COMMON_FLAGS) $(WARNINGS)

LDFLAGS += $(foreach librarydir,$(LIBRARY_DIRS),-L$(librarydir)) $(PKG_CONFIG) \
		$(foreach library,$(LIBRARIES),-l$(library))


##############################
# Define build targets
##############################
.PHONY: all lib tools clean $(DIST_ALIASES)

all: lib tools

lib: $(STATIC_NAME) $(DYNAMIC_NAME)

tools: $(TOOL_BINS)

$(ALL_WARNS): %.o.$(WARNS_EXT) : %.o

$(BUILD_DIR_LINK): $(BUILD_DIR)/.linked

# Create a target ".linked" in this BUILD_DIR to tell Make that the "build" link
# is currently correct, then delete the one in the OTHER_BUILD_DIR in case it
# exists and $(DEBUG) is toggled later.
$(BUILD_DIR)/.linked:
	@ mkdir -p $(BUILD_DIR)
	@ $(RM) $(OTHER_BUILD_DIR)/.linked
	@ $(RM) -r $(BUILD_DIR_LINK)
	@ ln -s $(BUILD_DIR) $(BUILD_DIR_LINK)
	@ touch $@

$(ALL_BUILD_DIRS): | $(BUILD_DIR_LINK)
	@ mkdir -p $@

$(DYNAMIC_NAME): $(OBJS) | $(LIB_BUILD_DIR)
	@ echo LD -o $@
	$(Q)$(CXX) -shared -o $@ $(OBJS) $(LINKFLAGS) $(LDFLAGS) $(DYNAMIC_FLAGS)

$(STATIC_NAME): $(OBJS) | $(LIB_BUILD_DIR)
	@ echo AR -o $@
	$(Q)ar rcs $@ $(OBJS)

$(BUILD_DIR)/%.o: %.cpp | $(ALL_BUILD_DIRS)
	@ echo CXX $<
	$(Q)$(CXX) $< $(CXXFLAGS) -c -o $@ 2> $@.$(WARNS_EXT) \
		|| (cat $@.$(WARNS_EXT); exit 1)
	@ cat $@.$(WARNS_EXT)

# Target for extension-less tool binaries
$(TOOL_BUILD_DIR)/%: $(TOOL_BUILD_DIR)/% | $(TOOL_BUILD_DIR)
	@ $(RM) $@
	@ ln -s $(abspath $<) $@

$(TOOL_BINS): % : %.o | $(DYNAMIC_NAME)
	@ echo CXX/LD -o $@
	$(Q)$(CXX) $< -o $@ $(LINKFLAGS) $(LDFLAGS) -l$(PROJECT)\
		-Wl,-rpath,$(ORIGIN)/../lib

clean:
	@- $(RM) -rf $(ALL_BUILD_DIRS)
	@- $(RM) -rf $(OTHER_BUILD_DIR)
	@- $(RM) -rf $(BUILD_DIR_LINK)
	@- $(RM) -rf $(DISTRIBUTE_DIR)

$(DIST_ALIASES): $(DISTRIBUTE_DIR)

$(DISTRIBUTE_DIR): all | $(DISTRIBUTE_SUBDIRS)
	# add include
	cp -r include $(DISTRIBUTE_DIR)/
	# add tool binaries
	cp $(TOOL_BINS) $(DISTRIBUTE_DIR)/bin
	# add libraries
	cp $(STATIC_NAME) $(DISTRIBUTE_DIR)/lib
	install -m 644 $(DYNAMIC_NAME) $(DISTRIBUTE_DIR)/lib

-include $(DEPS)
</file>

<file path="Makefile.config">
# Directories containing ffmpeg and opencv
INCLUDE_DIRS := /usr/local/include
LIBRARY_DIRS := /usr/local/lib

# Comment if you're using OpenCV 2.4
OPENCV_VERSION := 3

BUILD_DIR := build
DISTRIBUTE_DIR := distribute

# Uncomment for debugging.
# DEBUG := 1

# enable pretty build (comment to see full commands)
Q ?= @
</file>

<file path="null.d">
null.o: /dev/null
</file>

<file path="src/hecate/hecate_highlight.cpp">
/*
 * HECTATE Video Processing Library - Highlight
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#include "hecate/hecate.hpp"

using namespace std;
using namespace cv;


void detect_highlight_shots( hecate_params& opt, hecate::video_metadata& meta,
                            const vector<hecate::ShotRange>& v_shot_range,
                            const Mat& X, const Mat& diff,
                            vector<hecate::Range>& v_highlight_range)
{
  if( opt.gif && opt.mov ) {
    fprintf( stderr, "Fatal Error in detect_highlight_shots():"
            "opt.gif and opt.mov cannot be true at the same time.\n" );
    exit(-1);
  }
  
  v_highlight_range.clear();

  const int minK = 5;
  const int maxK = 30;

  ////////////////////////////////////////////////////////////////////////////
  //
  // Discard shots that are too short or too static
  //
  ////////////////////////////////////////////////////////////////////////////

  int min_shot_len, max_shot_len, min_num_shot;
  if( opt.mov ) {
    double addrate_min = 0.5 * sqrt(max(0.0,(double)opt.lmov-15.0)/45.0);
    double addrate_max = sqrt(max(0.0,(double)opt.lmov-15.0)/45.0);
    min_shot_len = floor((3.0+addrate_min) * meta.fps / opt.step_sz);
    max_shot_len = round((1.0+addrate_max) * min_shot_len);
    min_num_shot = ceil( opt.lmov / 3.0 );
    if( opt.debug ) {
      printf("detect_highlight_shots(): "
             "min_shot_len=%d, max_shot_len=%d, min_num_shot=%d, "
             "addrate_min=%f, addrate_max=%f\n",
             min_shot_len, max_shot_len, min_num_shot,
             addrate_min, addrate_max);
    }
  }
  else {
    min_shot_len = floor(1.5 * meta.fps / opt.step_sz);
    max_shot_len = ceil (4.5 * meta.fps / opt.step_sz);
    min_num_shot = opt.ngif;
  }

  // Active set containing candidates for highlight shots
  vector<hecate::Range> v_candidates;
  for(size_t i=0; i<v_shot_range.size(); i++) {
    hecate::Range shot(v_shot_range[i].start, v_shot_range[i].end);
    shot.v_idx = v_shot_range[i].v_idx;
    int shot_len = shot.length();
    double avg_diff=0;
    for(int i=shot.start; i<=shot.end; i++)
      avg_diff += diff.at<double>(i);
    avg_diff/=shot.length();
    
    // Discard if too short.
    if( shot_len < min_shot_len ) {
      //printf("Discard SHORT (shot_len=%d, avg_diff=%f) ", shot_len, avg_diff); shot.print();
      continue;
    }
    
    // Discard if too static
    if( avg_diff < 0.05 ) {
      //printf("Discard STATIC (shot_len=%d, avg_diff=%f) ", shot_len, avg_diff); shot.print();
      continue;
    }
    
    // Add the shot
    v_candidates.push_back( shot );
  }

  // If there's not enough shots, merged adjacent shots and add them
  if( (int)v_candidates.size() < min_num_shot ) {
    if( opt.debug ) {
      printf("detect_highlight_shots(): "
             "Not enough candidate shots (current=%d/%d, min=%d)\n",
             (int)v_candidates.size(), (int)v_shot_range.size(), min_num_shot);
    }
    for(size_t i=0; i<v_shot_range.size(); i++) {
      // Merge shots until it's longer than min_shot_len
      size_t j=i;
      int cumlen=0;
      while( (j+1)<v_shot_range.size() ) {
        cumlen += v_shot_range[j].length();
        if( cumlen<min_shot_len ) { j++; } else { break; }
      }
      // Construct a shot
      hecate::Range shot(v_shot_range[i].start, v_shot_range[j].end);
      shot.v_idx.clear();
      for(size_t k=i; k<=j; k++)
        shot.v_idx.insert( shot.v_idx.end(),
            v_shot_range[k].v_idx.cbegin(), v_shot_range[k].v_idx.cend());

      // Check if this shot is already in v_candidates
      bool exists = false;
      for( size_t k=0; k<v_candidates.size(); k++ ) {
        if( v_candidates[k].start >= shot.start &&
           v_candidates[k].start <= shot.end ) {
          exists = true; break;
        }
      }
      if( !exists && shot.length() >= min_shot_len ) {
        v_candidates.push_back( shot );
      }
      i = j+1;
    }

    // Sort candidate shots in a chronogical order
    vector<hecate::Range> v_candidates_tmp;
    vector<int> v_shot_nsrt; // shots in non-sorted order
    for( size_t i=0; i<v_candidates.size(); i++ )
      v_shot_nsrt.push_back( v_candidates[i].start );
    // sort wrt frame index in an ascending order
    vector<size_t> v_srt_idx; // contains idx
    vector<int> v_srt_val; // contains value (start frame idx)
    hecate::sort( v_shot_nsrt, v_srt_val, v_srt_idx );
    for(size_t i=0; i<v_srt_idx.size(); i++) {
      v_candidates_tmp.push_back( v_candidates[v_srt_idx[i]] );
    }
    v_candidates = v_candidates_tmp;
  }
  
  
  // Shorten shots if too long.
  // Prefer static shot; potentially reduces jitter
  for(size_t i=0; i<v_candidates.size(); i++) {
    hecate::Range shot = v_candidates[i];
    int shot_len = shot.length();
    if( shot_len > max_shot_len ) {
      while( shot_len > max_shot_len ) {
        Scalar mu, sigma, mu2, sigma2;
        meanStdDev( diff(Rect(0,shot.start+1,1,shot.length()-1)), mu, sigma );
        meanStdDev( diff(Rect(0,shot.start,  1,shot.length()-1)), mu2, sigma2 );
        if( sigma[0] < sigma2[0] )
          shot.start++;
        else
          shot.end--;
        shot_len = shot.length();
      }
    }
    v_candidates[i] = shot;
  }
  
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Group visually simimlar shots
  //
  // Represent each shot as a piece-wise constant multi-dimensional signal
  // Then run kmeans (k=#nshots_highlight).
  //
  ////////////////////////////////////////////////////////////////////////////
  
  // Prepare data for kmeans
  // Compute piece-wise constant feature representation
  Mat km_data( (int)v_candidates.size(), X.cols, X.type() );
  for( size_t shotid=0; shotid<v_candidates.size(); shotid++ ) {
    hecate::Range s = v_candidates[shotid];
    Mat Xsub = X( Rect(0, s.start, X.cols, s.length()) );
    cv::reduce( Xsub, km_data.row(shotid), 0, CV_REDUCE_AVG );
  }
  
  // Perform k-means (repeat 5 times)
  Mat km_lbl; // integer row vector; stores cluster IDs for every sample.
  Mat km_ctr; // one row per each cluster center.
  int km_k = min(maxK, min((int)v_candidates.size(), max(minK, min_num_shot)));
  hecate::perform_kmeans( km_data, km_lbl, km_ctr, km_k, 5 );
  
  // measure cluster size
  vector<int> v_shotlen;
  for(size_t i=0; i<v_candidates.size(); i++) {
    v_shotlen.push_back( v_candidates[i].length() );
  }
  vector<int> clust_sz(km_k,0);
  for(int i=0; i<km_lbl.rows; i++)
    clust_sz[ km_lbl.at<int>(i) ] += v_shotlen[i];
  
  // sort wrt cluster size in an ascending order
  vector<size_t> v_srt_idx; // contains cluster id
  vector<int> v_srt_val;    // contains cluster size
  hecate::sort( clust_sz, v_srt_val, v_srt_idx );
  
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Shot evaluation
  //
  // Criteria: prefer the most dynamic shot among others within the same cluster
  //
  ////////////////////////////////////////////////////////////////////////////
  
  // Pre-compute per-shot diff score avg & stddev
  Mat shot_diff_avg(v_candidates.size(), 1, diff.type(), Scalar(0,0,0)[0]);
  Mat shot_diff_std(v_candidates.size(), 1, diff.type(), Scalar(0,0,0)[0]);
  for( size_t shotid=0; shotid<v_candidates.size(); shotid++ ) {
    Scalar mu, sigma;
    hecate::Range s = v_candidates[shotid];
    meanStdDev( diff(Rect(0,s.start,1,s.length())), mu, sigma );
    shot_diff_avg.at<double>(shotid) = (double) mu[0];
    shot_diff_std.at<double>(shotid) = (double) sigma[0];
  }

  vector<int> v_shot_len;
  vector<double> v_shot_score;
  for(size_t i=0; i<v_candidates.size(); i++) {
    v_shot_len.push_back( v_candidates[i].length() );
    v_shot_score.push_back( 0.0 );
  }

  // Start with the largest cluster
  for(int i=0; i<km_k; i++)
  {
    int k = v_srt_idx[km_k-i-1];
    hecate::Range best_range(-1,-1);
    double best_val = -numeric_limits<double>::max();
    
    // Collect IDs & scores of the shots in the k-th cluster
    vector<int> v_tmp_shotid;
    vector<double> v_tmp_score;
    for(int shotid=0; shotid<km_lbl.rows; shotid++) {
      int lbl = km_lbl.at<int>(shotid);
      if( lbl==k ) {
        double val = shot_diff_avg.at<double>(shotid);
        if( val > best_val ) {
          best_range = v_candidates[shotid];
          best_val = val;
        }
        v_tmp_shotid.push_back( shotid );
        v_tmp_score.push_back( val );
      }
    }
    
    // If GIF mode, add shots here
    if( opt.gif ) {
      if( best_range.start>=0 && best_range.length()>0 )
        v_highlight_range.push_back( best_range );
      if( (int)v_highlight_range.size() >= opt.ngif )
        break;
    }
    
    // If MOV mode, store shot scores
    if( opt.mov ) {
      // Sort wrt avg_diff score, ascending order
      vector<size_t> v_srt_idx2;
      vector<double> v_srt_val2;
      hecate::sort( v_tmp_score, v_srt_val2, v_srt_idx2 );
      
      // Record normalized scores
      for( size_t i=0; i<v_srt_idx2.size(); i++ ) {
        // if prefer dynamic, higher avg_diff gets priority
        int order = (opt.prefer_dynamic) ? v_srt_idx2.size()-1-i : i;
        v_shot_score[v_tmp_shotid[v_srt_idx2[order]]] = 100.0/(1.0+(double(i)));
      }
    }
  }
  
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Shot selection
  //
  // Criteria: prefer the most dynamic shot among others within the same cluster
  //
  ////////////////////////////////////////////////////////////////////////////
  
  // Return all available segments
  if ( opt.gif ) {
    if( opt.gifall ) {
      v_highlight_range = v_candidates;
    }
  }
  
  if( opt.mov ) {
    int budget = floor(opt.lmov * meta.fps / opt.step_sz);
    budget += (int)(0.5 * max_shot_len); // buffer
    
    // solve 0/1 knapsack
    vector<bool> sol;
    hecate::solve_01knapsack( v_shot_score, v_shot_len, budget, sol );
    
    // merge shots if only they are only half a second apart
    int merge_thrsh = ceil(0.5 * meta.fps / opt.step_sz);
    for( size_t i=0; i<sol.size(); i++ ) {
      if( sol[i] ) {
        hecate::Range r = v_candidates[i];
        if( v_highlight_range.empty() ) {
          v_highlight_range.push_back( v_candidates[i] );
        }
        else {
          int dist = r.start - v_highlight_range[v_highlight_range.size()-1].end + 1;
          if( dist < merge_thrsh )
            v_highlight_range[v_highlight_range.size()-1].end = r.end;
          else
            v_highlight_range.push_back( v_candidates[i] );
        }
      }
    }
  }

  for(size_t i=0; i<v_highlight_range.size(); i++) {
    v_highlight_range[i].start *= opt.step_sz;
    v_highlight_range[i].end *= opt.step_sz;
  }
  
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Post Processing
  //
  // Ensures summary video length is exactly the same as required
  //
  ////////////////////////////////////////////////////////////////////////////
  
  // Ensures highlight ranges sums up to exactly target length
  if( opt.mov ) {
    int target = round(opt.lmov * meta.fps);
    int curlen = 0;
    for(size_t i=0; i<v_highlight_range.size(); i++) {
      curlen += v_highlight_range[i].length();
    }
    //printf("target=%d, cur=%d\n", target, curlen);
    if( curlen!=target ) {
      // If summary is too long
      while( curlen>target ) {
        // Pick a random shot
        int idx = rand() % (int) v_highlight_range.size();
        hecate::Range shot = v_highlight_range[idx];
        // Remove frame that reduces stddev of the shot by the most
        Scalar mu, sigma, mu2, sigma2;
        meanStdDev( diff(Rect(0,shot.start+1,1,shot.length()-1)), mu, sigma );
        meanStdDev( diff(Rect(0,shot.start,1,shot.length()-1)), mu2, sigma2 );
        if( sigma[0] < sigma2[0] )
          v_highlight_range[idx].start++;
        else
          v_highlight_range[idx].end--;
        curlen--;
      }
      // If video is longer than target, but summary is too short
      int shot_edge_buf = 10;
      int failed_attempt = 0;
      while( curlen<target ) {
        // Pick a random shot
        int idx = rand() % (int) v_highlight_range.size();
        hecate::Range shot = v_highlight_range[idx];
        
        // Add frame that increases stddev of the shot by the least
        bool failed = false;
        if( v_highlight_range[idx].start<shot_edge_buf ) {
          if( idx+1<v_highlight_range.size() && v_highlight_range[idx+1].start >
             v_highlight_range[idx].end+1+shot_edge_buf ) {
              v_highlight_range[idx].end++;
          }
          else {
            failed = true;
          }
        }
        else if( v_highlight_range[idx].end>meta.nframes-shot_edge_buf ) {
          if( idx>0 && v_highlight_range[idx-1].end <
             v_highlight_range[idx].start-1-shot_edge_buf ) {
            v_highlight_range[idx].start--;
          }
          else {
            failed = true;
          }
        }
        else {
          Scalar mu, sigma, mu2, sigma2;
          meanStdDev( diff(Rect(0,shot.start-1,1,shot.length()+1)), mu, sigma );
          meanStdDev( diff(Rect(0,shot.start,1,shot.length()+1)), mu2, sigma2 );
          if( sigma[0] < sigma2[0] ) {
            if( v_highlight_range[idx-1].end <
               v_highlight_range[idx].start-1-shot_edge_buf ) {
              v_highlight_range[idx].start--;
            }
            else {
              failed = true;
            }
          }
          else {
            if( v_highlight_range[idx+1].start >
               v_highlight_range[idx].end+1+shot_edge_buf) {
              v_highlight_range[idx].end++;
            }
            else {
              failed = true;
            }
          }
        }
        if( !failed )
          curlen++;
        else
          failed_attempt++;
        if( failed_attempt>10*(int)v_highlight_range.size() ) {
          if( opt.debug ) {
            printf("Failed to meet the target length in video summary\n");
          }
          break;
        }
      }
    }
    //curlen = 0;
    //for(size_t i=0; i<v_highlight_range.size(); i++)
    //  curlen += v_highlight_range[i].length();
    //printf("target=%d, cur=%d\n", target, curlen);
  }
}


////////////////////////////////////////////////////////////////////////////
//
// Highlight clip generation
//
////////////////////////////////////////////////////////////////////////////

void generate_highlight_clips( hecate_params& opt, vector<hecate::Range>& v_highlight_range )
{
  if( opt.gif && opt.mov ) {
    fprintf( stderr, "Fatal Error in generate_highlight_clips():"
            "opt.gif and opt.mov cannot be true at the same time.\n" );
    exit(-1);
  }
  
  // prefix for hiddden files generated during execution
  const char *cdot = "__tmp__";
  
  string filename = hecate::get_filename( std::string(opt.in_video) );
  
  VideoCapture vr( opt.in_video );
  double fps = vr.get(CV_CAP_PROP_FPS);
  vr.release();
  
  // Sort shots in chronological order
  vector<int> v_shot_nsrt; // shots in non-sorted order
  for( size_t i=0; i<v_highlight_range.size(); i++ )
    v_shot_nsrt.push_back( v_highlight_range[i].start );
  
  // sort wrt frame index in an ascending order
  vector<size_t> v_srt_idx; // contains idx
  vector<int> v_srt_val; // contains value (start frame idx)
  hecate::sort( v_shot_nsrt, v_srt_val, v_srt_idx );
  
  // For concatenating vieos clips
  char filelist[512];
  sprintf( filelist, "%s/%s%s_seg.txt",
          opt.out_dir.c_str(), cdot, filename.c_str() );
  FILE *ptr_filelist = fopen( filelist, "w+" );
  
  // Parse ttml-format caption, if provided
  vector<hecate::tcc> ttml;
  if( !opt.caption.empty() ) {
    parse_ttml( opt.caption, ttml );
    if( ttml.empty() ) {
      fprintf( stderr, "generate_animated_gifs: "
              "Caption file %s cannot be read\n", opt.caption.c_str() );
    }
    // Convert second to frame index
    for(size_t i=0; i<ttml.size(); i++) {
      ttml[i].start *= fps;
      ttml[i].end *= fps;
    }
  }
  
  // GENERATE CLIPS
  char cmd[1024];
  char infile[512];
  char outfile[512];
  
  for( size_t i=0; i<v_highlight_range.size(); i++ )
  {
    int shotid = v_srt_idx[i];
    hecate::Range r = v_highlight_range[shotid];
    double sec_from = (double) (r.start+1) / fps;
    double sec_duration = (double) (r.end-r.start) / fps;
    string start_pos = hecate::second2string( sec_from, "hh:mm:ss.mss" );
    string duration = hecate::second2string( sec_duration, "hh:mm:ss.mss" );
    
    // --------------------- VIDEO CLIP GENERATOR ---------------------
    if( opt.mov )
    {
      // Crop video segment
      sprintf( outfile, "%s/%s%s_seg%03d.mp4",
              opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
      hecate::ffmpeg_video_crop( opt.in_video, std::string(outfile),
                             start_pos, duration, opt.mov_width_px );
      
      // Apply video fade-in/out
      sprintf( infile, "%s/%s%s_seg%03d.mp4",
              opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
      sprintf( outfile, "%s/%s%s_segV%03d.mp4",
              opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
      if( opt.fade ) {
        hecate::ffmpeg_video_fade( std::string(infile), std::string(outfile),
                               r.end-r.start+1,i==0 );
      }
      else {
        sprintf( cmd, "mv %s %s", infile, outfile ); system( cmd );
      }
      
      // Apply audio fade-in/out
      sprintf( infile, "%s/%s%s_segV%03d.mp4",
              opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
      sprintf( outfile, "%s/%s%s_segAV%03d.mp4",
              opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
      hecate::ffmpeg_audio_fade( std::string(infile), std::string(outfile),
                             sec_duration, fps );
      
      // Log filename for concat
      fprintf( ptr_filelist, "file %s%s_segAV%03d.mp4\n",
              cdot, filename.c_str(), shotid);
    }
    // --------------------- VIDEO CLIP GENERATOR ---------------------
    
    // --------------------- GIF CLIP GENERATOR ---------------------
    if( opt.gif ) {
      if( opt.gifsum )
      {
        // Crop video segment
        sprintf( outfile, "%s/%s%s_seg%03d.mp4",
                opt.out_dir.c_str(), cdot, filename.c_str(), shotid);
        hecate::ffmpeg_video_crop( opt.in_video, std::string(outfile),
                               start_pos, duration, opt.mov_width_px );
        
        // Convert video to gif
        sprintf( infile, "%s", outfile );
        sprintf( outfile, "%s/%s_%02d.gif",
                opt.out_dir.c_str(), filename.c_str(), shotid);
        hecate::ffmpeg_video2gif( std::string(infile), std::string(outfile),
                              "", "", opt.gif_fps, opt.gif_width_px );
        
        // Log filename for concat
        fprintf( ptr_filelist, "file %s%s_seg%03d.mp4\n",
                cdot, filename.c_str(), shotid);
      }
      else
      {
        // Convert video to gif, direct memory access without cropping
        sprintf( outfile, "%s/%s_%02d.gif",
                opt.out_dir.c_str(), filename.c_str(), shotid);
        hecate::ffmpeg_video2gif( opt.in_video, std::string(outfile),
                              start_pos, duration, opt.gif_fps,
                              opt.gif_width_px );
      }
    }
    // --------------------- GIF CLIP GENERATOR ---------------------
  }
  
  // Close filelist
  fclose( ptr_filelist );
  
  if( opt.mov )
  {
    // Concatenate segments
    sprintf( outfile, "%s/%s_sum.mp4",
            opt.out_dir.c_str(), filename.c_str() );
    hecate::ffmpeg_video_concat( filelist, outfile );
  }
  
  if( opt.gif && opt.gifsum )
  {
    // Concatenate segments
    sprintf( outfile, "%s/%s%s_segsum.mp4",
            opt.out_dir.c_str(), cdot, filename.c_str() );
    hecate::ffmpeg_video_concat( filelist, outfile );
    
    // Convert video to gif
    sprintf( infile, "%s", outfile );
    sprintf( outfile, "%s/%s_sum.gif",
            opt.out_dir.c_str(), filename.c_str());
    hecate::ffmpeg_video2gif( std::string(infile), std::string(outfile),
                          "", "", opt.gif_fps, opt.gif_width_px );
  }
  
  // Clean up
  sprintf( cmd, "rm %s/%s%s_seg*.*",
          opt.out_dir.c_str(), cdot, filename.c_str() );
  system( cmd );
}
</file>

<file path="include/hecate/cc_parser.hpp">
/*
 * Video caption parser (VTT and TTML)
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_CC_PARSER_HPP
#define HECATE_CC_PARSER_HPP

#include <vector>
#include <string>
#include <iostream>
#include <sstream>
#include <fstream>
#include <cstring>
#include <algorithm>

#include "hecate/time.hpp"

using namespace std;

namespace hecate {
  
  struct tcc {
    double start; // milli-seconds
    double end;   // milli-seconds
    string text;
  };
  
  inline double time_str2num( const string str_time )
  {
    int hh,mm,ss,ms;
    
    hh = stoi( str_time.substr(0,2) );
    mm = stoi( str_time.substr(3,2) );
    ss = stoi( str_time.substr(6,2) );
    ms = stoi( str_time.substr(9,3) );
    
    return 60*60*hh + 60*mm + ss + (double)ms/1000.0;
  }
  
  
  inline string truncate_caption( const string src, const int maxlen )
  {
    string dst = src;
    while( (int)dst.length()>maxlen )
    {
      size_t pos = dst.find_last_of(" ");
      dst = dst.substr(0,pos);
    }
    return dst;
  }
  
  inline string clean_caption( const string src )
  {
    string dst = src;
    size_t pos, pos2;
    
    // Remove special characters
    char chars[] = ".,;:@#$%^&*\"><_+=~`/";
    for(unsigned i=0; i<strlen(chars); i++)
      dst.erase( remove(dst.begin(), dst.end(), chars[i]), dst.end() );
    
    // Remove leading & trailing spaces
    dst.erase(dst.begin(), find_if(dst.begin(), dst.end(), bind1st(not_equal_to<char>(), ' ')));
    dst.erase(find_if(dst.rbegin(), dst.rend(), bind1st(not_equal_to<char>(), ' ')).base(), dst.end());
    
    // Remove leadning words
    vector<string> lwords = {"And ","But ","Or ","and ","Then ","then "};
    for(size_t i=0; i<lwords.size(); i++)
    {
      pos = dst.find(lwords[i]);
      if( pos==0 ) {
        //printf("<<[%s>> [%s] -> [%s]\n", lwords[i].c_str(), dst.c_str(), dst.substr(lwords[i].length(),string::npos).c_str());
        dst = dst.substr(lwords[i].length(),string::npos);
      }
    }
    
    // Remove trailing words
    dst = dst + " ";
    vector<string> words = {" and "," or "," but "," however "," to "," of "," so ",
      " because "," who "," when "," where "," what "," how ", " why ",
      " while "," which "," with "," the "};
    for(size_t i=0; i<words.size(); i++)
    {
      pos = dst.substr(0,dst.find_last_of(" ")).find_last_of(" ");
      if( pos==string::npos )
        break;
      pos2 = dst.substr(pos,string::npos).find(words[i]);
      if( pos2!=string::npos ) {
        //printf("<<%s]>> [%s] -> [%s]\n", words[i].c_str(), dst.c_str(), dst.substr(0,pos).c_str());
        dst = dst.substr(0,pos) + " ";
      }
    }
    
    // Remove annotation inside a bracket, e.g., [UNKNOWN], [LAUGH], [MUSIC], etc.
    pos = dst.find("[");
    while( pos!=string::npos )
    {
      pos2 = dst.find("]");
      dst = dst.substr(0,pos) + dst.substr(pos2+1,string::npos);
      pos = dst.find("[");
    }
    
    // Remove double ??
    pos = dst.find("??");
    while( pos!=string::npos )
    {
      dst = dst.substr(0,pos) + dst.substr(pos+2,string::npos);
      pos = dst.find("??");
    }
    
    // Remove double space
    pos = dst.find("  ");
    while( pos!=string::npos )
    {
      dst = dst.substr(0,pos) + dst.substr(pos+1,string::npos);
      pos = dst.find("  ");
    }
    
    // Remove leading & trailing spaces
    dst.erase(dst.begin(), find_if(dst.begin(), dst.end(), bind1st(not_equal_to<char>(), ' ')));
    dst.erase(find_if(dst.rbegin(), dst.rend(), bind1st(not_equal_to<char>(), ' ')).base(), dst.end());
    
    
    return dst;
  }
  
  
  
  inline void print_closed_caption( vector<tcc>& cc )
  {
    for(size_t i=0; i<cc.size(); i++ )
      printf("%.2f  -->  %.2f: [%s]\n",cc[i].start,cc[i].end,cc[i].text.c_str());
  }
  
  
  
  inline void parse_vtt( const string filename, vector<tcc>& vtt )
  {
    string line;
    
    ifstream fid;
    fid.open( filename );
    getline( fid, line );
    while( fid )
    {
      size_t pos = line.find(" --> ");
      if( pos!=string::npos )
      {
        tcc cc;
        
        // time
        cc.start = time_str2num( line.substr( 0, pos ) );
        cc.end = time_str2num( line.substr( pos+5, string::npos) );
        
        // text
        getline( fid, line );
        line = clean_caption( line );
        
        pos = line.find("???");
        if( pos==string::npos && line.length()>3 ) {
          cc.text = line;
          vtt.push_back( cc );
        }
      }
      getline( fid, line );
    }
  }
  
  inline void parse_ttml( const string filename, vector<tcc>& ttml )
  {
    size_t pos1, pos2, pos3;
    string line, item;
    
    string p_start = "<p ";
    string p_end   = "</p>";
    
    ifstream fid;
    fid.open( filename );
    getline( fid, line );
    
    // Check the language
    pos1 = line.find("<language>en-US</language>");
    if( pos1==string::npos )
      return;
    
    // Parse TTML
    while( fid )
    {
      pos1 = line.find(p_start);
      while( pos1!=string::npos )
      {
        pos2 = line.find(p_end);
        item = line.substr(pos1, pos2-pos1);
        line = line.substr( pos2+3, string::npos );
        
        pos1 = item.find("begin=");
        pos2 = item.find("end=");
        pos3 = item.find("\">");
        
        tcc cc;
        cc.start = time_str2num( item.substr(pos1+7,12) );
        cc.end   = time_str2num( item.substr(pos2+5,12) );
        cc.text  = clean_caption( item.substr(pos3+2,string::npos) );
        ttml.push_back( cc );
        
        pos1 = line.find(p_start);
      }
      getline( fid, line );
    }
    
    //print_closed_caption( ttml );
  }
  
  //
  inline string encode_vtt( int index, float start_sec, float end_sec,
                           vector<string>& v_msg )
  {
    char buf[512];
    string start_sec_str = hecate::second2string( start_sec, "hh:mm:ss.mss" );
    string end_sec_str = hecate::second2string( end_sec, "hh:mm:ss.mss" );
    sprintf( buf, "%d\n%s --> %s\n", index, start_sec_str.c_str(),
            end_sec_str.c_str());

    for(size_t i=0; i<v_msg.size(); i++) {
      sprintf( buf, "%s- %s\n", buf, v_msg[i].c_str());
    }
    
    string ret = buf;
    return ret;
  }
  
}
#endif
</file>

<file path="include/hecate/image_metrics.hpp">
/*
 * Various image metrics
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_IMAGE_METRICS_HPP
#define HECATE_IMAGE_METRICS_HPP

#include <math.h>
#include <stdio.h>
#include <cmath>
#include <string>
#include <vector>

#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>

#include <hecate/hist_opencv.hpp>

using namespace cv;
using namespace std;

namespace hecate {
  
  
#define VALIDATE(x) ( std::isnan(x) ) ? 0 : x
  
  /*------------------------------------------------------------------------
   Contrast is measured as the standard deviation of the pixel intensities.
   RMS contrast does not depend on the angular frequency content or the
   spatial distribution of contrast in the image
   https://en.wikipedia.org/wiki/Contrast_(vision)#RMS_contrast
   ------------------------------------------------------------------------*/
  inline double calc_rms_contrast( const Mat& gray_img )
  /*-----------------------------------------------------------------------*/
  
  {
    Mat I;
    gray_img.convertTo( I, CV_32FC1 );
    Scalar mu = cv::mean( I );
    I = I - mu[0];
    return VALIDATE(cv::norm(I)/sqrt(I.rows*I.cols));
  }
  
  /*------------------------------------------------------------------------
   Sharpness is measured as the sum of magnitude in frequency domain
   ------------------------------------------------------------------------*/
  inline double calc_sharpness( const Mat& gray_img )
  /*-----------------------------------------------------------------------*/
  {
    Mat img;
    gray_img.convertTo( img, CV_32FC1 );
    img *= 1./255;
    
    Mat dx, dy;
    Sobel( img, dx, img.type(), 1, 0, 3 );
    Sobel( img, dy, img.type(), 0, 1, 3 );
    magnitude( dx, dy, dx );
    
    int npixels = gray_img.rows * gray_img.cols;
    return VALIDATE(cv::sum(dx)[0] / npixels);
  }
  
  
  /*------------------------------------------------------------------------
   Brightness is measured as the relative luminance in colorimetric spaces
   https://en.wikipedia.org/wiki/Relative_luminance
   ------------------------------------------------------------------------*/
  inline double calc_brightness( const Mat& img )
  /*-----------------------------------------------------------------------*/
  {
    vector<Mat> bgr;
    split( img, bgr );
    for(size_t j=0; j<bgr.size(); j++)
      bgr[j].convertTo(bgr[j],CV_32F);
    
    // compute perceived brightness
    Mat img_pb = (0.2126*bgr[2] + 0.7152*bgr[1] + 0.0722*bgr[0])/255.0;
    return VALIDATE(mean( img_pb )[0]);
  }
  
  /*------------------------------------------------------------------------
   Uniformness is measured as the ratio between the 5% percentile pixel
   intensity histograms and the rest.
   ------------------------------------------------------------------------*/
  inline double calc_uniformity( const Mat& gray_img, int nbins=128 )
  /*-----------------------------------------------------------------------*/
  {
    double val = 0.0;
    
    Mat ghist;
    hecate::calc_gray_hist( gray_img, ghist, nbins );
    if( cv::sum(ghist)[0] == 0 ) {
      val = 1.0;
    }
    else {
      Mat hist_sorted;
      cv::sort( ghist, hist_sorted, CV_SORT_EVERY_COLUMN|CV_SORT_DESCENDING );
      hist_sorted /= cv::sum( hist_sorted )[0];
      for(int j=0; j<(int)(0.05*nbins); j++)
        val += (double) hist_sorted.at<float>(j);
    }
    return VALIDATE(val);
  }
  
  /*------------------------------------------------------------------------
   Symmetry is measured as the difference between edge orientation & magnitude
   histograms of the left and right halves.
   ------------------------------------------------------------------------*/
  inline double calc_asymmetry( const Mat& gray_img )
  /*-----------------------------------------------------------------------*/
  {
    Mat img_l( gray_img, Rect(0,0,gray_img.cols/2,gray_img.rows) );
    Mat img_r( gray_img, Rect(gray_img.cols/2,0,gray_img.cols/2,gray_img.rows) );
    
    Mat hist_l, hist_r;
    hecate::calc_edge_hist( img_l, hist_l );
    hecate::calc_edge_hist( img_r, hist_r );
    
    return VALIDATE((double)cv::norm( hist_l-hist_r ));
  }
  
  /*------------------------------------------------------------------------
   Third Saliency is measured as the residual saliency on the resized image,
   then collects the average saliency for each sub-window. It's an indicator
   of the informativeness of each window, but also of the general distribution
   of the content in the image.
   ------------------------------------------------------------------------*/
  inline vector<double> calc_third_saliency( const Mat& gray_img )
  {
    const int w = 3; // divide 128-by-128 image into 3-by-3 patches
    
    // 0-1 normalize & resize to 128-by-128
    Mat img;
    gray_img.convertTo( img, CV_32FC1 ); img *= 1./255;
    cv::resize( img, img, cv::Size(128,128), 0, 0, cv::INTER_AREA );
    
    //real is img image, im is zero
    Mat planes[]  = {Mat_<double>(img),               Mat::zeros(img.size(),CV_32FC1)};
    Mat planes2[] = {Mat::zeros(img.size(),CV_32FC1), Mat::zeros(img.size(),CV_32FC1)};
    Mat planesr[] = {Mat::zeros(img.size(),CV_32FC1), Mat::zeros(img.size(),CV_32FC1)};
    
    Mat complexI, magI, phasem;
    merge( planes, 2, complexI ); // Merges for FT
    dft( complexI, complexI );    //Forward DFT
    split( complexI, planes );    // planes[0] = Re(DFT(I), planes[1] = Im(DFT(I))
    magnitude( planes[0], planes[1], magI );    //DFT magnitude (amplitude)
    phase( planes[0], planes[1], phasem );      //DFT phase
    
    //log spectral amplitude
    cv::log( magI, magI );
    
    Mat smooth, kernel;
    smooth = Mat::zeros( img.size(), CV_32FC1 );
    kernel = Mat::zeros( Size(10,10), CV_32FC1 );
    kernel += Scalar::all( 0.01 ); //kernel for average filtering ( 0.01=1/(10*10) )
    
    //smoothed spectrum with average filtering
    cv::filter2D( magI, smooth, CV_32FC1, kernel, Point(-1,-1), 0, BORDER_REPLICATE );
    
    Mat diff;
    cv::subtract( magI, smooth, diff ); //spectral residual (log domain)
    cv::exp( diff, diff );              //spectral residual (real domain)
    
    //recover real and im part of the DFT after the residual
    polarToCart( diff, phasem, planes2[0], planes2[1] );
    
    //invert the DFT (we are back in the pixel domain! We have just created a Saliency Component)
    Mat result;
    merge( planes2, 2, complexI );
    dft( complexI, result, DFT_INVERSE+DFT_SCALE );
    split( result, planesr );                       // planes[0] = Re(DFT(I), planes[1] = Im(DFT(I))
    magnitude( planesr[0], planesr[1], result );	// sqrt(Re(DFT(I))^2 + Im(DFT(I))^2)
    
    normalize( result, result, 0, 2, cv::NORM_MINMAX );
    
    //compute the window dimensions
    float cx = result.cols/w;
    float cy = result.rows/w;
    vector<double> features;
    
    //local mean for each window
    for( int a=0; a<w; ++a ) {
      for( int b=0; b<w; ++b ) {
        Mat temp = result(Rect(cx*a, cy*b, cx, cy));
        double val = mean( temp )[0];
        features.push_back( VALIDATE(val) );
      }
    }
    
    return features;
  }
  /*-----------------------------------------------------------------------*/
  
  /*------------------------------------------------------------------------
   Entropy is measured -sum(p.*log2(p)), which is a statistical measure of
   randomness that can be used to characterize the texture of the imput image.
   http://www.mathworks.com/help/images/ref/entropy.html?refresh=true
   ------------------------------------------------------------------------*/
  inline double calc_entropy( const Mat& gray_img, int nbins=256 )
  /*-----------------------------------------------------------------------*/
  {
    double val=0.0;
    
    Mat ghist;
    hecate::calc_gray_hist( gray_img, ghist, nbins );
    for(int i=0; i<nbins; i++) {
      if( ghist.at<float>(i)!=0 )
        val -= ghist.at<float>(i) * log2(ghist.at<float>(i));
    }
    return VALIDATE(val);
  }
  
  
  /*------------------------------------------------------------------------
   Contrast balance is measured as the l2 distance between an original
   image and contrast-equalized image.
   ------------------------------------------------------------------------*/
  inline double calc_contrast_balance( const Mat& img )
  /*-----------------------------------------------------------------------*/
  {
    double res = 0;
    
    vector<Mat> hsv_planes;
    split( img, hsv_planes );
    
    //for each channel
    for (int pl=0; pl < 3; ++pl)
    {
      //equalize the histogram
      Mat img_hist_equalized;
      equalizeHist( hsv_planes[pl], img_hist_equalized );
      
      //compute the diff between original and equalized histograms
      res += cv::norm( hsv_planes[pl], img_hist_equalized ) /
      (double)(img.rows*img.cols);
    }
    
    //the larger the difference, the larger the contrast error. so we negate
    return VALIDATE(-res);
  }
  
  
  /*------------------------------------------------------------------------
   Exposure balance is measured as an absolute value of the skewness
   of the luminance histogram.
   ------------------------------------------------------------------------*/
  inline double calc_exposure_balance( const Mat& img )
  /*-----------------------------------------------------------------------*/
  {
    vector<Mat> hsv_planes;
    split( img, hsv_planes );
    
    /// Establish the number of bins
    const int histSize = 256;
    
    /// Set the ranges (for B,G,R)
    float range[] = { 0, 256 };
    const float *histRange = { range };
    
    cv::Mat hist;
    double res = 0;
    for (int pl=0; pl < 3; ++pl)
    {
      /// Compute the histograms:
      cv::calcHist( &hsv_planes[pl], 1, 0, cv::Mat(), hist, 1, &histSize, &histRange,
                   /*uniform: */true, /*accumulate: */false );
      cv::Scalar sump = cv::sum( hist );
      
      double mean = (double) sump[0] / hist.rows;
      
      cv::Mat prod;
      cv::multiply( (hist-mean), (hist-mean), prod);
      cv::Scalar sums = cv::sum( prod );
      
      cv::multiply( prod, (hist-mean), prod);
      cv::Scalar sumskew = cv::sum( prod );
      
      double result[2];
      result[0] = sqrt( (double) sums[0] / hist.rows );
      result[1] = (double) sumskew[0] / (hist.rows * result[0]*result[0]*result[0]);
      
      //absolute value of the skewness gives an idea of how much
      //the histogram of colors is incorrect
      res += std::abs( result[1] );
    }
    
    // the larger the skew, the larger the exposure error
    return VALIDATE(-res / 3);
  }
  
  /*------------------------------------------------------------------------
   JPEG quality is measured using the no-reference quality estimation of
   Z. Wang, H. R. Sheikh, and A. C. Bovik. No-reference perceptual quality
   assessment of jpeg compressed images. In ICIP, 2002.
   ------------------------------------------------------------------------*/
  inline double calc_jpeg_quality( const Mat& gray_img )
  /*-----------------------------------------------------------------------*/
  {
    // Convert to grayscale image with 64bit doubles
    cv::Mat img;
    gray_img.convertTo( img, CV_32FC1 );
    
    const int m = img.rows;
    const int n = img.cols;
    
    if (m<16 || n<16)
    {
      return -2.0;
    }
    
    // feature extraction: horizontal features
    Mat dh, dh1, dh2;
    dh1 = img( Rect(1, 0, n-1, m) );
    dh2 = img( Rect(0, 0, n-1, m) );
    dh = dh1 - dh2;
    
    double sum = 0;
    int count = 0;
    double sumz = 0;
    for (int i=0; i < m; ++i) {
      for (int j=0; j < n-2; ++j) {
        if ((j+1)%8==0 && j>0 && (j+1)<8*floor(n/8))
        {
          sum += std::abs( dh.at<double>(i,j) );
          count++;
        }
        double signval = copysign( 1.0, dh.at<double>(i,j) ) *
        copysign( 1.0, dh.at<double>(i,j+1) );
        if (signval < 0)
          sumz += 1;
      }
    }
    
    double bh = sum / count;
    double ah = (8.0 * mean( cv::abs(dh) )[0] - bh) / 7;
    double zh = sumz / (m * (n-2));
    
    // feature extraction: vertical features
    Mat dv1, dv2, dv;
    dv1 = img( Rect(0, 1, n, m-1) );
    dv2 = img( Rect(0, 0, n, m-1) );
    dv = dv1 - dv2;
    
    sum = 0;
    count = 0;
    sumz = 0;
    for (int i=0; i < m-2; ++i) {
      for (int j=0; j < n; ++j) {
        if ((i+1)%8==0 && i>0 && (i+1)<8*floor(m/8))
        {
          sum += std::abs( dv.at<double>(i,j) );
          count++;
        }
        double signval = copysign( 1.0, dv.at<double>(i,j) ) *
        copysign( 1.0, dv.at<double>(i,j+1) );
        if (signval < 0)
          sumz += 1;
      }
    }
    
    double bv = sum / count;
    double av = (8.0 * mean( cv::abs(dv) )[0] - bv) / 7;
    double zv = sumz / (n * (m-2));
    
    //combined features
    double B = (bh + bv) / 2;
    double A = (ah + av) / 2;
    double Z = (zh + zv) / 2;
    
    // Quality Prediction
    const double alpha = -245.8909;
    const double beta = 261.9373;
    const double gamma1 = -239.8886;
    const double gamma2 = 160.1664;
    const double gamma3 = 64.2859;
    
    double score = alpha + beta *
    std::pow( B, (gamma1/10000) ) *
    std::pow( A, (gamma2/10000) ) *
    std::pow( Z, (gamma3/10000) );
    
    return VALIDATE(score);
  }
  
}
#endif
</file>

<file path="include/hecate/knapsack.hpp">
/*
 * 0/1 Knapsack solver
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_KNAPSACK_HPP
#define HECATE_KNAPSACK_HPP

#include <stdio.h>

namespace hecate {
  
  template <typename T>
  inline T Tmax(T a, T b) {return (a>b) ? a : b; };
  
  template <typename T>
  inline void solve_01knapsack( const vector<T>& value, const vector<int>& weight,
                               const int budget, vector<bool>& solution)
  {
    int n = (int)value.size();
    solution.resize(n, false);
    
    // recursion
    vector<vector<T> > V( n+1, vector<T>(budget+1,0) );
    for( int i=1; i<=n; i++ )
      for( int w=1; w<=budget; w++ )
        V[i][w] = ( weight[i-1]>w )
        ? V[i-1][w] : Tmax( V[i-1][w], V[i-1][w-weight[i-1]] + value[i-1] );
    
    // backtrack
    int w = budget;
    for( int i=n; i>0; i-- ) {
      if( V[i][w]!=V[i-1][w] && V[i][w]==V[i-1][w-weight[i-1]]+value[i-1] ) {
        solution[i-1] = true;
        w -= weight[i-1];
      }
    }
  }
  
}
#endif
</file>

<file path="include/hecate/shot_range.hpp">
/*
 * Shot range definition
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_SHOT_RANGE_HPP
#define HECATE_SHOT_RANGE_HPP

#include <string>
#include <vector>

#include <hecate/sort.hpp>

namespace hecate {
  
  /*
   */
  class Range {
  public:
    int start;
    int end;
    vector<int> v_idx; // store indices (keyframe index)
    
  public:
    Range(int s, int e): start(s), end(e) {};
    
    inline int length() const { return end-start+1; };
    
    inline void print() const {
      printf("range(%d:%d) (%d) [", start, end, length() );
      for(size_t i=0; i<v_idx.size(); i++) {
        printf("%d", v_idx[i]);
        if( i+1<v_idx.size() )
          printf(",");
      }
      printf("]\n");
    };
  };
  
  /*
   */
  class ShotRange: public Range {
  public:
    vector<Range> v_range;
    
  public:
    ShotRange(int s, int e): Range(s,e) {};
    
    inline void print() const {
      printf("shot_range(%d:%d) (%d) [", start, end, length() );
      for(size_t i=0; i<v_idx.size(); i++) {
        printf("%d", v_idx[i]);
        if( i+1<v_idx.size() )
          printf(",");
      }
      printf("]\n");
      
      for(size_t i=0; i<v_range.size(); i++) {
        printf("  sub_");
        v_range[i].print();
      }
    };
  };
  
  /*
   */
  class Tag {
  public:
    string label;
    double score;
    
  public:
    Tag(string& l, double s): label(l), score(s) {};
    
    inline void print() const {
      printf("(%s,%f)", label.c_str(), score);
    }
  };
  
  /*
   */
  class RangeTag: public Range {
  public:
    vector<Tag> v_tag;
  
  public:
    RangeTag(int s, int e): Range(s,e) {};
    RangeTag(Range r): Range(r.start,r.end) {
      v_idx=r.v_idx;
    };
    
    inline void print() const {
      printf("range(%d:%d) (%d) [", start, end, length() );
      for(size_t i=0; i<v_idx.size(); i++) {
        printf("%d", v_idx[i]);
        if( i+1<v_idx.size() )
          printf(",");
      }
      printf("], tags: ");
      for(size_t i=0; i<v_tag.size(); i++)
        v_tag[i].print();
      printf("\n");
    };
    
    inline void sort() {
      vector<double> v_scores;
      for(size_t i=0; i<v_tag.size(); i++)
        v_scores.push_back( v_tag[i].score );
      vector<double> v_srtval;
      vector<size_t> v_srtidx;
      hecate::sort( v_scores, v_srtval, v_srtidx );
      vector<Tag> v_tag_new;
      for(size_t i=0; i<v_srtidx.size(); i++)
        v_tag_new.push_back( v_tag[v_srtidx[v_srtidx.size()-1-i]] );
      v_tag = v_tag_new;
    }
  };
  
  /*
   */
  class ShotRangeTag: public Range {
  public:
    vector<RangeTag> v_range_tag;
    
  public:
    ShotRangeTag(int s, int e): Range(s,e) {};
    ShotRangeTag(ShotRange& sr): Range(sr.start,sr.end) {
      v_idx = sr.v_idx;
      for(size_t i=0; i<sr.v_range.size(); i++) {
        RangeTag rt( sr.v_range[i] );
        v_range_tag.push_back( rt );
      }
    };
    
    inline void print() {
      printf("shot_range_tag(%d:%d) (%d) [", start, end, length() );
      for(size_t i=0; i<v_idx.size(); i++) {
        printf("%d", v_idx[i]);
        if( i+1<v_idx.size() )
          printf(",");
      }
      printf("]\n");
      
      for(size_t i=0; i<v_range_tag.size(); i++) {
        printf("  sub_");
        v_range_tag[i].print();
      }
    };
    
    inline void sort() {
      for(size_t i=0; i<v_range_tag.size(); i++)
        v_range_tag[i].sort();
    };
  };
  
}
#endif
</file>

<file path="include/hecate/sort.hpp">
/*
 * MATLAB-like sort
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_SORT_HPP
#define HECATE_SORT_HPP

#include <vector>
#include <algorithm>

namespace hecate {
  
  // Act like matlab's [Y,I] = SORT(X)
  // Input:
  //   unsorted  unsorted vector
  // Output:
  //   sorted     sorted vector, allowed to be same as unsorted
  //   index_map  an index map such that sorted[i] = unsorted[index_map[i]]
  template <class T>
  void sort(
            std::vector<T> &unsorted,
            std::vector<T> &sorted,
            std::vector<size_t> &index_map);
  
  // Act like matlab's Y = X[I]
  // where I contains a vector of indices so that after,
  // Y[j] = X[I[j]] for index j
  // this implies that Y.size() == I.size()
  // X and Y are allowed to be the same reference
  template< class T >
  void reorder(
               std::vector<T> & unordered,
               std::vector<size_t> const & index_map,
               std::vector<T> & ordered);
  
  ////////////////////////////////////////////////////////////////////////////////
  // Implementation
  ////////////////////////////////////////////////////////////////////////////////
  
  
  // Comparison struct used by sort
  template<class T> struct index_cmp
  {
    index_cmp(const T arr) : arr(arr) {}
    bool operator()(const size_t a, const size_t b) const
    {
      return arr[a] < arr[b];
    }
    const T arr;
  };
  
  template <class T>
  inline void sort(
            std::vector<T> & unsorted,
            std::vector<T> & sorted,
            std::vector<size_t> & index_map)
  {
    // Original unsorted index map
    index_map.resize(unsorted.size());
    for(size_t i=0;i<unsorted.size();i++)
    {
      index_map[i] = i;
    }
    // Sort the index map, using unsorted for comparison
    sort(
         index_map.begin(),
         index_map.end(),
         index_cmp<std::vector<T>& >(unsorted));
    
    sorted.resize(unsorted.size());
    reorder(unsorted,index_map,sorted);
  }
  
  // This implementation is O(n), but also uses O(n) extra memory
  template< class T >
  inline void reorder(
               std::vector<T> & unordered,
               std::vector<size_t> const & index_map,
               std::vector<T> & ordered)
  {
    // copy for the reorder according to index_map, because unsorted may also be
    // sorted
    std::vector<T> copy = unordered;
    ordered.resize(index_map.size());
    for(unsigned int i = 0; i<index_map.size();i++)
    {
      ordered[i] = copy[index_map[i]];
    }
  }
  
}
#endif
</file>

<file path="include/hecate/time.hpp">
/*
 * Time util
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_TIME_HPP
#define HECATE_TIME_HPP

#include <stdio.h>

#include <ctime>      // display date and time
#include <cmath>      // floor
#include <chrono>
#include <string>

namespace hecate {
  
  typedef std::chrono::high_resolution_clock Clock;
  typedef std::chrono::milliseconds milliseconds;
  
  inline double elapsed_time_ms( Clock::time_point from)
  {
    Clock::time_point now = Clock::now();
    milliseconds ms = std::chrono::duration_cast<milliseconds>( now - from );
    return (double)ms.count();
  }
  
  inline double print_elapsed_time( Clock::time_point from, const char* prefix)
  {
    int msec = (int) elapsed_time_ms(from);
    int sec = msec/1000;
    printf("%s: Elapsed time %02d:%02d:%04d\n", prefix, sec/60, sec%60, msec%1000);
    
    return msec / 1000.0;
  }
  
  inline std::string second2string(double sec, const std::string& format) {
    char buf[128];
    int hh, mm, ss, mss;
    hh  = (int) floor( sec/3600 );
    mm  = (int) floor( sec/60 ) % 60;
    ss  = (int) sec % 60;
    mss = (int) 10000*(sec - floor(sec));
    if( format == "hh:mm:ss.mss" ) {
      sprintf( buf, "%02d:%02d:%02d.%04d", hh,mm,ss,mss );
    }
    else if( format == "mm:ss.mss" ) {
      sprintf( buf, "%02d:%02d.%04d", 60*hh+mm,ss,mss );
    }
    std::string ret = buf;
    return ret;
  }
}
#endif
</file>

<file path="src/tools/hecate.cpp">
/*
 * HECATE Yahoo Video Processing Library - Binary
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#include "hecate/hecate.hpp"

using namespace std;
using namespace cv;

int main( int argc, char** argv )
{
  hecate_copyright();
  if( argc<3 )
    hecate_usage();
  
  // Read input params
  hecate_params opt;
  hecate_parse_params( argc, argv, opt );
  
  // Run VIDSUM
  vector<int> v_thumb_idx;
  vector<hecate::Range> v_gif_range;
  vector<hecate::Range> v_mov_range;
  run_hecate( opt, v_thumb_idx, v_gif_range, v_mov_range );
  
  // Print debugging info
  if( opt.debug ) {
    if( opt.jpg ) {
      printf("hecate: thumbnail indices: [ ");
      for(size_t i=0; i<v_thumb_idx.size(); i++)
        printf("%d ", v_thumb_idx[i]);
      printf("]\n");
    }
    if( opt.gif ) {
      printf("hecate: gif shot ranges:\n");
      for(int i=0; i<v_gif_range.size(); i++)
        v_gif_range[i].print();
    }
    if( opt.mov ) {
      printf("hecate: mov shot ranges:\n");
      for(int i=0; i<v_mov_range.size(); i++)
        v_mov_range[i].print();
    }
  }
  
  // Produce results
  if( opt.jpg ) {
    generate_thumbnails( opt, v_thumb_idx );
  }
  
  if( opt.gif ) {
    bool mov = opt.mov;
    opt.mov = false;
    generate_highlight_clips( opt, v_gif_range );
    opt.mov = mov;
  }
  
  if( opt.mov ) {
    bool gif = opt.gif;
    opt.gif = false;
    generate_highlight_clips( opt, v_mov_range );
    opt.gif = gif;
  }
}
</file>

<file path="LICENSE">
Apache License
Version 2.0, January 2004

http://www.apache.org/licenses/

TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

1. Definitions.
"License" shall mean the terms and conditions for use, reproduction, and distribution as defined by 
Sections 1 through 9 of this document.

"Licensor" shall mean the copyright owner or entity authorized by the copyright owner that is granting 
the License.

"Legal Entity" shall mean the union of the acting entity and all other entities that control, are 
controlled by, or are under common control with that entity. For the purposes of this definition, 
"control" means (i) the power, direct or indirect, to cause the direction or management of such entity, 
whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding 
shares, or (iii) beneficial ownership of such entity.

"You" (or "Your") shall mean an individual or Legal Entity exercising permissions granted by this License.

"Source" form shall mean the preferred form for making modifications, including but not limited to software 
source code, documentation source, and configuration files.

"Object" form shall mean any form resulting from mechanical transformation or translation of a Source form, 
including but not limited to compiled object code, generated documentation, and conversions to other media types.

"Work" shall mean the work of authorship, whether in Source or Object form, made available under the License, 
as indicated by a copyright notice that is included in or attached to the work (an example is provided in 
the Appendix below).

"Derivative Works" shall mean any work, whether in Source or Object form, that is based on (or derived from) 
the Work and for which the editorial revisions, annotations, elaborations, or other modifications represent, 
as a whole, an original work of authorship. For the purposes of this License, Derivative Works shall not 
include works that remain separable from, or merely link (or bind by name) to the interfaces of, the Work 
and Derivative Works thereof.

"Contribution" shall mean any work of authorship, including the original version of the Work and any 
modifications or additions to that Work or Derivative Works thereof, that is intentionally submitted to 
Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to 
submit on behalf of the copyright owner. For the purposes of this definition, "submitted" means any form of 
electronic, verbal, or written communication sent to the Licensor or its representatives, including but not 
limited to communication on electronic mailing lists, source code control systems, and issue tracking systems 
that are managed by, or on behalf of, the Licensor for the purpose of discussing and improving the Work, but 
excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner 
as "Not a Contribution."

"Contributor" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been 
received by Licensor and subsequently incorporated within the Work.

2. Grant of Copyright License. Subject to the terms and conditions of this License, each Contributor hereby 
grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license 
to reproduce, prepare Derivative Works of, publicly display, publicly perform, sublicense, and distribute 
the Work and such Derivative Works in Source or Object form.

3. Grant of Patent License. Subject to the terms and conditions of this License, each Contributor hereby 
grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable (except as stated 
in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer 
the Work, where such license applies only to those patent claims licensable by such Contributor that are 
necessarily infringed by their Contribution(s) alone or by combination of their Contribution(s) with the Work 
to which such Contribution(s) was submitted. If You institute patent litigation against any entity (including 
a cross-claim or counterclaim in a lawsuit) alleging that the Work or a Contribution incorporated within the 
Work constitutes direct or contributory patent infringement, then any patent licenses granted to You under 
this License for that Work shall terminate as of the date such litigation is filed.

4. Redistribution. You may reproduce and distribute copies of the Work or Derivative Works thereof in any 
medium, with or without modifications, and in Source or Object form, provided that You meet the following 
conditions:

You must give any other recipients of the Work or Derivative Works a copy of this License; and
You must cause any modified files to carry prominent notices stating that You changed the files; and
You must retain, in the Source form of any Derivative Works that You distribute, all copyright, patent, 
trademark, and attribution notices from the Source form of the Work, excluding those notices that do not 
pertain to any part of the Derivative Works; and
If the Work includes a "NOTICE" text file as part of its distribution, then any Derivative Works that You 
distribute must include a readable copy of the attribution notices contained within such NOTICE file, 
excluding those notices that do not pertain to any part of the Derivative Works, in at least one of the 
following places: within a NOTICE text file distributed as part of the Derivative Works; within the Source 
form or documentation, if provided along with the Derivative Works; or, within a display generated by the 
Derivative Works, if and wherever such third-party notices normally appear. The contents of the NOTICE file 
are for informational purposes only and do not modify the License. You may add Your own attribution notices 
within Derivative Works that You distribute, alongside or as an addendum to the NOTICE text from the Work, 
provided that such additional attribution notices cannot be construed as modifying the License. 

You may add Your own copyright statement to Your modifications and may provide additional or different 
license terms and conditions for use, reproduction, or distribution of Your modifications, or for any such 
Derivative Works as a whole, provided Your use, reproduction, and distribution of the Work otherwise 
complies with the conditions stated in this License.

5. Submission of Contributions. Unless You explicitly state otherwise, any Contribution intentionally 
submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this 
License, without any additional terms or conditions. Notwithstanding the above, nothing herein shall 
supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding 
such Contributions.

6. Trademarks. This License does not grant permission to use the trade names, trademarks, service marks, or 
product names of the Licensor, except as required for reasonable and customary use in describing the origin 
of the Work and reproducing the content of the NOTICE file.

7. Disclaimer of Warranty. Unless required by applicable law or agreed to in writing, Licensor provides the 
Work (and each Contributor provides its Contributions) on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS 
OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, 
NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are solely responsible for 
determining the appropriateness of using or redistributing the Work and assume any risks associated with Your 
exercise of permissions under this License.

8. Limitation of Liability. In no event and under no legal theory, whether in tort (including negligence), 
contract, or otherwise, unless required by applicable law (such as deliberate and grossly negligent acts) 
or agreed to in writing, shall any Contributor be liable to You for damages, including any direct, indirect, 
special, incidental, or consequential damages of any character arising as a result of this License or out 
of the use or inability to use the Work (including but not limited to damages for loss of goodwill, work 
stoppage, computer failure or malfunction, or any and all other commercial damages or losses), even if such 
Contributor has been advised of the possibility of such damages.

9. Accepting Warranty or Additional Liability. While redistributing the Work or Derivative Works thereof, 
You may choose to offer, and charge a fee for, acceptance of support, warranty, indemnity, or other 
liability obligations and/or rights consistent with this License. However, in accepting such obligations, 
You may act only on Your own behalf and on Your sole responsibility, not on behalf of any other Contributor, 
and only if You agree to indemnify, defend, and hold each Contributor harmless for any liability incurred 
by, or claims asserted against, such Contributor by reason of your accepting any such warranty or additional 
liability.

END OF TERMS AND CONDITIONS
</file>

<file path="include/hecate/ffmpeg_helper.hpp">
/*
 * Various helper functions using ffmpeg
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */


#ifndef HECATE_FFMPEG_HPP
#define HECATE_FFMPEG_HPP

#include <stdio.h>
#include <string.h>

#include <iostream>
#include <fstream>
#include <string>
#include <vector>

#include "hecate/file_helper.hpp"

#define BUF_S 256
#define BUF_M 512
#define BUF_L 1024

using namespace std;

namespace hecate {
  const string _ffmpeg = hecate::which("ffmpeg");
  const string _ffmarg = "-loglevel quiet -y";
  const int _lfade = 8; // fade-in/out duration (unit: frame)
  
  // Crop video segment & resize
  static inline void ffmpeg_video_crop(string in_file,
                                       string out_file,
                                       string start_time,
                                       string duration,
                                       int out_width_px)
  {
    in_file = escape_space(in_file);
    
    char filter[BUF_S];
    sprintf( filter, "'scale=%d:trunc(ow/a/2)*2'", out_width_px);
    
    char cmd[BUF_L];
    sprintf( cmd, "%s -ss %s -t %s -i %s -strict -2 -vf %s %s %s",
            _ffmpeg.c_str(), start_time.c_str(), duration.c_str(),
            in_file.c_str(), filter, out_file.c_str(), _ffmarg.c_str());
    
    system( cmd );
  };
  
  static inline void ffmpeg_video_concat(string in_filelist,
                                         string out_file)
  {
    char cmd[BUF_L];
    sprintf( cmd, "%s -f concat -i %s -c copy %s %s",
            _ffmpeg.c_str(), in_filelist.c_str(), out_file.c_str(),
            _ffmarg.c_str() );
    system( cmd );
  };
  
  // Audio fade in/out
  static inline void ffmpeg_audio_fade(string in_file,
                                       string out_file,
                                       double video_duration_sec,
                                       double video_fps)
  {
    in_file = escape_space(in_file);
    
    const double afade_sec = (double)2*_lfade/video_fps;
    const double afade_msec = (int)10000*(afade_sec-floor(afade_sec));
    
    double afos  = video_duration_sec - afade_sec; // audio fade-out start
    int afos_ss  = (int) afos; // NOTE: we don't compute modulo this time
    int afos_mss = (int) 10000*(afos - floor(afos));
    
    char filter[BUF_S];
    sprintf( filter, "'afade=t=in:ss=0:d=0.%04d,"
                      "afade=t=out:st=%d.%04d:d=0.%04d'",
            (int)afade_msec, afos_ss, afos_mss, (int)afade_msec);

    char cmd[BUF_L];
    sprintf( cmd, "%s -i %s -af %s %s %s", _ffmpeg.c_str(),
            in_file.c_str(), filter, out_file.c_str(), _ffmarg.c_str() );
    system( cmd );

  };
  
  // Video fade in/out
  static inline void ffmpeg_video_fade(string in_file,
                                       string out_file,
                                       int video_duration,
                                       bool out_only=false)
  {
    in_file = escape_space(in_file);
    
    char filter[BUF_S];
    if( out_only ) {
      sprintf( filter, "'fade=out:%d:%d'",
              video_duration-_lfade, _lfade);
    }
    else {
      sprintf( filter, "'fade=in:0:%d,fade=out:%d:%d'",
              _lfade, video_duration-_lfade, _lfade);
    }
    
    char cmd[BUF_L];
    sprintf( cmd, "%s -i %s -vf %s %s %s", _ffmpeg.c_str(),
            in_file.c_str(), filter, out_file.c_str(), _ffmarg.c_str());
    system( cmd );
  };
  
  
  // Based on http://blog.pkh.me/p/21-high-quality-gif-with-ffmpeg.html
  static inline void ffmpeg_video2gif(string in_file,
                                      string out_file,
                                      string start_time,
                                      string duration,
                                      int out_fps,
                                      int out_width_px)
  {
    in_file = escape_space(in_file);
    
    string out_dir = hecate::get_dir( std::string(out_file) );
    
    char filter[BUF_S];
    sprintf( filter, "fps=%d,scale=%d:-1:flags=lanczos", out_fps, out_width_px );
    
    char palette[BUF_M];
    sprintf( palette, "%s/palatte.png", out_dir.c_str() );
    
    char time_setup[BUF_S] = "";
    if( !start_time.empty() && !duration.empty() ) {
      sprintf( time_setup, "-ss %s -t %s",
              start_time.c_str(), duration.c_str() );
    }

    char cmd[BUF_L];
    
    // Create a palatte
    sprintf( cmd, "%s %s -i %s -vf '%s,palettegen=stats_mode=diff' %s %s",
            _ffmpeg.c_str(), time_setup,  in_file.c_str(), filter,
            _ffmarg.c_str(), palette );
    system( cmd );
    
    // Convert segment to gif
    sprintf( cmd, "%s %s -i %s -i %s -lavfi '%s [x]; [x][1:v] paletteuse' %s %s",
            _ffmpeg.c_str(), time_setup, in_file.c_str(), palette, filter,
            _ffmarg.c_str(), out_file.c_str());
    system( cmd );
    
    // Delete palette
    sprintf( cmd, "rm %s", palette );
    system( cmd );
  };
  
  
  
}
#endif
</file>

<file path="include/hecate/gflseg.hpp">
/*
 * GFLSEG Group Fused LASSO Change Point Detection solver
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 *
 * Implementation is based on:
 *   Kevin Bleakley and Jean-Philippe Vert.
 *     "The group fused lasso for multiple change-point detection."
 *   arXiv preprint arXiv:1106.4199 (2011).
 */


#ifndef HECATE_GFLSEG_HPP
#define HECATE_GFLSEG_HPP

#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>

#if CV_MAJOR_VERSION > 2
#include <opencv2/core/core_c.h>
#endif

#include "hecate/sort.hpp"

using namespace std;
using namespace cv;

namespace hecate {
  
  class Segmenter {
  public:
    /*
     Automatic multiple change-point detection
     
     This function is a wrapper for multi-dimensional signal segmentation into at
     least k change-points by the LARS (function gflars), followed by change-point
     selection with a dynamic programming optimization (function dpseg).
     
     INPUT
     X      : n-by-p matrix to be segmented (n: # obs, p: # dim).
     k      : the number of change points to find in the first segmentation step
     theta  : stopping criteria, see dpseg. (default=0.1)
     forcek : k is set as the hard maximum number of change points
     
     OUTPUT
     jumps  : vector of change-points
     val    : matrix of the value on each interval
     updown : the up/down statistics on each interval
     */
    void gflseg(const Mat& X, vector<int>& jumps, int k, double theta=0.1);
    
    
    
    /*
     Segmentation of a multi-dimensional signal with dynamic programming
     http://pbil.univ-lyon1.fr/members/fpicard/franckpicard_fichiers/pdf/aCGH-stat.pdf
     Improvement is made by penalizing with the optimal segment length,
     lambda=sqrt(lstar-l) where lstar = n/k (typically chosen as 2-second long)
     
     INPUT
     X     : n-by-p matrix to be segmented (n: # obs, p: # dim).
     cp    : candidate change points (default: [0:n-2])
     kmax  : maximum number of change-points to test (default: length(cp))
     theta : stopping criteria. Typically chonse to be in the interval (0 0.5].
     The smaller the threshold, the higher the tendency to keep more
     breakpoints. The criteria is based on the method found in
     'Picard et al (2005)' "A statistical approach for array CGH data
     analysis" (BMC Bioinformatics). (default=0.5)
     
     OUTPUT
     jump  : j-by-1 vector of change-point positions for the i-th lambda value
     (j depends on lambda). i varies between 1 and kmax
     rse   : (kmax+1)-by-1 vector of residual squared error
     kbest : the number of selected change-points
     */
    void dpseg(const Mat& X, const vector<int>& cp, vector<vector<int> >& jumps,
               Mat& rse, int& kbest, double theta, int kmax=-1 );
    
    
    private:
    /*
     Segmentation of a multi-dimensional signal with the group fused LARS.
     
     INPUT
     X       : n-by-p matrix to be segmented (n: # obs, p: # dim).
     k       : the number of change points to find.
     epsilon : values smaller than epsilon are considered null.
     weights : (n-1)*1 vector of weights for the weighted graph fused LASSO.
     
     OUTPUT
     lambda     : estimated lambda values for each change-point
     jump       : successive change-point positions (1 x k)
     meansignal : mean signal per column (1 x p vector)
     */
    void gflars(const Mat& X, vector<int>& jumps, vector<double>& lambda,
                const int k, const double epsilon );
    
    
    /*
     Fast computation of Y' * X
     
     Compute R = Y'*X, where Y is the n-by-(n-1) design matrix for the weighted
     group fused lasso, with weights defined by the vector w, and X is a n-by-p
     data matrix. The computation is done in O(np).
     
     INPUT
     X : n-by-p matrix
     w : (n-1)-by-1 vector of weights
     
     OUTPUT
     R : (n-1)-by-p matrix equal to W' * X
     */
    void leftmultiplybyXt(const Mat& X, const Mat& w, Mat& R);
    
    
    /*
     Fast computation of inv(W'*W)*X
     
     Compute R = inv(W(:,ind)'*W(:,ind))*X, where W is the n-by-(n-1) design matrix
     
     INPUT
     X   : a-by-p matrix
     ind : a-by-1 vector of indices between 1 and n-1, sorted in an ascending order
     w   : (n-1)-by-1 vector of weights
     n   : the size of X is n-by-(n-1)
     
     OUTPUT
     R   : a-by-p matrix equal to inv(W'*W)*X
     */
    void leftmultiplybyinvXAtXA(const Mat& X, const vector<int>& ind,
                                const Mat& w, const int n, Mat& R);
    
    
    /*
     Fast computation of W' * W * X when X is sparse
     
     Compute R = W'*W*X, where X is a wor-sparse (n-1)-by-p matrix and W is the
     n-by-(n-1) design matrix
     
     INPUT
     X   : a-by-p matrix whose rows are the non-zero rows of the original X
     (same order as ind)
     ind : a-by-1 vector of indices of the non-zero rows of X (each in [1,n-1])
     w   : (n-1)-by-1 vector of weights
     n   : size of the problem
     
     OUTPUT
     R   : (n-1)-by-p matrix equal to W'*W*X
     */
    void multiplyXtXbysparse(const Mat& X, const vector<int>& ind,
                             const Mat& w, const int n, Mat& R);
    
    
    /* UTILITY FUNCTIONS */
    
    // dst = src(I)
    inline void get_subvector(const Mat& src, Mat& dst, const vector<int>& I)
    {
      dst = Mat( I.size(), 1, src.type() );
      for( size_t i=0; i<I.size(); i++ )
        dst.at<double>(i) = src.at<double>(I[i]);
    };
    
    // dst = src(I,:)
    inline void get_submatrix_row(const Mat& src, Mat& dst, const vector<int>& I)
    {
      dst = Mat( I.size(), src.cols, src.type() );
      for( size_t i=0; i<I.size(); i++ )
        src.row(I[i]).copyTo( dst.row(i) );
    };
    
    // dst = cumsum(src)
    inline void cumsum(const Mat& src, Mat& dst)
    {
      if( !dst.data )
        dst = Mat( src.rows, src.cols, src.type() );
      
      src.row(0).copyTo( dst.row(0) );
      for( int r=1; r<src.rows; r++)
        dst.row(r) = dst.row(r-1) + src.row(r);
    };
    
    // dst = sum(src.^2,2)
    inline void norm2sq( const Mat& src, Mat& dst, int dim)
    {
      if( dim==0 ) {// column-wise
        dst = Mat( 1, src.cols, src.type() );
        for(int c=0; c<src.cols; c++ )
          dst.at<double>(c) = cv::sum(src.col(c).mul(src.col(c)))[0];
      }
      else {
        dst = Mat( src.rows, 1, src.type() );
        for(int r=0; r<src.rows; r++)
          dst.at<double>(r) = cv::sum(src.row(r).mul(src.row(r)))[0];
      }
    }
    
    inline void check_nan(vector<double>& v) {
      for( size_t i=0; i<v.size(); i++ )
        if( v[i]!=v[i] )
          v[i]=0.0;
    };
    
    inline void print(Mat& X, string name)
    {
      cout << name << "_c=[" << endl;
      
      for(int r=0; r<X.rows; r++) {
        for( int c=0; c<X.cols; c++) {
          if( X.type()==CV_32F || X.type()==CV_64F )
            printf("%f ", X.at<double>(r,c));
          else
            printf("%d ", X.at<int>(r,c));
        }
        printf("\n");
      }
      printf("];\n\n");
    }
    
    inline void print(vector<int> v, string name)
    {
      cout << name << "_c=[";
      for(size_t i=0; i<v.size(); i++)
        printf("%d ", v[i]);
      printf("];\n\n");
    }
    
    inline void print(vector<double> v, string name)
    {
      cout << name << "_c=[";
      for(size_t i=0; i<v.size(); i++)
        printf("%f,", v[i]);
      printf("];\n\n");
    }
  };
  
}

#endif
</file>

<file path="include/hecate/hist_opencv.hpp">
/*
 * Compute histogram of [x] using OpenCV
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_HIST_OPENCV_HPP
#define HECATE_HIST_OPENCV_HPP

#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>

#if CV_MAJOR_VERSION > 2
#include <opencv2/imgproc/types_c.h>
#endif

using namespace cv;
using namespace std;

namespace hecate {
  
  
  inline void print( const Mat x, const string filename )
  {
    ofstream myfile;
    myfile.open( filename );
    myfile << x;
    myfile.close();
  }
  
  inline void calc_gray_hist( const Mat& img, Mat& hist, int nbins=128 )
  {
    // Gray histogram
    float _range_val_gry[] = {0,256};
    const float* _range_gry = {_range_val_gry};
    
    calcHist( &img, 1, 0, Mat(), hist, 1, &nbins, &_range_gry, true, false);
    normalize( hist, hist );
  }
  
  inline void calc_color_hist( const Mat& img, Mat& hist, int nbins=128 )
  {
    // Color histogram
    float _range_val_clr[] = {0,256};
    const float* _range_clr = {_range_val_clr};
    
    // CV_BGR2HSV, CV_BGR2HLS, CV_BGR2YCrCb
    Mat img_cvt;
    cvtColor( img, img_cvt, CV_BGR2HSV );
    
    vector<Mat> planes;
    split( img_cvt, planes );
    
    if( !hist.data )
      hist = Mat( 3*nbins, 1, CV_32F, Scalar(0,0,0)[0] );
    
    Mat hist0( hist, Rect(0,0*nbins,1,nbins) );
    Mat hist1( hist, Rect(0,1*nbins,1,nbins) );
    Mat hist2( hist, Rect(0,2*nbins,1,nbins) );
    
    calcHist( &planes[0], 1, 0, Mat(), hist0, 1, &nbins, &_range_clr, true, false);
    calcHist( &planes[1], 1, 0, Mat(), hist1, 1, &nbins, &_range_clr, true, false);
    calcHist( &planes[2], 1, 0, Mat(), hist2, 1, &nbins, &_range_clr, true, false);
    
    normalize( hist0, hist0 );
    normalize( hist1, hist1 );
    normalize( hist2, hist2 );
  }
  
  
  inline void orientation( const Mat& Gx, const Mat& Gy, Mat& ori )
  {
    double alpha = 180.0 / 3.14159265358979323846264338327950288419716939937510;
    
    ori = Mat( Gx.rows, Gx.cols, CV_32F, Scalar(0,0,0)[0] );
    for(int r=0; r<Gx.rows; r++) {
      for(int c=0; c<Gx.cols; c++) {
        double deg = atan2(Gy.at<float>(r,c), Gx.at<float>(r,c)) * alpha;
        deg = (deg>=0) ? deg : deg + 360.0;
        deg = (deg<180.0) ? deg : deg - 180.0;
        ori.at<float>(r,c) = deg;
      }
    }
  }
  
  
  inline void calc_edge_hist( const Mat& Gx, const Mat& Gy, Mat& hist, int nbins_ori=16, int nbins_mag=16 )
  {
    // Edge histogram
    float _range_val_ori[] = {0,180};
    float _range_val_mag[] = {0,256};
    const float* _range_ori = {_range_val_ori};
    const float* _range_mag = {_range_val_mag};
    
    Mat ori, mag;
    orientation( Gx, Gy, ori );
    cv::magnitude( Gx, Gy, mag );
    
    if( !hist.data )
      hist = Mat( nbins_ori+nbins_mag, 1, CV_32F, Scalar(0,0,0)[0] );
    
    Mat hist_ori( hist, Rect(0,0,1,nbins_ori) );
    Mat hist_mag( hist, Rect(0,nbins_ori,1,nbins_mag) );
    
    calcHist( &ori, 1, 0, Mat(), hist_ori, 1, &nbins_ori, &_range_ori, true, false );
    calcHist( &mag, 1, 0, Mat(), hist_mag, 1, &nbins_mag, &_range_mag, true, false );
    
    normalize( hist_ori, hist_ori );
    normalize( hist_mag, hist_mag );
  }
  
  inline void calc_edge_hist( const Mat& img_gray, Mat& hist, int nbins_ori=16, int nbins_mag=16 )
  {
    Mat Gx, Gy;
    Scharr( img_gray, Gx, CV_32F, 1, 0 ); // ddepth, dx, dy
    Scharr( img_gray, Gy, CV_32F, 0, 1 );
    
    calc_edge_hist( Gx, Gy, hist, nbins_ori, nbins_mag );
  }
  
  
  inline void calc_pyr_gray_hist( const Mat& img, Mat& hist, int nbins=128, int level=2)
  {
    int w = img.cols;
    int h = img.rows;
    
    int npatches = 0;
    for(int i=0; i<level; i++)
      npatches += pow(4,i);
    
    int hist_sz = nbins;
    
    if( !hist.data )
      hist = Mat( hist_sz*npatches, 1, CV_32F, Scalar(0,0,0)[0] );
    
    int patch = 0;
    for(int l=0; l<level; l++) {
      for(int x=0; x<pow(2,l); x++) {
        for(int y=0; y<pow(2,l); y++) {
          int p_width  = floor( w/pow(2,l) );
          int p_height = floor( h/pow(2,l) );
          int p_x = x*p_width;
          int p_y = y*p_height;
          Mat patch_img( img, Rect(p_x,p_y,p_width,p_height) );
          Mat patch_hist( hist, Rect(0,patch*hist_sz,1,hist_sz) );
          calc_gray_hist( patch_img, patch_hist, nbins );
          patch++;
        }
      }
    }
  }
  
  
  inline void calc_pyr_color_hist( const Mat& img, Mat& hist, int nbins=128, int level=2)
  {
    int w = img.cols;
    int h = img.rows;
    
    int npatches = 0;
    for(int i=0; i<level; i++)
      npatches += pow(4,i);
    
    int hist_sz = 3 * nbins;
    
    if( !hist.data )
      hist = Mat( hist_sz*npatches, 1, CV_32F, Scalar(0,0,0)[0] );
    
    int patch = 0;
    for(int l=0; l<level; l++) {
      for(int x=0; x<pow(2,l); x++) {
        for(int y=0; y<pow(2,l); y++) {
          int p_width  = floor( w/pow(2,l) );
          int p_height = floor( h/pow(2,l) );
          int p_x = x*p_width;
          int p_y = y*p_height;
          Mat patch_img( img, Rect(p_x,p_y,p_width,p_height) );
          Mat patch_hist( hist, Rect(0,patch*hist_sz,1,hist_sz) );
          calc_color_hist( patch_img, patch_hist, nbins );
          patch++;
        }
      }
    }
  }
  
  
  inline void calc_pyr_edge_hist( const Mat& img, Mat& hist, int nbins_ori=16, int nbins_mag=16, int level=2)
  {
    int w = img.cols;
    int h = img.rows;
    
    int npatches = 0;
    for(int i=0; i<level; i++)
      npatches += pow(4,i);
    
    int hist_sz = nbins_ori + nbins_mag;
    
    if( !hist.data )
      hist = Mat( hist_sz*npatches, 1, CV_32F, Scalar(0,0,0)[0] );
    
    int patch = 0;
    for(int l=0; l<level; l++) {
      for(int x=0; x<pow(2,l); x++) {
        for(int y=0; y<pow(2,l); y++) {
          int p_width  = floor( w/pow(2,l) );
          int p_height = floor( h/pow(2,l) );
          int p_x = x*p_width;
          int p_y = y*p_height;
          Mat patch_img( img, Rect(p_x,p_y,p_width,p_height) );
          Mat patch_hist( hist, Rect(0,patch*hist_sz,1,hist_sz) );
          calc_edge_hist( patch_img, patch_hist, nbins_ori, nbins_mag );
          patch++;
        }
      }
    }
  }
  
  
  inline void calc_pyr_edge_hist( const Mat& Gx, const Mat& Gy, Mat& hist, int nbins_ori=16, int nbins_mag=16, int level=2)
  {
    int w = Gx.cols;
    int h = Gx.rows;
    
    int npatches = 0;
    for(int i=0; i<level; i++)
      npatches += pow(4,i);
    
    int hist_sz = nbins_ori + nbins_mag;
    
    if( !hist.data )
      hist = Mat( hist_sz*npatches, 1, CV_32F, Scalar(0,0,0)[0] );
    
    int patch = 0;
    for(int l=0; l<level; l++) {
      for(int x=0; x<pow(2,l); x++) {
        for(int y=0; y<pow(2,l); y++) {
          int p_width  = floor( w/pow(2,l) );
          int p_height = floor( h/pow(2,l) );
          int p_x = x*p_width;
          int p_y = y*p_height;
          Mat patch_Gx( Gx, Rect(p_x,p_y,p_width,p_height) );
          Mat patch_Gy( Gy, Rect(p_x,p_y,p_width,p_height) );
          Mat patch_hist( hist, Rect(0,patch*hist_sz,1,hist_sz) );
          calc_edge_hist( patch_Gx, patch_Gy, patch_hist, nbins_ori, nbins_mag );
          patch++;
        }
      }
    }
  }
  
}

#endif
</file>

<file path="include/hecate/video_parser.hpp">
/*
 * Video Parser
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_VIDEO_PARSER_HPP
#define HECATE_VIDEO_PARSER_HPP

#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <getopt.h>
#include <sys/stat.h> // mkdir
#include <unistd.h>   // access() function

#include <ctime>      // display date and time
#include <iostream>   // for standard I/O
#include <fstream>    // for file I/O
#include <string>     // for strings
#include <iomanip>    // for controlling float print precision
#include <sstream>    // string to number conversion
#include <chrono>
#include <limits>
#include <numeric>

// OpenMP library
#if defined(_OPENMP)
#include <omp.h>
#endif

// OpenCV library
#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>

#if CV_MAJOR_VERSION > 3
#include <opencv2/videoio/legacy/constants_c.h>
#endif

#include "hecate/sort.hpp"
#include "hecate/gflseg.hpp"
#include "hecate/gapstat.hpp"
#include "hecate/shot_range.hpp"
#include "hecate/hist_opencv.hpp"
#include "hecate/image_metrics.hpp"

using namespace std;
using namespace cv;

namespace hecate {
  
  // video metadata struct
  struct video_metadata {
    int nframes;
    int width;
    int height;
    double duration; // in seconds
    double fps;
  };
  
  struct parser_params {
    int step_sz;
    double fltr_begin_sec;
    double fltr_end_sec;
    double max_duration; // in seconds
    bool gfl;      // use group-fused lasso to refine boundaries
    bool fltr_lq;  // filter low-quality frames
    bool fltr_rdt; // filter redundant frames
    bool debug;
    bool ignore_rest; // if video is too long, ignore the rest (true) or
                      // adjust step_sz (false). for vidtag this should be
                      // false, while for hecate this should be true
    
    parser_params():
    step_sz(1),
    fltr_begin_sec(0),
    fltr_end_sec(0),
    max_duration(-1),
    gfl(false),
    fltr_lq(true),
    fltr_rdt(true),
    debug(false),
    ignore_rest(false)
    {};
  };
  
  inline void print_video_metadata( const string filename,
                                    const hecate::video_metadata m ) {
    printf("%s\n  seconds=%.2f, nframes=%d, fps=%.2f, resolution=%dx%d\n",
           filename.c_str(), m.duration, m.nframes, m.fps, m.width, m.height);
  };
  
  class VideoParser {
  public:
    VideoParser();
    
    /* Perform video parsing */
    // max_duration is there to handle too long videos
    //   (100K frms ~= 1 hr long with 30 fps)
    // filter_first and filter_last is there to filter out
    //   a few frames from the beginning and at the end
    //   to manually handle logos, ending credits, etc.
    vector<hecate::ShotRange> parse_video(const string& in_video,
                                       hecate::parser_params opt);
    
    /* Get the number of valid frames */
    int get_nfrm_valid();
    
    /* Display video with shot boundary information */
    void play_video_filtered(const string& in_video,
                             int step_sz=1,
                             int max_frm_len=360);
    
    /* Get a vector of booleans representing valid frames */
    inline void get_frm_valid(vector<bool>& vec) {vec=_v_frm_valid;}
    
    /* Get effective step size */
    inline int get_effective_step_size() {return _step_sz;}
    
    /* Get extracted features */
    inline const Mat get_frame_features() {return _X_feat;}
    inline const Mat get_frame_diff_features() {return _X_diff;}
    
    
  private:
    /* Read video into the memory */
    int read_video(const string& in_video,
                   int step_sz=1,
                   double max_duration=30*60,
                   bool ignore_rest=false,
                   int max_frm_len=160);
    
    /* Filter first end last few frames */
    void filter_heuristic(double fltr_begin_sec=0,
                          double fltr_end_sec=0);
    
    /* Filter out low-quality frames */
    void filter_low_quality(double thrsh_bright=0.075,
                            double thrsh_sharp=0.08,
                            double thrsh_uniform=0.80 );
    
    /* Filter out frames during transition */
    void filter_transition(double thrsh_diff=0.50,
                           double thrsh_ecr=0.10 );
    
    /* Filter out redundant frames */
    void filter_redundant_and_obtain_subshots();
    
    /* Update shot ranges, filter out shots if too short */
    void update_shot_ranges(int min_shot_len=5);

    /* Perform post processing. Break up shots if too long */
    void post_process(double min_shot_sec=2.0, bool gfl=false);
    
    /* Perform SBD using heuristics: add next big diff if
     the new shot length is longer than min_shot_len */
    void sbd_heuristic(vector<double> v_diff, vector<int>& jump,
                       int njumps, int min_shot_len );
    
    // Helper functions
    
    /* Extract pyramid of histogram features */
    void extract_histo_features(int pyr_level=2,
                                bool omit_filtered=true,
                                int nbin_color_hist=128,
                                int nbin_edge_ori_hist=8,
                                int nbin_edge_mag_hist=8);
    
    void mark_invalid( vector<bool>& vec, int idx, int wnd_sz=0 );
    void mark_invalid( vector<bool>& vec, vector<string>& vec2,
                      int idx, const string msg, int wnd_sz=0 );
    
    void release_memory();
    
    
  public:
    hecate::video_metadata meta;
    vector<bool> _v_frm_valid;    // filtered frames
    vector<string> _v_frm_log;    // filtered frames msgs (debug)
    
  private:
    bool _debug;
    bool _display;
    int _step_sz;
    int _nfrm_total;   // number of frames BEFORE sampling
    int _nfrm_given;   // number of frames AFTER sampling
    int _video_width;
    int _video_height;
    double _video_fps;
    double _video_sec;
    
    Mat _X_feat; // frame-wise feature representation
    Mat _X_diff; // n-by-1 frame-by-frame difference first-order derivative
    Mat _X_ecr;  // n-by-1 ecr first-order derivative
    
    vector<Mat> _v_frm_rgb;       // rgb frames
    vector<Mat> _v_frm_gray;      // gray-scale frames
    
    vector<hecate::ShotRange> _v_shot_ranges;
  };
}


#endif
</file>

<file path="src/hecate/gflseg.cpp">
/*
 * GFLSEG Group Fused LASSO Change Point Detection solver
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 *
 * Implementation is based on:
 *   Kevin Bleakley and Jean-Philippe Vert.
 *     "The group fused lasso for multiple change-point detection."
 *   arXiv preprint arXiv:1106.4199 (2011).
 */

#include "hecate/gflseg.hpp"

using namespace std;
using namespace cv;
using namespace hecate;

void Segmenter::gflseg(const Mat& X, vector<int>& jumps, int k, double theta)
{
  double epsilon = 1e-9;
  
  // group fused LASSO solver
  vector<int> jmp1;
  vector<double> lambda;
  gflars( X, jmp1, lambda, k, epsilon );
  
  // DP optimizer
  vector<vector<int> > jmp2;
  Mat rse;
  int kbest = 0;
  dpseg( X, jmp1, jmp2, rse, kbest, theta, -1 );
  
  // return the optimal solution
  jumps.resize( (int)jmp2[kbest].size(), 0 );
  for( size_t i=0; i<jmp2[kbest].size(); i++)
    jumps[i] = jmp2[kbest][i];
  //jumps[jmp2[kbest].size()] = X.rows-1; // last index
};


void Segmenter::dpseg(const Mat& X, const vector<int>& cp, vector<vector<int> >& jumps,
                      Mat& rse, int& kbest, double theta, int kmax )
{
  int n = X.rows; // the length of the signal X
  int p = X.cols; // the dimension of the signal X
  
  // Prevent the likelihood from diverging too much
  if( kmax<0 )
    kmax = min((int)cp.size(), (int)floor(n/10));
  
  vector<int>::iterator it;
  vector<int> cp_srt = cp;
  std::sort( cp_srt.begin(), cp_srt.end() );
  
  // Compute boundaries of the smallest intervals considered
  // b = sort(union([0],union([n],option.candidatechangepoints)));
  vector<int> b(2+cp.size());
  vector<int> edge = {-1, n-1};
  it = set_union( edge.begin(), edge.end(), cp_srt.begin(), cp_srt.end(), b.begin() );
  b.resize( it-b.begin() );
  std::sort( b.begin(), b.end() );
  
  
  // k is the number of such intervals
  int k = (int)b.size()-1;
  
  
  // Compute the k-by-k matrix J such that J(i,j) for i<=j is the RSE when
  // intervals i-to-j are merged.
  //
  // According to Picard,
  // "J(i,j) is the cost of the path connecting i-to-j in k steps (k segments)"
  // http://pbil.univ-lyon1.fr/members/fpicard/franckpicard_fichiers/pdf/aCGH-stat.pdf
  Mat J( k,   k, X.type(), Scalar(0,0,0)[0] );
  Mat S( n+1, p, X.type(), Scalar(0,0,0)[0] ); // cumsum of the rows of X
  Mat v( n+1, 1, X.type(), Scalar(0,0,0)[0] ); // cumsum of squared norm of the rows of X
  
  // S = [zeros(1,size(X,2));cumsum(X)]; % cumsum of the rows
  Mat Ssub = S( Rect(0,1,p,n) ); cumsum( X, Ssub );
  
  // v = [0;cumsum(sum(X.*X,2))]; % cumsum of squared norm of the rows
  Mat vsub = v( Rect(0,1,1,n) );
  cv::reduce( X.mul(X), vsub, 1, CV_REDUCE_SUM );
  cumsum( vsub, vsub );
  
  for( int i=0; i<k; i++ ) {
    for( int j=i; j<k; j++ ) {
      int Istart = b[i]+1;
      int Iend = b[j+1];
      // Regularization term: 1/length * ||s[end]-s[start]||^2_2
      double penalty = pow(cv::norm(S.row(Iend+1)-S.row(Istart)),2.0)/(Iend-Istart+1);
      J.at<double>(i,j) = v.at<double>(Iend+1)-v.at<double>(Istart)-penalty;
    }
  }
  
  //
  // DP recursion
  //
  
  // V(i,j) is the best RSE for segmenting intervals 1 to j with at most i-1 change-points
  Mat V( kmax+1, k, X.type(), Scalar(0,0,0)[0] );
  Mat jumpmat( kmax, k, CV_32S, Scalar(-1,0,0)[0] );
  
  // With no change-points, V(1,j) is just the precomputed RSE for intervals 1 to j
  J.row(0).copyTo( V.row(0) );
  
  // The recursive formula
  // NOTE: minidx/maxidx in minMaxIdx are very, very confusing to use!
  int minidx[2]; double minval;
  for( int ki=0; ki<kmax; ki++ ) {
    for( int j=ki+1; j<k; j++ ) {
      Mat tmp = V(Rect(ki,ki,j-ki,1)) + J(Rect(j,ki+1,1,j-ki)).t();
      minMaxIdx( tmp, &minval, 0, minidx, 0 ); // row matrix
      V.at<double>(ki+1,j) = minval;
      jumpmat.at<int>(ki,j) = minidx[1]+ki;
    }
  }
  
  
  // Optimal segmentations
  for( int ki=0; ki<kmax; ki++ )
  {
    vector<int> jump_ki(ki+1, 0);
    jump_ki[ki] = jumpmat.at<int>( ki,k-1 );
    for( int i=ki-1; i>=0; i-- )
      jump_ki[i] = jumpmat.at<int>(i,jump_ki[i+1]);
    jumps.push_back( jump_ki );
  }
  
  
  // Convert interval index back to the last position before the jump
  for( int ki=0; ki<kmax; ki++ )
    for( size_t i=0; i<jumps[ki].size(); i++ )
      jumps[ki][i] = b[ 1+jumps[ki][i] ];
  
  
  // RSE as a fuction of the number of change-points
  V.col(k-1).copyTo( rse );
  
  
  //
  // Based on DP table, find the optimal number of change-points
  //
  
  // log-likelihood is -n/2*(J-log(n)+1+log(2*pi));
  Mat JJ; cv::log( rse, JJ );
  
  // normalize
  // >> JJtild = (JJ(Km)-JJ) / (JJ(Km)-JJ(1)) * (Km-1) + 1;
  int Km = JJ.rows;
  Mat JJtild = (JJ.at<double>(Km-1)-JJ) / (JJ.at<double>(Km-1)-JJ.at<double>(0)) * (Km-1) + 1;
  
  
  // find the inflexion point
  // >> res.kbest = max(find(diff(diff(Jtild))>option.threshold))+1;
  Mat dJJtild(Km-1,1,X.type(),Scalar(0,0,0)[0]);
  Mat ddJJtild(Km-2,1,X.type(),Scalar(0,0,0)[0]);
  for(int i=0; i<Km-1; i++)
    dJJtild.at<double>(i) = JJtild.at<double>(i+1) - JJtild.at<double>(i);
  for(int i=0; i<Km-2; i++)
    ddJJtild.at<double>(i) = dJJtild.at<double>(i+1) - dJJtild.at<double>(i);
  
  kbest = 0;
  for( int i=0; i<Km-2; i++ )
    if( ddJJtild.at<double>(i)>theta && i>kbest )
      kbest = i;
};


void Segmenter::gflars(const Mat& X, vector<int>& jumps,
                       vector<double>& lambda, const int k, const double epsilon)
{
  int n = X.rows; // the length of the signal X
  int p = X.cols; // the dimension of the signal X
  
  jumps.clear();
  lambda.clear();
  
  // Default weight w(i) = sqrt(n/(i*(n-i)))
  Mat weights( n-1, 1, X.type() );
  for( int i=0; i<n-1; i++ )
    weights.at<double>(i)= sqrt((double)n/((i+1)*(n-i-1)));
  
  // Auxilary variable to use MATLAB-like sort function. The variable vjmps
  // should always be synced with vector<int> jumps.
  vector<int> vsrtval;    // contains sorted values
  vector<size_t> vsrtidx; // contains sorted indices
  
  //
  // Initialize cHat = W'*X
  Mat cHat;
  leftmultiplybyXt(X,weights,cHat);
  
  vector<int> A; // Active set indices (sorted in an ascending order)
  Mat cHatSub; // Used to access cHat(A,:)
  
  //
  // Main loop to find the successive jumps
  for( int iter=0; iter<k; iter++ )
  {
    // Compute row-wise norms of cHat
    // >> cHatSquareNorm = sum(cHat.^2,2);
    Mat cHatSquareNorm;
    norm2sq( cHat, cHatSquareNorm, 1 ); // 0:col, 1:row-wise
    
    // >> [bigcHat,besti]=max(cHatSquareNorm);
    int besti[2];
    double bigcHat;
    minMaxIdx( cHatSquareNorm, 0, &bigcHat, 0, besti ); // col matrix
    
    //
    // In the first iteration, we add the most correlated feature to the
    // active set. For the other iterations, this is already done at the
    // end of the previous iteration
    if( iter==0 ) {
      jumps.push_back( besti[0] );
    }
    
    // Resize active set vector and cHatSub matrix
    A.resize( iter+1, 0 );
    cHatSub = Mat( iter+1, p, X.type(), Scalar(0,0,0)[0] );
    
    
    //
    // Compute the descent direction W = inv(X(:,A)'*X(:,A))*cHat(A,:)
    Mat W; // size of (iter+1)-by-p
    
    // >> [A,I]=sort(res.jump(1:iter));
    hecate::sort( jumps, A, vsrtidx );
    get_submatrix_row( cHat, cHatSub, A );
    
    // >> w = leftmultiplybyinvXAtXA(n,A,cHat(A,:),weights);
    leftmultiplybyinvXAtXA(cHatSub,A,weights,n,W);
    
    // >> B = multiplyXtXbysparse(n,A,w,weights);
    Mat B;
    multiplyXtXbysparse(W,A,weights,n,B);
    
    //
    // Compute the descent step
    //   For each i we find the largest possible step alpha by solving:
    //      norm(cHat(i,:)-alpha*B(i,:)) = norm(cHat(j,:)-alpha*B(j,:))
    //      where j is in the active set.
    //   We write it as a second order polynomial
    //      a1(i)*alpha^2 - 2* a2(i)*alpha + a3(i)
    
    Mat a1,a2,a3;
    Mat a1sub, a2sub, a3sub;
    Mat tmp1, tmp2, tmp3;
    vector<int> subset;
    
    // >> a1 = bigcHat - sum(B.^2,2);
    cv::reduce( B.mul(B), a1, 1, CV_REDUCE_SUM );
    a1 = bigcHat - a1;
    
    // >> a2 = bigcHat - sum(B.*cHat,2);
    cv::reduce( B.mul(cHat), a2, 1, CV_REDUCE_SUM );
    a2 = bigcHat - a2;
    
    // >> a3 = bigcHat - cHatSquareNorm;
    a3 = bigcHat - cHatSquareNorm;
    
    //
    // Now we solve it
    // >> gammaTemp = zeros(2*(n-1),1);
    Mat gammaTemp( 2*(n-1), 1, X.type(), Scalar(0,0,0)[0] );
    
    // First, those where we really have a second-order polynomial
    // >> subset = find(a1 > EPSILON);
    for( int i=0; i<a1.rows; i++ )
      if( a1.at<double>(i)>epsilon )
        subset.push_back(i);
    
    if( !subset.empty() )
    {
      get_subvector( a1, a1sub, subset );
      get_subvector( a2, a2sub, subset );
      get_subvector( a3, a3sub, subset );
      
      // tmp1 = sqrt( a2(subset).^2 - a1(subset).*a3(subset) )
      cv::sqrt( a2sub.mul(a2sub)-a1sub.mul(a3sub), tmp1);
      
      // >> gammaTemp(subset)
      // = (a2(subset) + sqrt( a2(subset).^2 - a1(subset).*a3(subset) )) ./ a1(subset);
      cv::divide( a2sub + tmp1, a1sub, tmp2);
      for( size_t i=0; i<subset.size(); i++ )
        gammaTemp.at<double>(subset[i]) = tmp2.at<double>(i);
      
      // >> gammaTemp(subset+n-1)
      // = (a2(subset) - sqrt( a2(subset).^2 - a1(subset).*a3(subset) )) ./ a1(subset);
      cv::divide( a2sub - tmp1, a1sub, tmp2);
      for( size_t i=0; i<subset.size(); i++ )
        gammaTemp.at<double>(subset[i]+n-1) = tmp2.at<double>(i);
      
      subset.clear();
    }
    
    //
    // then those where the quadratic term vanishes and we have a
    // first-order polynomial
    // >> subset = find((a1 <= EPSILON) & (a2 > EPSILON));
    for( int i=0; i<a1.rows; i++ )
      if( a1.at<double>(i)<=epsilon && a2.at<double>(i)>epsilon )
        subset.push_back(i);
    
    if( !subset.empty() )
    {
      get_subvector( a1, a1sub, subset );
      get_subvector( a2, a2sub, subset );
      get_subvector( a3, a3sub, subset );
      
      // >> gammaTemp(subset)     = a3(subset) ./ (2*a2(subset));
      // >> gammaTemp(subset+n-1) = a3(subset) ./ (2*a2(subset));
      cv::divide( a3sub, 2*a2sub, tmp2 );
      for( size_t i=0; i<subset.size(); i++ )
        gammaTemp.at<double>(subset[i]) = gammaTemp.at<double>(subset[i]+n-1) = tmp2.at<double>(i);
      
      subset.clear();
    }
    
    
    //
    // Finally the active set should not be taken into account, as well as
    // those for which the computation gives dummy solutions
    // >> maxg=max(gammaTemp)+1;
    double maxg; minMaxIdx(gammaTemp, 0, &maxg); maxg+=1.0;
    
    // >> subset = find((a1 <= EPSILON) & (a2 <= EPSILON));
    for( int i=0; i<a1.rows; i++ )
      if( a1.at<double>(i)<=epsilon && a2.at<double>(i)<=epsilon )
        subset.push_back(i);
    
    if( !subset.empty() )
    {
      // >> gammaTemp(subset) = maxg;
      // >> gammaTemp(n+subset) = maxg;
      for( size_t i=0; i<subset.size(); i++ )
        gammaTemp.at<double>(subset[i]) = gammaTemp.at<double>(subset[i]+n) = maxg;
      subset.clear();
    }
    
    // >> gammaTemp(A) = maxg;
    // >> gammaTemp(n+A-1) = maxg;
    for( size_t i=0; i<A.size(); i++ )
      gammaTemp.at<double>(A[i]) = gammaTemp.at<double>(A[i]+n-1) = maxg;
    
    // >> gammaTemp(gammaTemp<=0)=maxg;
    // >> gammaTemp(imag(gammaTemp)~=0) = maxg;
    for( int i=0; i<gammaTemp.rows; i++ )
      if( gammaTemp.at<double>(i)<=0 || gammaTemp.at<double>(i)!=gammaTemp.at<double>(i) )
        gammaTemp.at<double>(i) = maxg;
    
    //
    // Now we can take the minimum
    // >> [gamma,nexttoadd]=min(gammaTemp);
    double gamma;
    int nexttoadd[2];
    minMaxIdx( gammaTemp, &gamma, 0, nexttoadd, 0); // col matrix
    
    //
    // Update
    // >> res.value{iter} = zeros(iter,p);
    // >> res.value{iter}(I,:) = gamma*w;
    // >> if iter>1
    // >>     res.value{iter}(1:(iter-1),:) = res.value{iter}(1:(iter-1),:) + res.value{iter-1};
    // >> end
    
    // >> res.lambda(iter)=sqrt(bigcHat);
    lambda.push_back( sqrt(bigcHat) );
    
    // >> if iter<k
    // >>     res.jump(iter+1) = 1+mod(nexttoadd-1,n-1);
    // >>     cHat = cHat-gamma*a;
    // >> end
    if( iter+1<k ) {
      jumps.push_back( nexttoadd[0]%(n-1) );
      cHat = cHat - gamma*B;
    }
  }
};


// X is n-by-p, w is (n-1)-by-1, R is (n-1)-by-p
void Segmenter::leftmultiplybyXt(const Mat& X, const Mat& w, Mat& R)
{
  int n = X.rows;
  int p = X.cols;
  
  R = Mat( n-1, p, X.type() );
  
  // R = ([1:n-1]'*U(end,:)/n - U(1:end-1,:)) .* w(:,ones(1,p));
  Mat U; cumsum( X, U );
  
  // llt = [1:n-1]'
  Mat llt( n-1, 1, X.type() );
  for( int r=0; r<n-1; r++ )
    llt.at<double>(r) = (double)(r+1);
  
  Mat lt = llt*U.row(n-1)/n - U(Rect(0,0,p,n-1));
  for( int c=0; c<p; c++ )
    R.col(c) = lt.col(c).mul(w);
};



// X is a-by-p, w is (n-1)-by-1, R is a-by-p, ind is a-by-1, where 1<=a<=(n-1)
void Segmenter::leftmultiplybyinvXAtXA(const Mat& X, const vector<int>& ind,
                                       const Mat& w, const int n, Mat& R)
{
  int a = X.rows;
  int p = X.cols;
  R = Mat( a, p, X.type(), Scalar(0,0,0)[0] );
  
  if( a>0 )
  {
    // >> u = diff([0;ind;n])
    // Note: we convert C++ index system (zero-base) to MATLAB (one-base)
    Mat u( a+1, 1, X.type() );
    u.at<double>(0) = ind[0]+1; // [2 0 1] becomes [3 1 2]
    u.at<double>(a) = n - (ind[a-1]+1);
    for( int i=1; i<a; i++ )
      u.at<double>(i) = ind[i] - ind[i-1];
    
    // >> val = val ./ w(ind,ones(1,p))
    Mat val;  X.copyTo(val);
    Mat wsub; get_subvector(w, wsub, ind);
    for( int c=0; c<p; c++ )
      cv::divide( val.col(c), wsub, val.col(c) );
    
    // >> delta = diff( [zeros(1,p); val; zeros(1,p)] ) ./ u(:,ones(1,p))
    Mat delta( a+1, p, X.type(), Scalar(0,0,0)[0] );
    delta.row(0) = val.row(0)+0.0;
    delta.row(a) = -val.row(a-1);
    for( int r=1; r<a; r++ )
      delta.row(r) = val.row(r) - val.row(r-1);
    for( int c=0; c<p; c++ )
      cv::divide( delta.col(c), u, delta.col(c) );
    
    // >> R = - diff( delta )
    for(int r=0; r<a; r++)
      R.row(r) = delta.row(r) - delta.row(r+1);
    
    // >> R = R ./ w(ind,ones(1,p))
    for(int c=0; c<p; c++)
      cv::divide( R.col(c), wsub, R.col(c) );
  }
};



void Segmenter::multiplyXtXbysparse(const Mat& X, const vector<int>& ind,
                                    const Mat& w, const int n, Mat& R)
{
  int a = X.rows;
  int p = X.cols;
  
  R = Mat( n-1, p, X.type(), Scalar(0,0,0)[0] );
  if( a>0 )
  {
    Mat wsub; get_subvector(w, wsub, ind);
    Mat val; X.copyTo(val);
    
    // First multiply beta by the weights
    // >> val = val .* w(ind,ones(1,p));
    for(int c=0; c<p; c++)
      val.col(c) = val.col(c).mul(wsub);
    
    //  compute the matrix s of increments of r
    // >> S = zeros(n-1,p);
    Mat S( n-1, p, X.type(), Scalar(0,0,0)[0] );
    
    // >> S(ind,:) = val;
    for( size_t i=0; i<ind.size(); i++ )
      val.row(i).copyTo(S.row(ind[i]));
    
    // >> S = flipud(cumsum(flipud(S)));
    flip(S,S,0); cumsum(S,S); flip(S,S,0);
    
    // >> u = ind' * val; // don't forget to add ones
    Mat indv( 1, a, X.type() );
    for( size_t i=0; i<ind.size(); i++ )
      indv.at<double>(i) = (double)(ind[i]+1);
    Mat u = indv * val;
    
    // >> S = S - u(ones(n-1,1),:)/n;
    for( int r=0; r<n-1; r++ )
      S.row(r) = S.row(r) - u/n;
    
    // then make the cumsum
    // >> R = cumsum(S);
    cumsum( S, R );
    
    // then multiply the rows by the weights
    // >> R = R .* w(:,ones(1,p));
    for( int c=0; c<p; c++ )
      R.col(c) = R.col(c).mul(w);
  }
};
</file>

<file path="src/hecate/hecate_main.cpp">
/*
 * HECTATE Video Processing Library - Main
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#include "hecate/hecate.hpp"

using namespace std;
using namespace cv;

void run_hecate( hecate_params& opt, vector<int>& v_thumb_idx,
                 vector<hecate::Range>& v_gif_range,
                 vector<hecate::Range>& v_mov_range)
{
  if( !hecate::file_exists(opt.in_video) ) {
    fprintf(stderr, "File not exist: %s\n", opt.in_video.c_str());
    return;
  }
  
  v_thumb_idx.clear();
  v_gif_range.clear();
  v_mov_range.clear();

  hecate::Clock::time_point t0;
  hecate::VideoParser parser;
  
  vector<hecate::ShotRange> v_shot_range;
  Mat histo_features;
  Mat diff_features;
  
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Parse video
  //
  ////////////////////////////////////////////////////////////////////////////
  
  if( opt.debug ) {
    printf("run_hecate: Video segmentation and keyframe extraction\n");
    t0 = hecate::Clock::now();
  }

  hecate::parser_params parser_opt;
  parser_opt.step_sz = opt.step_sz;
  parser_opt.gfl = opt.gfl;
  parser_opt.fltr_begin_sec = ( opt.fltr_begin_sec<0 )
      ? max(0.5, 0.05 * parser.meta.duration) : opt.fltr_begin_sec;
  parser_opt.fltr_end_sec = ( opt.fltr_end_sec<0 )
      ? max(0.5, 0.10 * parser.meta.duration) : opt.fltr_end_sec;
  parser_opt.max_duration = opt.max_duration;
  parser_opt.ignore_rest = (opt.max_duration>0); // ignore parts after max_nfrms
  parser_opt.debug = opt.debug;
  
  // PARSE
  v_shot_range = parser.parse_video( opt.in_video, parser_opt );
  if( v_shot_range.empty() ) {
    fprintf(stderr, "run_hecate: Failed to parse the video\n");
    return;
  }
  
  histo_features = parser.get_frame_features();
  diff_features  = parser.get_frame_diff_features();
  opt.step_sz    = parser.get_effective_step_size();
  
  // If video is shorter than desired summary length
  if( opt.mov && opt.lmov >= parser.meta.duration ) {
    fprintf( stderr, "run_hecate: Video duration is %.2f seconds, "
            "shorter than the requested summary of length %.2f seconds.\n"
            "\tVideo summarization is disabled.",
            parser.meta.duration, (double)opt.lmov);
    opt.mov = false;
  }
  
  // Check desired resolution of output
  if( opt.jpg_width_px<0 || opt.jpg_width_px > parser.meta.width ) {
    //fprintf( stderr, "run_hecate: Forcing jpg_width_px to %d\n",parser.meta.width);
    opt.jpg_width_px = parser.meta.width;
  }
  if( opt.gif_width_px<0 || opt.gif_width_px > parser.meta.width ) {
    //fprintf( stderr, "run_hecate: Forcing gif_width_px to %d\n",parser.meta.width);
    opt.gif_width_px = parser.meta.width;
  }
  if( opt.mov_width_px<0 || opt.mov_width_px > parser.meta.width ) {
    //fprintf( stderr, "run_hecate: Forcing mov_width_px to %d\n",parser.meta.width);
    opt.mov_width_px = parser.meta.width;
  }
  
  if( opt.debug ) {
    hecate::print_elapsed_time( t0, "run_hecate" );
    hecate::print_video_metadata( opt.in_video, parser.meta );
  }

  
  
  ////////////////////////////////////////////////////////////////////////////
  //
  // Analyze video
  //
  ////////////////////////////////////////////////////////////////////////////
  
  // Print shot info
  if( opt.info_shot ) {
    printf("shots: ");
    for(size_t i=0; i<v_shot_range.size(); i++) {
      printf("[%d:%d]", v_shot_range[i].start, v_shot_range[i].end);
      if( i<v_shot_range.size()-1 )
        printf(",");
    }
    printf("\n");
  }
  
  // Print keyframe indices
  if( opt.info_keyfrm ) {
    vector<int> keyfrms;
    for(size_t i=0; i<v_shot_range.size(); i++) {
      for(size_t j=0; j<v_shot_range[i].v_idx.size(); j++) {
        keyfrms.push_back(v_shot_range[i].v_idx[j]);
      }
    }
    
    printf("keyframes: [");
    for(size_t i=0; i<keyfrms.size(); i++) {
      printf("%d", keyfrms[i]);
      if( i<keyfrms.size()-1 )
        printf(",");
    }
    printf("]\n");
  }
  
  // Thumbnail extraction module
  if( opt.jpg ) {
    if( opt.debug ) {
      printf("run_hecate: Video keyframe detection\n");
      t0 = hecate::Clock::now();
    }
    
    detect_thumbnail_frames( opt, parser.meta, v_shot_range,
                             histo_features, diff_features,
                             v_thumb_idx);
    
    if( opt.debug ) {
      hecate::print_elapsed_time( t0, "run_hecate" );
    }
  }
  
  // GIF generation module
  if( opt.gif ) {
    if( opt.debug ) {
      printf("run_hecate: Video highlight detection for GIF creation\n");
      t0 = hecate::Clock::now();
    }
    
    bool mov = opt.mov;
    opt.mov = false;
    detect_highlight_shots( opt, parser.meta, v_shot_range,
                            histo_features, diff_features, v_gif_range );
    opt.mov = mov;
    if( opt.debug ) {
      hecate::print_elapsed_time( t0, "run_hecate" );
    }
  }
  
  // Video summarization module
  if( opt.mov ) {
    if( opt.debug ) {
      printf("run_hecate: Video highlight detection for summarization\n");
      t0 = hecate::Clock::now();
    }
    
    bool gif = opt.gif;
    opt.gif = false;
    detect_highlight_shots( opt, parser.meta, v_shot_range,
                            histo_features, diff_features, v_mov_range );
    opt.gif = gif;
    if( opt.debug ) {
      hecate::print_elapsed_time( t0, "run_hecate" );
    }
  }
}
</file>

<file path="include/hecate/file_helper.hpp">
/*
 * Various helper functions for filesystem
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_FILE_HPP
#define HECATE_FILE_HPP

#include <stdio.h>
#include <string.h>

#include <iostream>
#include <fstream>
#include <algorithm>
#include <functional>
#include <cctype>
#include <locale>
#include <string>
#include <vector>

namespace hecate {
  
  // GET FILENAME WITHOUT EXTENSION AND TRAILING DIRECTORIES
  struct FileParts
  {
    std::string path;
    std::string name;
    std::string ext;
  };
  
  static inline FileParts fileparts(std::string filename)
  {
    int idx0 = filename.rfind("/");
    int idx1 = filename.rfind(".");
    
    if( idx1 == (int) std::string::npos )
      idx1 = filename.length();
    
    FileParts fp;
    fp.path = filename.substr(0,idx0+1);
    fp.name = filename.substr(idx0+1,idx1-idx0-1);
    fp.ext  = filename.substr(idx1);
    
    return fp;
  };
  
  static inline std::string get_dir( std::string filepath ) {
    hecate::FileParts fp = hecate::fileparts( filepath );
    std::string dir = fp.path;
    return dir;
  };
  
  static inline std::string escape_space( std::string s ) {
    std::string out;
    for( size_t i=0; i<s.size(); i++) {
      if( s[i] == ' ' )
        out += '\\';
      out += s[i];
    }
    return out;
  }
  
  static inline std::string get_filename( std::string filepath ) {
    hecate::FileParts fp = hecate::fileparts( filepath );
    std::string filename = fp.name;
    replace( filename.begin(), filename.end(), ' ', '_' );
    return filename;
  };
  
  // TRIM STRING. USEFUL FOR PROCESSING STRING FILENAMES
  // trim from start
  static inline std::string &ltrim(std::string &s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
    return s;
  };
  // trim from end
  static inline std::string &rtrim(std::string &s) {
    s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
    return s;
  };
  // trim from both ends
  static inline std::string &trim(std::string &s) {
    return ltrim(rtrim(s));
  };
  
  
  static inline char *trim(char *str)
  {
    size_t len = 0;
    char *frontp = str;
    char *endp = NULL;
    
    if( str == NULL ) { return NULL; }
    if( str[0] == '\0' ) { return str; }
    
    len = strlen(str);
    endp = str + len;
    
    /* Move the front and back pointers to address the first non-whitespace
     * characters from each end.
     */
    while( isspace(*frontp) ) { ++frontp; }
    if( endp != frontp )
    {
      while( isspace(*(--endp)) && endp != frontp ) {}
    }
    
    if( str + len - 1 != endp )
      *(endp + 1) = '\0';
    else if( frontp != str &&  endp == frontp )
      *str = '\0';
    
    /* Shift the string so that it starts at str so that if it's dynamically
     * allocated, we can still free it on the returned pointer.  Note the reuse
     * of endp to mean the front of the string buffer now.
     */
    endp = str;
    if( frontp != str )
    {
      while( *frontp ) { *endp++ = *frontp++; }
      *endp = '\0';
    }
    return str;
  };
  
  
  // CHECK IF FILE EXISTS
  static inline bool file_exists (const std::string& name) {
    if (FILE *file = fopen(name.c_str(), "r")) {
      fclose(file);
      return true;
    } else {
      return false;
    }
  };
  
  // READ TEXT FILE INTO A VECTOR
  static inline void read_textlist( const std::string& in,
                                   std::vector<std::string>& out )
  {
    std::string str;
    std::ifstream file( in );
    while( std::getline( file, str ) ) {
      str = hecate::trim(str);
      if( str.length()==0 ) continue;
      if( str.at(0)=='#' ) continue;
      out.push_back( str );
    }
  };
  
  // READ TEXT FILE CONTAINING A LIST OF FILEPATHS
  static inline void read_filelist( const std::string& in,
                                   std::vector<std::string>& out )
  {
    std::string str;
    std::ifstream file( in );
    while( std::getline( file, str ) ) {
      str = hecate::trim(str);
      if( str.length()==0 ) continue;
      if( str.at(0)=='#' ) continue;
      
      if( hecate::file_exists( str ) )
        out.push_back( str );
      else
        fprintf( stderr, "File doesn't exist: %s\n", str.c_str() );
      
    }
  };
  
  static inline void split_string( char* in,
                                  std::vector<std::string>& out,
                                  const char* delimiter)
  {
    out.clear();
    char *token = in;
    while( (token=strsep(&in,delimiter)) != NULL )
      out.push_back( hecate::trim(token) );
  };
  
  static inline std::string exec(const char* cmd) {
    FILE* pipe = popen(cmd, "r");
    if (!pipe) return "ERROR";
    char buffer[1024];
    std::string result = "";
    while (!feof(pipe)) {
      if (fgets(buffer, 1024, pipe) != NULL)
        result += buffer;
    }
    pclose(pipe);
    return result;
  };
  
  static inline std::string which(const char* bin) {
    char buf[1024];
    sprintf( buf, "echo `which %s`", bin );
    std::string result = hecate::exec(buf);
    result.erase( result.find_last_not_of(" \n\r\t")+1);
    return result;
  }
}
#endif
</file>

<file path="include/hecate/gapstat.hpp">
/*
 * Gap statistics
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */


#ifndef HECATE_GAPSTAT_HPP
#define HECATE_GAPSTAT_HPP

#include <stdio.h>
#include <stdlib.h>

#include <iostream>   // for standard I/O
#include <limits>
#include <numeric>

#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>

#if CV_MAJOR_VERSION > 2
#include <opencv2/core/core_c.h>
#include <opencv2/imgproc/types_c.h>
#endif

using namespace std;
using namespace cv;

namespace hecate {
  
  // Compute mean-squared error (mse)
  inline double calc_mse( const Mat& km_data, const Mat& km_lbl, const Mat& km_ctr )
  {
    double compactness = 0;
    
    int nsamples = km_lbl.rows;
    int nclusters  = km_ctr.rows;
    
    for( int k=0; k<nclusters; k++ ) {
      int nk = 0;
      double err = 0;
      for( int i=0; i<nsamples; i++ ) {
        if( km_lbl.at<int>(i)==k ) {
          nk++;
          err += pow(cv::norm(km_data.row(i)-km_ctr.row(k)),2.0);
        }
      }
      compactness += 0.5 * err / nk;
    }
    
    return compactness;
  }
  
  inline void find_bounds( const Mat& km_data, Mat& bounds )
  {
    int ndim = km_data.cols;
    bounds = Mat(2,ndim,CV_64F);
    
    double minval, maxval;
    for( int d=0; d<ndim; d++ ){
      minMaxLoc( km_data.col(d), &minval, &maxval );
      bounds.at<double>(0,d) = minval;
      bounds.at<double>(1,d) = maxval;
    }
  }
  
  inline void randu_bound( Mat& X, const Mat& bounds, int nsamples, int ndims )
  {
    X = Mat(nsamples, ndims, CV_32F);
    randu( X, Scalar::all(0.0), Scalar::all(1.0) );
    for(int c=0; c<X.cols; c++) {
      double lb = bounds.at<double>(0,c);
      double ub = bounds.at<double>(1,c);
      X.col(c) = (ub-lb)*X.col(c) + lb;
    }
  }
  
  //fix error when there is only 1 data point: http://docs.opencv.org/2.4/modules/core/doc/clustering.html
  inline void perform_kmeans(const Mat& km_data, Mat& km_lbl, Mat& km_ctr, int ncluster,
                             int km_attempts=1, int km_max_cnt=1000, double km_eps=0.0001)
  {
      if(km_data.rows==1){
          km_lbl = Mat::zeros(1,1, km_lbl.type());
          cv::reduce( km_data, km_ctr, 0, CV_REDUCE_AVG );
      }
      else{
        int km_k = min(ncluster, km_data.rows);
        TermCriteria km_opt = TermCriteria(CV_TERMCRIT_ITER|CV_TERMCRIT_EPS, km_max_cnt, km_eps);
        kmeans( km_data, km_k, km_lbl, km_opt, km_attempts, KMEANS_PP_CENTERS, km_ctr );
      }
}
  
  inline int perform_kmeans_gs( const Mat& km_data, Mat& km_lbl, Mat& km_ctr,
                               vector<int> K, int B=10, int N=500 )
  {
    int ndims = km_data.cols;
    
    // Generate null reference dataset
    vector<Mat> v_Xb;
    Mat bounds; find_bounds( km_data, bounds );
    for(int b=0; b<B; b++) {
      Mat Xb;
      randu_bound( Xb, bounds, N, ndims );
      v_Xb.push_back( Xb );
    }
    
    // Compute Gap Statistics
    vector<double> gap(K.size(), 0.0);    // gap statistics = E[logWk] - logWk
    vector<double> ElogWk(K.size(), 0.0); // compactness of the null reference distribution
    vector<double> logWk(K.size(), 0.0);  // compactness of the given data
    vector<double> Sk(K.size(), 0.0);   // standard deviations
    
    for( size_t i=0; i<K.size(); i++ )
    {
      Mat lbl, ctr;
      perform_kmeans( km_data, lbl, ctr, K[i] );
      logWk[i] = log(calc_mse( km_data, lbl, ctr ));
      
      ElogWk[i] = 0.0;
      vector<double> logWkb(B, 0.0);
      for(int b=0; b<B; b++)
      {
        Mat lbl_b, ctr_b;
        perform_kmeans( v_Xb[b], lbl_b, ctr_b, K[i], 100, 1000, 0.001 );
        logWkb[b] = log(calc_mse( v_Xb[b], lbl_b, ctr_b ));
        ElogWk[i] += logWkb[b];
      }
      ElogWk[i] /= B;
      
      Sk[i] = 0.0;
      for(int b=0; b<B; b++)
        Sk[i] += (logWkb[b]-ElogWk[i])*(logWkb[b]-ElogWk[i]);
      Sk[i] = sqrt(1.0+1.0/B) * sqrt( Sk[i] / B );
      
      gap[i] = ElogWk[i] - logWk[i];
      printf("\tgapstat: k=%d, logWk=%f, ElogWk=%f, Sk=%f, Gap=%f\n",
             K[i], logWk[i], ElogWk[i], Sk[i], gap[i]);
    }
    
    // find the smallest k such that gap(k) >= gap(k+1) - S[k+1]
    size_t kstar=0;
    for(size_t i=0; i<K.size()-1; i++) {
      if( gap[i] >= gap[i+1] - Sk[i+1] ) {
        kstar = i;
        break;
      }
    }
    printf("\tgapstat: Optimal k=%d [%d:%d]\n", K[kstar], K[0], K[K.size()-1]);
    
    // return results
    perform_kmeans( km_data, km_lbl, km_ctr, K[kstar] );
    return K[kstar];
    
  }
}

#endif
</file>

<file path="src/hecate/hecate_thumbnail.cpp">
/*
 * HECATE Video Processing Library - Thumbnail
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#include "hecate/hecate.hpp"

using namespace std;
using namespace cv;

////////////////////////////////////////////////////////////////////////////
//
// Select most representative frames (thumbnails)
//
// Perform k-means++ (k=#thumbnails) over valid frames
// Thumbnails are selected by sorting clusters by their size and
//   selecting a frame from the longest subshot
//
////////////////////////////////////////////////////////////////////////////

void detect_thumbnail_frames( hecate_params& opt, hecate::video_metadata& meta,
                              const vector<hecate::ShotRange>& v_shot_range,
                              const Mat& X, const Mat& diff,
                              vector<int>& v_thumb_idx)
{
  v_thumb_idx.clear();

  const int minK = 5;   // min #clusters
  const int maxK = 30;  // max #clusters
  const int nfrm = meta.nframes;

  vector<bool> v_frm_valid(nfrm,false);
  for(size_t i=0; i<v_shot_range.size(); i++) {
    for(size_t j=0; j<v_shot_range[i].v_idx.size(); j++) {
      v_frm_valid[v_shot_range[i].v_idx[j]] = true;
    }
  }

  int nfrm_valid = accumulate(v_frm_valid.begin(),v_frm_valid.end(),0);
  if( nfrm_valid <= 1 ) {
    // If there's no valid frame, pick one most still frame
    int minidx=-1;
    double minval=numeric_limits<double>::max();
    for( int i=0; i<nfrm; i++ ) {
      double val = diff.at<double>(i);
      if( val<minval ) {
        minval = val;
        minidx = i;
      }
    }
    v_thumb_idx.push_back( minidx );
  }
  else if( nfrm_valid <= opt.njpg ) {
    // If not enough frames are left,
    // include all remaining keyframes sorted by shot length
    vector<int> v_shot_len;
    vector<int> v_keyfrm_idx;
    for(size_t i=0; i<v_shot_range.size(); i++) {
      int max_subshot_id=-1;
      int max_subshot_len=-1;
      for(size_t j=0; j<v_shot_range[i].v_range.size(); j++) {
        int shotlen = v_shot_range[i].v_range[j].length();
        if( shotlen>max_subshot_len ) {
          max_subshot_len = shotlen;
          max_subshot_id = j;
        }
      }
      v_shot_len.push_back(max_subshot_len);
      v_keyfrm_idx.push_back(v_shot_range[i].v_range[max_subshot_id].v_idx[0]);
    }

    // Include keyframes sorted by shot length
    vector<size_t> v_srt_idx;  // contains sorted indices
    vector<int> v_srt_val;     // contains sorted values
    hecate::sort( v_shot_len, v_srt_val, v_srt_idx );
    for(size_t i=0; i<v_srt_idx.size(); i++)
      v_thumb_idx.push_back( v_keyfrm_idx[v_srt_idx[v_srt_idx.size()-1-i]] );
  }
  else {
    vector<int> v_valid_frm_idx;
    vector<int> v_valid_frm_shotlen;
    for(size_t i=0; i<v_shot_range.size(); i++) {
      for(size_t j=0; j<v_shot_range[i].v_range.size(); j++) {
        v_valid_frm_idx.push_back( v_shot_range[i].v_range[j].v_idx[0] );
        v_valid_frm_shotlen.push_back( v_shot_range[i].v_range[j].length() );
      }
    }

    Mat km_data(nfrm_valid, X.cols, X.type());
    for(size_t i=0; i<v_valid_frm_idx.size(); i++) {
      X.row(v_valid_frm_idx[i]).copyTo( km_data.row(i) );
    }

    // Perform k-means (repeat 5 times)
    Mat km_lbl; // integer row vector; stores cluster IDs for every sample.
    Mat km_ctr; // one row per each cluster center.
    int km_k = min(maxK, min(nfrm_valid, max(minK, opt.njpg)));
    hecate::perform_kmeans( km_data, km_lbl, km_ctr, km_k, 5 );

    // For k-means with gap statistics
    //vector<int> Kset;
    //for(int i=km_k; i<=min(nfrm_valid,(int)(2*km_k)); i++)
    //  Kset.push_back( i );
    //km_k = hecate::perform_kmeans_gs( km_data, km_lbl, km_ctr, Kset, 3, 500 );

    // measure cluster size
    vector<int> clust_sz(km_k,0);
    for(int i=0; i<km_lbl.rows; i++)
      clust_sz[ km_lbl.at<int>(i) ] += v_valid_frm_shotlen[i];

    // sort wrt cluster size in an ascending order
    vector<size_t> v_srt_idx; // contains cluster id
    vector<int> v_srt_val;    // contains cluster size
    hecate::sort( clust_sz, v_srt_val, v_srt_idx );

    // obtain thumbnails -- the most still frame per cluster
    for(int i=0; i<km_k; i++) {
      int diff_min_idx = -1;
      double diff_min_val = numeric_limits<double>::max();
      for(int j=0; j<km_lbl.rows; j++) {
        if( km_lbl.at<int>(j) == v_srt_idx[km_k-i-1] ) {
          double mean_diff_j = diff.at<double>(v_valid_frm_idx[j]);
          if( mean_diff_j<diff_min_val ) {
            diff_min_idx = j;
            diff_min_val = mean_diff_j;
          }
        }
      }
      // Convert back to the real index
      v_thumb_idx.push_back( v_valid_frm_idx[diff_min_idx] );
    }
  }

  for(size_t i=0; i<v_thumb_idx.size(); i++)
    v_thumb_idx[i] *= opt.step_sz;
}



////////////////////////////////////////////////////////////////////////////
//
// Thumbnail generation
//
////////////////////////////////////////////////////////////////////////////
void generate_thumbnails( hecate_params& opt, vector<int>& v_thumb_idx )
{
  char strbuf[256];
  int njpg_cnt = 0;
  int frm_idx = 0;

  string filename = hecate::get_filename( std::string(opt.in_video) );

  VideoCapture vr( opt.in_video );
  double rsz_ratio = (double)(2+opt.jpg_width_px)/vr.get(CV_CAP_PROP_FRAME_WIDTH);
  while( njpg_cnt < (int)v_thumb_idx.size() )
  {
    Mat frm; vr>>frm;
    if( frm.empty() ) break;

    // Check if the current frame is in the selected thumbnail list
    int rank = -1;
    for( size_t i=0; i<v_thumb_idx.size(); i++ ) {
      if( frm_idx==v_thumb_idx[i] ) {
        rank = (int)i;
        break;
      }
    }

    // Save that thumbnail
    if( rank>=0 && rank<opt.njpg ) {
      resize( frm, frm, Size(), rsz_ratio, rsz_ratio, CV_INTER_LINEAR );
      frm = frm(Rect(0,0,frm.cols-2,frm.rows));
      sprintf( strbuf, "%s/%s_%02d.jpg",
              opt.out_dir.c_str(), filename.c_str(), rank );
      imwrite( strbuf, frm );
      njpg_cnt++;
    }

    if (njpg_cnt >= opt.njpg) {
        break;
    }

    frm_idx++;
  }
  vr.release();
}
</file>

<file path="src/hecate/video_parser.cpp">
/*
 * Video Parser
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#include "hecate/video_parser.hpp"

using namespace std;
using namespace cv;
using namespace hecate;

/*-----------------------------------------------------------------------*/
VideoParser::VideoParser()
/*-----------------------------------------------------------------------*/
{
  _debug = false;
  _display = false;
  
  _nfrm_total = 0;
  _nfrm_given = 0;
  
  _v_shot_ranges.clear();
}

/*-----------------------------------------------------------------------*/
void VideoParser::release_memory()
/*-----------------------------------------------------------------------*/
{
  _v_frm_rgb.clear();
  _v_frm_gray.clear();
}

/*-----------------------------------------------------------------------*/
vector<hecate::ShotRange> VideoParser::parse_video(const string& in_video,
                                                hecate::parser_params opt)
/*-----------------------------------------------------------------------*/
{
  _debug = opt.debug;
  
  int ret = read_video( in_video, opt.step_sz, opt.max_duration,
                       opt.ignore_rest );
  if( ret<0 ) {
    fprintf( stderr, "VideoParser: Failed to open input video: %s\n",
            in_video.c_str());
    return vector<hecate::ShotRange>();
  }
  
  // Record metadata
  meta.nframes  = _nfrm_total;
  meta.width    = _video_width;
  meta.height   = _video_height;
  meta.fps      = _video_fps;
  meta.duration = _video_sec;
  
  // Frame filtering
  if( opt.fltr_begin_sec>.0 || opt.fltr_end_sec>.0 )
    filter_heuristic(opt.fltr_begin_sec, opt.fltr_end_sec);
  
  if( opt.fltr_lq )
    filter_low_quality();
  
  filter_transition();
  
  // Extract feature representation
  extract_histo_features();
  
  // Post-process (break up shots if too long)
  double min_shot_len_sec = 2.0;
  post_process(min_shot_len_sec, opt.gfl);
  
  release_memory();
  
  // Store shot information
  update_shot_ranges();
  
  // Subshot detection; subshot info is stored during this step
  if( opt.fltr_rdt )
    filter_redundant_and_obtain_subshots();
  
  if( _display )
    play_video_filtered( in_video, 2, 360 );
  
  // Produce result
  return _v_shot_ranges;
}

/*------------------------------------------------------------------------
 Read input video and store as RGB and GRAY formats.
 ------------------------------------------------------------------------*/
int VideoParser::read_video( const string& in_video, int step_sz,
                            double max_duration, bool ignore_rest,
                            int max_frm_len)
/*-----------------------------------------------------------------------*/
{
  if( _debug )
    printf("VideoParser: read_video(\"%s\", \n\tstep_sz=%d, "
           "max_duration=%.2f, max_frm_len=%d, ignore_rest=%d)\n",
           in_video.c_str(), step_sz, max_duration, max_frm_len, ignore_rest);
  
  VideoCapture vr( in_video );
  if( !vr.isOpened() ) {
    return -1;
  }
  
  _nfrm_total   = vr.get(CV_CAP_PROP_FRAME_COUNT);
  _video_width  = vr.get(CV_CAP_PROP_FRAME_WIDTH);
  _video_height = vr.get(CV_CAP_PROP_FRAME_HEIGHT);
  _video_fps    = max(1.0, vr.get(CV_CAP_PROP_FPS));
  if( _video_fps!=_video_fps )
    _video_fps = 29.97;
  
  int max_nfrms = (max_duration<0)
  ? _nfrm_total : round(max_duration*_video_fps);
  
  // need to store _step_sz for computing min_shot_len in sbg_gflseg()
  _step_sz = step_sz;
  if( step_sz>10 ) {
    _step_sz = 10;
    fprintf( stderr, "VideoParser: The maximum step size is 10"
            " (provided is %d)\n", step_sz );
  }
  // if video is too long, and ignore_rest is false, adjust step size
  if( !ignore_rest && max_nfrms > 0 && _nfrm_total > max_nfrms ) {
    _step_sz = ceil( _nfrm_total/max_nfrms );
    fprintf( stderr, "VideoParser: Video too long (%d frames),"
            "increasing step size to %d\n", _nfrm_total, step_sz );
  }
  _step_sz = max(1, _step_sz);
  
  int maxlen = max( _video_width, _video_height );
  double rsz_ratio = (maxlen>max_frm_len)
  ? (double) max_frm_len / maxlen : -1.0;
  
  // Read RGB frames
  _nfrm_total=0; // reset because vr.get is known to be inaccurate
  while( true )
  {
    Mat frm;
    vr >> frm;
    if( frm.empty() ) break;
    
    if( _nfrm_total % _step_sz == 0 ) {
      if( rsz_ratio>0 )
        resize( frm, frm, Size(), rsz_ratio, rsz_ratio, CV_INTER_LINEAR );
      _v_frm_rgb.push_back( frm );
      
      // if video is too long, and ignore_rest is true, cut the rest
      if( ignore_rest && _nfrm_total>=max_nfrms ) {
        if( _debug )
          printf("VideoParser: video too long, "
                 "cutting at (%d)-th frame\n", _nfrm_total);
        break;
      }
    }
    _nfrm_total++;
  }
  vr.release();
  
  _nfrm_given = (int) _v_frm_rgb.size();
  _video_sec  = (double)_nfrm_total/_video_fps;
  
  // RGB2GRAY
  _v_frm_gray.assign( _nfrm_given, Mat() );
  
#pragma omp parallel for
  for( int i=0; i<_nfrm_given; i++ )
  {
    Mat frm_gray;
    cvtColor( _v_frm_rgb[i], frm_gray, CV_BGR2GRAY );
    GaussianBlur( frm_gray, frm_gray, Size(3,3), 0, 0 );
    frm_gray.copyTo( _v_frm_gray[i] );
  }
  
  _v_frm_valid.assign( _nfrm_given, true );
  _v_frm_log.assign( _nfrm_given, " " );
  
  _X_diff = Mat( _nfrm_given, 1, CV_64F, Scalar(0,0,0)[0] );
  _X_ecr  = Mat( _nfrm_given, 1, CV_64F, Scalar(0,0,0)[0] );
  
  return 0;
}


/*------------------------------------------------------------------------
 Manually invalidate first and last frames (heuristic)
 ------------------------------------------------------------------------*/
void VideoParser::filter_heuristic(double fltr_begin_sec, double fltr_end_sec)
/*-----------------------------------------------------------------------*/
{
  int fltr_begin_nfrms = ceil(fltr_begin_sec * _video_fps / (double)_step_sz);
  int fltr_end_nfrms = ceil(fltr_end_sec * _video_fps / (double)_step_sz);
  
  for(int i=0; i<fltr_begin_nfrms; i++)
    mark_invalid(_v_frm_valid, _v_frm_log, i, "[Begin]");
  for(int i=0; i<fltr_end_nfrms; i++)
    mark_invalid(_v_frm_valid, _v_frm_log, _nfrm_total-1-i, "[End]");
}


/*------------------------------------------------------------------------
 Use a collection of heuristics to filter out low-quality frames.
 ------------------------------------------------------------------------*/
void VideoParser::filter_low_quality( double thrsh_bright,
                                     double thrsh_sharp,
                                     double thrsh_uniform )
/*-----------------------------------------------------------------------*/
{
  // filter at most n percent of the total frames
  int nfrm_nperc = (int)(0.15*_nfrm_given);
  
  vector<double> v_brightness(_nfrm_given,0.0);
  vector<double> v_sharpness(_nfrm_given,0.0);
  vector<double> v_uniformity(_nfrm_given,0.0);
  
#pragma omp parallel for
  for( int i=0; i<_nfrm_given; i++ ) {
    v_brightness[i] = hecate::calc_brightness( _v_frm_rgb[i]  );
    v_sharpness[i]  = hecate::calc_sharpness(  _v_frm_gray[i] );
    v_uniformity[i] = hecate::calc_uniformity( _v_frm_gray[i] );
  }
  
  vector<size_t> v_srt_idx; // contains sorted indices
  vector<double> v_srt_val; // contains sorted values
  
  // DARK frame detection
  hecate::sort( v_brightness, v_srt_val, v_srt_idx );
  for( int i=0; i<nfrm_nperc; i++ )
    if( v_srt_val[i] <= thrsh_bright )
      mark_invalid(_v_frm_valid, _v_frm_log, v_srt_idx[i], "[Dark]");
  
  // BLURRY frame detection
  hecate::sort( v_sharpness, v_srt_val, v_srt_idx );
  for( int i=0; i<nfrm_nperc; i++ )
    if( v_srt_val[i] <= thrsh_sharp )
      mark_invalid(_v_frm_valid, _v_frm_log, v_srt_idx[i], "[Blurry]");
  
  // UNIFORM frame detection
  hecate::sort( v_uniformity, v_srt_val, v_srt_idx );
  for( int i=0; i<nfrm_nperc; i++ )
    if( v_srt_val[_nfrm_given-i-1] >= thrsh_uniform )
      mark_invalid(_v_frm_valid, _v_frm_log, v_srt_idx[_nfrm_given-i-1], "[Uniform]");
}


/*------------------------------------------------------------------------
 Frames around shot boundaries are usually low-quality, filter them out
 Use two SBD methods: frame-by-frame difference and ECR
 ------------------------------------------------------------------------*/
void VideoParser::filter_transition( double thrsh_diff, double thrsh_ecr )
/*-----------------------------------------------------------------------*/
{
  int nfrm_nperc = (int)(0.10*_nfrm_given); // n percent of the total frames
  
  vector<double> v_diff(_nfrm_given, 0.0);
  vector<double> v_ecr(_nfrm_given, 0.0);
  
  // sort wrt cluster size in an ascending order
  vector<size_t> v_srt_idx; // contains sorted indices
  vector<double> v_srt_val;    // contains sorted values
  
  // compute the first-order derivative frame-by-frame difference
  int img_sz = _v_frm_gray[0].cols * _v_frm_gray[0].rows;
#pragma omp parallel for
  for( int i=1; i<_nfrm_given-1; i++ ) {
    v_diff[i] = (double) (cv::norm( (_v_frm_rgb[i]-_v_frm_rgb[i-1]) )
                          + cv::norm( (_v_frm_rgb[i]-_v_frm_rgb[i+1]) )) / (2.0*img_sz);
    _X_diff.at<double>(i) = v_diff[i];
  }
  
  // compute edge-change-ratio (ECR)
  {
    int dl_sz = 5; // dilute size
    Mat dl_elm = getStructuringElement(MORPH_CROSS,
                                       Size(2*dl_sz+1, 2*dl_sz+1),
                                       Point(dl_sz, dl_sz));
    
    // Pre-compute edge & edge dilation
    vector<Mat> v_edge( _nfrm_given, Mat() );    // edge images
    vector<Mat> v_edge_dl( _nfrm_given, Mat() ); // edge-diluted images
    
#pragma omp parallel for
    for(int i=0; i<_nfrm_given; i++)
    {
      Mat tmp;
      double theta = threshold(_v_frm_gray[i],tmp,0,255,CV_THRESH_BINARY|CV_THRESH_OTSU);
      Canny( _v_frm_gray[i], v_edge[i], theta, 1.2*theta);
      dilate( v_edge[i], v_edge_dl[i], dl_elm );
      v_edge[i] -= 254; v_edge_dl[i] -= 254;
    }
    
    // Transition detection using ECR (edge change ratio)
#pragma omp parallel for
    for(int i=1; i<_nfrm_given; i++)
    {
      double rho_out, rho_in;
      rho_out = 1.0 - min(1.0,sum(v_edge[i-1].mul(v_edge_dl[i]))[0]/max(1e-6,sum(v_edge[i-1])[0]));
      rho_in  = 1.0 - min(1.0,sum(v_edge_dl[i-1].mul(v_edge[i]))[0]/max(1e-6,sum(v_edge[i-1])[0]));
      
      v_ecr[i] = max(rho_out,rho_in); // edge change ratio
      _X_ecr.at<double>(i) = v_ecr[i];
    }
  }
  
  // CUT detection
  hecate::sort( v_diff, v_srt_val, v_srt_idx );
  for( int i=0; i<nfrm_nperc; i++ )
    if( v_srt_val[_nfrm_given-i-1] >= thrsh_diff )
      mark_invalid(_v_frm_valid, _v_frm_log, v_srt_idx[_nfrm_given-i-1], "[Cut]" );
  
  // TRANSITION detection (cut, fade, dissolve, wipe)
  hecate::sort( v_ecr, v_srt_val, v_srt_idx );
  for( int i=0; i<nfrm_nperc; i++ )
    if( v_srt_val[_nfrm_given-i-1] >= thrsh_ecr )
      mark_invalid(_v_frm_valid, _v_frm_log, v_srt_idx[_nfrm_given-i-1], "[ECR]" );
}



/*------------------------------------------------------------------------
 Perform change point detection either by solving group-fused LASSO of
 "The group fused Lasso for multiple change-point detection" (2011) by
 Kevin Bleakley and Jean-Philippe Vert, or by using heuristics
 -----------------------------------------------------------------------*/
void VideoParser::post_process(double min_shot_sec, bool gfl)
/*-----------------------------------------------------------------------*/
{
  hecate::Segmenter seg;
  int start_idx=-1, end_idx=-1, shotlen=-1;
  int min_shot_len = min_shot_sec * _video_fps / _step_sz;
  int max_shot_len = 3 * min_shot_len;
  double thrsh_gfl = 0.25;
  
  for( size_t i=0; i<_v_frm_valid.size(); i++ )
  {
    if( start_idx<0 && _v_frm_valid[i] ) {
      start_idx = i;
    }
    if( start_idx>=0 && (!_v_frm_valid[i] || i+1==_v_frm_valid.size()) )
    {
      end_idx = i;
      shotlen = end_idx-start_idx+1;
      if( shotlen >= max_shot_len )
      {
        int njumps = floor(shotlen/min_shot_len);
        vector<int> jump;
        
        // Solve group-fused LASSO
        if( gfl ) {
          Mat Xsub( shotlen, _X_feat.cols, _X_feat.type() );
          for( int r=start_idx; r<=end_idx; r++ ) {
            _X_feat.row(r).copyTo( Xsub.row(r-start_idx) );
          }
          Xsub.convertTo(Xsub,CV_64F);
          
          seg.gflseg( Xsub, jump, njumps, thrsh_gfl );
        }
        // Use heuristics
        else {
          vector<double> v_diff;
          for(int i=start_idx; i<=end_idx; i++) {
            v_diff.push_back( _X_diff.at<double>(i) );
          }
          sbd_heuristic( v_diff, jump, njumps, min_shot_len );
        }
        
        for(size_t k=0; k<jump.size(); k++) {
          mark_invalid(_v_frm_valid, _v_frm_log, start_idx+jump[k]-1, "[GFL]" );
          mark_invalid(_v_frm_valid, _v_frm_log, start_idx+jump[k], "[GFL]" );
        }
        
        if( _debug )
          printf("segmenter: %s (seqlen=%d (%d:%d),"
                 "nJumpsEst=%d, nJumps=%d, theta=%.2f)\n",
                 (gfl) ? "gflseg" : "heuristic",  shotlen, start_idx, end_idx,
                 njumps, (int)jump.size(), thrsh_gfl);
        
      }
      start_idx = end_idx = -1;
    }
  }
}

/*-----------------------------------------------------------------------*/
void VideoParser::sbd_heuristic(vector<double> v_diff, vector<int>& jump,
                                int njumps, int min_shot_len )
/*-----------------------------------------------------------------------*/
{
  vector<size_t> v_srt_idx;
  vector<double> v_srt_val; // contains sorted values
  hecate::sort( v_diff, v_srt_val, v_srt_idx );
  for(int i=(int)v_srt_val.size()-1; i>=0; i--) {
    bool add = true;
    if (((unsigned) v_srt_idx[i] + 1 < min_shot_len) ||
        ((unsigned) v_diff.size() - v_srt_idx[i] < min_shot_len)) {
      add = false;
    } else {
      for (size_t j = 0; j < jump.size(); j++) {
        int len = abs(jump[j] - (int) v_srt_idx[i]) + 1;
        if (len < min_shot_len) {
          add = false;
          break;
        }
      }
    }
    if( add ) {
      jump.push_back( (int)v_srt_idx[i] );
    }
    if( (int)jump.size() == njumps ) {
      break;
    }
  }
};

/*-----------------------------------------------------------------------*/
void VideoParser::extract_histo_features(int pyr_level, bool omit_filtered,
                                         int nbin_color, int nbin_edge_ori,
                                         int nbin_edge_mag)
/*-----------------------------------------------------------------------*/
{
  int npatches = 0;
  for(int l=0; l<pyr_level; l++)
    npatches += pow(4,l);
  
  int nbin_edge = nbin_edge_ori + nbin_edge_mag;
  Mat X_color_hist = Mat( npatches*3*nbin_color, _nfrm_given, CV_32F, Scalar(0,0,0)[0] );
  Mat X_edge_hist  = Mat( npatches*nbin_edge, _nfrm_given, CV_32F, Scalar(0,0,0)[0] );
  
#pragma omp parallel for
  for(int i=0; i<_nfrm_given; i++)
  {
    if( omit_filtered && !_v_frm_valid[i] ) continue;
    
    Mat color_hist;
    hecate::calc_pyr_color_hist( _v_frm_rgb[i], color_hist, nbin_color, pyr_level );
    color_hist.copyTo( X_color_hist.col(i) );
    
    Mat edge_hist;
    hecate::calc_pyr_edge_hist( _v_frm_gray[i], edge_hist, nbin_edge_ori, nbin_edge_mag, pyr_level );
    edge_hist.copyTo( X_edge_hist.col(i) );
    
  }
  
  // Transpose X_gray/edge_hist, X_hist = horzcat( X_color_hist, X_edge_hist )
  X_color_hist = X_color_hist.t();
  X_edge_hist = X_edge_hist.t();
  hconcat( X_color_hist, X_edge_hist, _X_feat );
}


/*-----------------------------------------------------------------------*/
void VideoParser::filter_redundant_and_obtain_subshots()
/*-----------------------------------------------------------------------*/
{
  if( _v_shot_ranges.empty() )
    update_shot_ranges();
  
  // Generate data matrix for kmeans, consider only valid frames
  int nfrm_valid = get_nfrm_valid();
  if( nfrm_valid==0 ) {
    return;
  }

  Mat km_data( nfrm_valid, _X_feat.cols, _X_feat.type() );
  vector<int> v_idxmap( nfrm_valid, 0 );
  
  int row=0;
  for(int i=0; i<_nfrm_given; i++)
  {
    if( _v_frm_valid[i] ) {
      _X_feat.row(i).copyTo(km_data.row(row));
      v_idxmap[row] = i;
      row++;
    }
  }
  
  //
  // Perform k-means
  int ncluster = min(nfrm_valid/2, (int)_v_shot_ranges.size());
  Mat km_lbl; // integer row vector; stores cluster IDs for every sample.
  Mat km_ctr; // One row per each cluster center.
  hecate::perform_kmeans( km_data, km_lbl, km_ctr, ncluster );
  
  //
  // convert km_lbl to v_frm_clusterid
  vector<int> v_frm_clusterid(_nfrm_given,-1);
  for(int i=0; i<km_lbl.rows; i++)
    v_frm_clusterid[ v_idxmap[i] ] = km_lbl.at<int>(i);
  
  //
  // Pick the most "still" frame from every sub-shot within each shot
  for(size_t shotid=0; shotid<_v_shot_ranges.size(); shotid++)
  {
    int sb0 = _v_shot_ranges[shotid].start;
    int sb1 = _v_shot_ranges[shotid].end;
    
    // Identify sub-shots (per kmeans result)
    int ssb0=-1, ssb1=-1, lbl=-1;
    for( int j=sb0; j<=sb1; j++ )
    {
      if( _v_frm_valid[j] ) {
        if( ssb0<0 ) { // enter a new sub-shot area
          ssb0 = j;
          lbl = v_frm_clusterid[j];
        }
        ssb1 = j;
      }
      if( ssb0>=0 && (v_frm_clusterid[j]!=lbl || j==sb1) )  // exit the current sub-shot area
      {
        int diff_min_idx=-1;
        double diff_min_val = numeric_limits<double>::max();
        for( int k=ssb0; k<=ssb1; k++ )
        {
          double diff_k = _X_diff.at<double>(k);
          if( diff_k < diff_min_val )
          {
            diff_min_idx = k;
            diff_min_val = diff_k;
          }
        }
        
        // Store subshot with keyframe index
        hecate::Range r(ssb0, ssb1);
        r.v_idx.push_back( diff_min_idx );
        _v_shot_ranges[shotid].v_idx.push_back( diff_min_idx );
        _v_shot_ranges[shotid].v_range.push_back( r );
        
        // Filter out redundant frames
        for( int k=ssb0; k<=ssb1; k++ )
          if( k!=diff_min_idx )
            mark_invalid(_v_frm_valid, _v_frm_log, k, "[Redundant]");
        
        // reset sub-shot area
        ssb0 = ssb1 = lbl = -1;
      }
    }
    
    // reset shot area
    sb0 = sb1 = -1;
  }
}


/*-----------------------------------------------------------------------*/
void VideoParser::update_shot_ranges( int min_shot_len )
/*-----------------------------------------------------------------------*/
{
  _v_shot_ranges.clear();
  
  int sb0=0, sb1=-1;
  for( int i=0; i<_nfrm_given; i++ )
  {
    if( _v_frm_valid[i] ) {
      // enter a new shot area
      if( sb0<0 ) sb0 = i;
      sb1 = i;
    }
    
    // exit the current shot area
    if( sb0>=0 && sb1>=0 && (!_v_frm_valid[i] || i+1==_nfrm_given) )
    {
      hecate::ShotRange r( sb0, sb1 );
      if( r.length()>min_shot_len ) {
        _v_shot_ranges.push_back( r );
      }
      else {
        for(int j=sb0; j<=sb1; j++ )
          mark_invalid( _v_frm_valid, _v_frm_log, j, "[Short]" );
      }
      sb0 = sb1 = -1;
    }
  }
}


/*-----------------------------------------------------------------------*/
int VideoParser::get_nfrm_valid()
/*-----------------------------------------------------------------------*/
{
  return (int) accumulate( _v_frm_valid.begin(), _v_frm_valid.end(), 0 );
}


/*-----------------------------------------------------------------------*/
void VideoParser::mark_invalid( vector<bool>& vec, int idx, int wnd_sz )
/*-----------------------------------------------------------------------*/
{
  int vec_len = (int)vec.size();
  for(int i=max(0,idx-wnd_sz); i<=min(vec_len-1,idx+wnd_sz); i++) {
    vec[i] = false;
  }
}

/*-----------------------------------------------------------------------*/
void VideoParser::mark_invalid( vector<bool>& vec, vector<string>& vec2,
                               int idx, const string msg, int wnd_sz )
/*-----------------------------------------------------------------------*/
{
  int vec_len = (int)vec.size();
  for(int i=max(0,idx-wnd_sz); i<=min(vec_len-1,idx+wnd_sz); i++) {
    vec[i] = false;
    vec2[i] = msg;
  }
}



/*-----------------------------------------------------------------------*/
void VideoParser::play_video_filtered( const string& in_video,
                                      int step_sz, int max_frm_len )
/*-----------------------------------------------------------------------*/
{
  printf("\nDebug mode: Displaying shot segmentation results...\n");
  
  // Debug visualization
  const char* WND = "DEBUG";
  namedWindow( WND ,1 );
  
  Mat frm;
  double debug_rsz_ratio = (double)max_frm_len/_video_width;
  
  VideoCapture vr( in_video );
  vr >> frm;
  resize( frm, frm, Size(), debug_rsz_ratio, debug_rsz_ratio, CV_INTER_LINEAR );
  vr.set( CV_CAP_PROP_POS_FRAMES, 0 );
  
  Size sz = frm.size();
  Mat frm_lr( sz.height, 2*sz.width, CV_8UC3 );
  Mat frm_l(frm_lr, Rect(0,0,sz.width,sz.height));
  Mat frm_r(frm_lr, Rect(sz.width,0,sz.width,sz.height));
  frm_lr.setTo(Scalar(0));
  
  for( int i=0; i<_nfrm_given; i++)
  {
    for( int j=0; j<step_sz; j++ ) {
      vr >> frm;
      if( frm.empty() ) break;
    }
    if( frm.empty() ) break;
    resize( frm, frm, Size(), debug_rsz_ratio, debug_rsz_ratio, CV_INTER_LINEAR );
    
    std::stringstream s;
    s << _v_frm_log[i];
    putText(frm, s.str(), Point2f(5,30), FONT_HERSHEY_PLAIN, 1.3, Scalar(255,0,255,255), 2);
    
    if( _v_frm_log[i].length()<2 ) {
      frm.copyTo( frm_l );
    }
    else {
      frm.copyTo( frm_r );
    }
    
    imshow( WND, frm_lr );
    if( waitKey(_video_fps)>=0 ) break;
  }
  vr.release();
  destroyWindow( WND );
}
</file>

<file path="include/hecate/hecate.hpp">
/*
 * HECTATE Video Processing Library
 *
 * Copyright 2016 Yahoo Inc.
 * Licensed under the terms of the Apache 2.0 License.
 * See LICENSE file in the project root for terms.
 *
 * Developer: Yale Song (yalesong@yahoo-inc.com)
 */

#ifndef HECATE_HPP
#define HECATE_HPP

#include <stdio.h>
#include <stdlib.h>
#include <dirent.h>
#include <getopt.h>
#include <sys/stat.h> // mkdir
#include <unistd.h>   // access() function

#include <ctime>      // display date and time
#include <iostream>   // for standard I/O
#include <fstream>    // for file I/O
#include <string>     // for strings
#include <iomanip>    // for controlling float print precision
#include <sstream>    // string to number conversion
#include <chrono>
#include <limits>
#include <numeric>

// OpenMP library
#if defined(_OPENMP)
#include <omp.h>
#endif

// Hecate headers
#include "hecate/sort.hpp"
#include "hecate/time.hpp"
#include "hecate/gapstat.hpp"
#include "hecate/knapsack.hpp"
#include "hecate/cc_parser.hpp"
#include "hecate/file_helper.hpp"
#include "hecate/video_parser.hpp"
#include "hecate/ffmpeg_helper.hpp"

// OpenCV library
#include <opencv2/objdetect/objdetect.hpp>
#include <opencv2/ml/ml.hpp>

using namespace std;

// program options
struct hecate_params {
  string in_video;
  string out_dir;
  string caption;
  int step_sz;          // frame subsampling step size
  int njpg;             // number of thumbnail images
  int ngif;             // number of GIFs
  int lmov;             // length of video summary (in seconds)
  int gif_fps;          // gif play speed
  int jpg_width_px;     // thumbnail image width
  int gif_width_px;     // animated GIF width
  int mov_width_px;     // summary video width
  int max_duration;     // maximum length of video to process (in seconds)
  double fltr_begin_sec;// always filter out x-second frames at the beginning
  double fltr_end_sec;  // always filter out x-second frames at the end
  double invalid_wnd;   // window for dropping neighbor frames of low-quality ones
  bool jpg;             // generate thumbnail jpg
  bool gif;             // generate summary gif
  bool mov;             // generate summary movie
  bool gifsum;          // if enabled, combine individual GIFs into one summary
  bool gifall;          // generate all possible gifs (for debugging purpose)
  bool info_shot;       // print shot boundary info
  bool info_keyfrm;     // print key frame indices
  bool prefer_dynamic;  // if enabled, prefer dynamic scene in highlight
  bool gfl;             // run group-fused lasso as part of shot segmentation
  bool fade;            // disable fade-in/out during shot transition
  bool debug;
  bool display;
  
  hecate_params():
  out_dir("./output"),
  caption(""),
  step_sz(1),
  njpg(5),
  ngif(5),
  lmov(15),
  gif_fps(8),
  jpg_width_px(360),
  gif_width_px(360),
  mov_width_px(360),
  max_duration(-1),
  fltr_begin_sec(-1.0),
  fltr_end_sec(-1.0),
  invalid_wnd(0.15),
  jpg(false),
  gif(false),
  mov(false),
  gifsum(false),
  gifall(false),
  info_shot(false),
  info_keyfrm(false),
  prefer_dynamic(true),
  gfl(false),
  fade(false),
  debug(false),
  display(false)
  {};
};

inline void hecate_parse_params(int argc, char** argv, hecate_params& opt)
{
  static struct option long_options[] = {
    {"in_video",        required_argument, 0, 'i'},
    {"out_dir",         required_argument, 0, 'o'},
    {"step",            required_argument, 0, 's'},
    {"njpg",            required_argument, 0, 'n'},
    {"ngif",            required_argument, 0, 'q'},
    {"lmov",            required_argument, 0, 'l'},
    {"gif_fps",         required_argument, 0, 'f'},
    {"jpg_width_px",    required_argument, 0, 'u'},
    {"gif_width_px",    required_argument, 0, 'v'},
    {"mov_width_px",    required_argument, 0, 'w'},
    {"max_duration",    required_argument, 0, 'd'},
    {"fltr_begin_sec",  required_argument, 0, 'a'},
    {"fltr_end_sec",    required_argument, 0, 'b'},
    {"invalid_wnd",     required_argument, 0, 'k'},
    {"generate_jpg",      no_argument, 0, 'J'},
    {"generate_gif",      no_argument, 0, 'G'},
    {"generate_mov",      no_argument, 0, 'M'},
    {"optimize_gif",      no_argument, 0, 'O'},
    {"generate_gifsum",   no_argument, 0, 'S'},
    {"generate_gifall",   no_argument, 0, 'A'},
    {"print_shot_info",   no_argument, 0, 'T'},
    {"print_keyfrm_info", no_argument, 0, 'K'},
    {"prefer_dynamic",    no_argument, 0, 'V'},
    {"gfl",               no_argument, 0, 'B'},
    {"fade",              no_argument, 0, 'F'},
    {"debug",             no_argument, 0, 'D'},
    {"display",           no_argument, 0, 'C'},
    {0,0,0,0}
  };
  
  while( true ) {
    int opt_idx=0;
    int c = getopt_long( argc, argv,
                        "0:1:2:3:4:5:6:7:8:9:"
                        "a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:"
                        "A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z",
                        long_options, &opt_idx);
    if( c==-1 ) break;
    switch( c ) {
      case 'i': opt.in_video         = optarg; break;
      case 'o': opt.out_dir          = optarg; break;
      case 's': opt.step_sz          = atoi(optarg); break;
      case 'n': opt.njpg             = atoi(optarg); break;
      case 'q': opt.ngif             = atoi(optarg); break;
      case 'l': opt.lmov             = atoi(optarg); break;
      case 'f': opt.gif_fps          = atoi(optarg); break;
      case 'u': opt.jpg_width_px     = atoi(optarg); break;
      case 'v': opt.gif_width_px     = atoi(optarg); break;
      case 'w': opt.mov_width_px     = atoi(optarg); break;
      case 'd': opt.max_duration     = atof(optarg); break;
      case 'a': opt.fltr_begin_sec   = atof(optarg); break;
      case 'b': opt.fltr_end_sec     = atof(optarg); break;
      case 'k': opt.invalid_wnd      = atof(optarg); break;
      case 'J': opt.jpg              = true; break;
      case 'G': opt.gif              = true; break;
      case 'M': opt.mov              = true; break;
      case 'S': opt.gifsum = opt.gif = true; break;
      case 'A': opt.gifall = opt.gif = true; break;
      case 'T': opt.info_shot        = true; break;
      case 'K': opt.info_keyfrm      = true; break;
      case 'V': opt.prefer_dynamic   = true; break;
      case 'B': opt.gfl              = true; break;
      case 'F': opt.fade             = true; break;
      case 'D': opt.debug            = true; break;
      case 'C': opt.display          = true; break;
    }
  }
  
  // Create output dir (silently fails if dir already exists)
  mkdir( opt.out_dir.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH );
}



inline void hecate_copyright()
{
  printf("\n");
  printf("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n");
  printf(" HECATE Copyright 2016 Yahoo Inc.\n");
  printf("   Licensed under the terms of the Apache 2.0 License.\n");
  printf("   Developed by : Yale Song (yalesong@yahoo-inc.com)\n");
  printf("   Built on  : %s %s\n", __TIME__, __DATE__ );
  printf("-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\n");
}

inline void hecate_usage()
{
  hecate_params opt;
  printf("USAGE: hecate -i infile [options]\n");
  printf("\n");
  printf("  -i  --in_video      (string)    Input video file\n");
  printf("  -o  --out_dir       (string)    Output directory (%s)\n", opt.out_dir.c_str());
  printf("  -s  --step          (int)       Frame subsampling step size (%d)\n", opt.step_sz);
  printf("  -n  --njpg          (int)       Number of thumbnails to be generated (%d)\n", opt.njpg);
  printf("  -q  --ngif          (int)       Number of GIFs to be generated (%d)\n", opt.ngif);
  printf("  -r  --lmov          (int)       Length of video summary to be generated (in seconds) (%d)\n", opt.lmov);
  printf("  -u  --jpg_width_px  (int)       Pixel width of thumbnail images (%d)\n", opt.jpg_width_px);
  printf("  -v  --gif_width_px  (int)       Pixel width of animated GIFs (%d)\n", opt.gif_width_px);
  printf("  -w  --mov_width_px  (int)       Pixel width of summary video (%d)\n", opt.mov_width_px);
  printf("  --generate_jpg                  Generate thumbnail images\n");
  printf("  --generate_gif                  Generate animated GIFs\n");
  printf("  --generate_mov                  Generate a summary video\n");
  printf("  --generate_gifsum               Generate animated GIFs summary\n");
  printf("  --generate_gifall               Generate all possible animated GIFs\n");
  printf("  --print_shot_info               Print valid shot ranges\n");
  printf("  --print_keyfrm_info             Print keyframe indices\n");
  
  exit(-1);
}



/*******************************************************************************
 
 HECTATE INTERFACE
 
 INPUT:
 hecate_params opt : input option paramaters
 
 OUTPUT:
 vector<int> v_thumb_idx : thumbnail frame indices
 vector<hecate::Range> v_gif_range : highlight shot ranges for GIF creation
 vector<hecate::Range> v_mov_range : highlight shot ranges for video summarization
 
 *******************************************************************************/
void run_hecate( hecate_params& opt,
                 vector<int>& v_thumb_idx,
                 vector<hecate::Range>& v_gif_range,
                 vector<hecate::Range>& v_mov_range );

inline void run_hecate( hecate_params& opt, vector<int>& v_thumb_idx) {
  vector<hecate::Range> v_gif_range, v_mov_range;
  run_hecate( opt, v_thumb_idx, v_gif_range, v_mov_range );
}

inline void run_hecate( hecate_params& opt, vector<hecate::Range>& v_range) {
  vector<int> v_thumb_idx;
  vector<hecate::Range> v_xxx_range;
  
  if( opt.gif )
    run_hecate( opt, v_thumb_idx, v_range, v_xxx_range );
  else if( opt.mov )
    run_hecate( opt, v_thumb_idx, v_xxx_range, v_range );
}


/*******************************************************************************
 
 THUMBNAIL IMAGE GENERATION MODULE
 
 INPUT:
 hecate_params opt        : input option paramaters
 video_metadata meta      : video metadata
 vector<hecate::ShotRanges> v_shot_range
                          : shot boundaries
 const Mat& X             : input features
 const Mat& diff          : n-by-1 vector of frame-by-frame difference scores
 
 OUTPUT:
 vector<int> v_thumb_idx  : vector of frame index numbers for thumbnails
 
 *******************************************************************************/

void detect_thumbnail_frames( hecate_params& opt,
                              hecate::video_metadata& meta,
                              const vector<hecate::ShotRange>& v_shot_range,
                              const Mat& X,
                              const Mat& diff,
                              vector<int>& v_thumb_idx);

void generate_thumbnails( hecate_params& opt, vector<int>& v_thumb_idx );




/*******************************************************************************
 
 VIDEO SUMMARIZATION MODULE
 
 INPUT:
 hecate_params opt        : input option paramaters
 video_metadata meta      : video metadata
 vector<hecate::ShotRanges> v_shot_range
                          : shot boundaries
 const Mat& X             : input features
 const Mat& diff          : n-by-1 vector of frame-by-frame difference scores
 
 OUTPUT:
 vector<hecate::Ranges> v_highlight_range
                          : vector of highlight shot ranges
 
 *******************************************************************************/

void detect_highlight_shots( hecate_params& opt,
                             hecate::video_metadata& meta,
                             const vector<hecate::ShotRange>& v_shot_range,
                             const Mat& X,
                             const Mat& diff,
                             vector<hecate::Range>& v_highlight_range );

void generate_highlight_clips( hecate_params& opt,
                               vector<hecate::Range>& v_highlight_range );


////////////////////////////////////////////////////////////////////////////////
//
// VARIOUS HELPER FUNCTIONS
//
////////////////////////////////////////////////////////////////////////////////


inline void mark_invalid( vector<bool>& vec, int idx, int wnd_sz=0 )
{
  int vec_len = (int)vec.size();
  for(int i=max(0,idx-wnd_sz); i<=min(vec_len-1,idx+wnd_sz); i++)
    vec[i] = false;
}

inline void expand_invalid_frms( vector<bool>& valid, int k )
{
  vector<bool> valid_new = valid;
  
  int nfrm = (int) valid.size();
  for( int pos=1; pos<nfrm-1; pos++ )
  {
    if( !valid[pos] )
      for(int i=max(0,pos-k); i<=min(nfrm-1,pos+k); i++)
        valid_new[i] = false;
  }
  
  valid = valid_new;
}


#endif
</file>

<file path="README.md">
# HECATE
Hecate [hek-uh-tee] is a video processing library that auto-magically generates thumbnails, animated GIFs, and video summaries from videos. This library is developed and maintained by Yahoo Research, New York.

The source code is Copyright 2016 Yahoo Inc. and is licensed under the terms of the Apache 2.0 License. See the [LICENSE](https://github.com/yahoo/hecate/blob/master/LICENSE) in the project root file for terms.

The technology behind this library is based on our research work. If you find this library useful in your work, we ask you to cite our research paper:
```
"To Click or Not To Click: Automatic Selection of Beautiful Thumbnails from Videos."
Yale Song, Miriam Redi, Jordi Vallmitjana, Alejandro Jaimes, 
Proceedings of the 25th ACM International on Conference on Information and Knowledge Management, CIKM 2016
```

## Installation
Hecate has one dependency: [OpenCV library](https://github.com/opencv/opencv) with an [FFMPEG](https://github.com/FFmpeg/FFmpeg) support. You will need to install the library properly before trying out Hecate!

Once you install the dependenct library correctly, follow the instruction below:
```
$ git clone https://github.com/yahoo/hecate.git
$ cd hecate
$ vim Makefile.config
 - Set INCLUDE_DIRS and LIBRARY_DIRS to where your 
   opencv library is installed. Usually under /usr/local.
 - If your OpenCV version is 2.4.x, comment out the line 
   OPENCV_VERSION := 3
 - Save and exit
$ make all
$ make distribute
```

Once you've successfully compiled hecate, it will generate a binary executable under `distribute/bin/`. Run the following command to check if everything works properly:
```
$ ./distribute/bin/hecate

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
 HECATE Copyright 2016 Yahoo Inc.
   Licensed under the terms of the Apache 2.0 License.
   Developed by : Yale Song (yalesong@yahoo-inc.com)
   Built on  : 11:46:03 Aug 11 2016
-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
USAGE: hecate -i infile [options]

  -i  --in_video      (string)    Input video file
  -o  --out_dir       (string)    Output directory (./output)
  -s  --step          (int)       Frame subsampling step size (1)
  -n  --njpg          (int)       Number of thumbnails to be generated (5)
  -q  --ngif          (int)       Number of GIFs to be generated (5)
  -r  --lmov          (int)       Length of video summary to be generated (in seconds) (15)
  -u  --jpg_width_px  (int)       Pixel width of thumbnail images (360)
  -v  --gif_width_px  (int)       Pixel width of animated GIFs (360)
  -w  --mov_width_px  (int)       Pixel width of summary video (360)
  --generate_jpg                  Generate thumbnail images
  --generate_gif                  Generate animated GIFs
  --generate_mov                  Generate a summary video
  --generate_gifsum               Generate animated GIFs summary
  --generate_gifall               Generate all possible animated GIFs
  --print_shot_info               Print shot boundary detection results
  --print_keyfrm_info             Print keyframe indices
```

Congratulations! You have successfully installed hecate!


## Get started
In order to get started, we will need a video file to play with. In this example, we will use the video ["The Spirit of '43" by Walt Disney](https://archive.org/details/TheSpiritOf43_56) from [The Internet Archive](https://archive.org). 

Let's download the video and save it as `examples/video.mp4`:
```
$ wget https://archive.org/download/TheSpiritOf43_56/The_Spirit_of__43_512kb.mp4 \
  --output-document examples/video.mp4 --no-check-certificate
```

Hecate provides three main functionalities through a binary executable `hecate`: Thumbnail extraction, GIF generation, and video summarization. There are various other functionalities the library provides, such as shot boundary detection and keyframe extraction. 

We will explain each case below.

### Shot boundary detection and keyframe extraction
Shot boundary detection and keyframe extraction are often the first steps towards various video processing methods. With Hecate, obtaining shot and keyframe information is easier than ever! Simply run the following command to get the result:
```
$ ./distribute/bin/hecate -i examples/video.mp4 --print_shot_info  --print_keyfrm_info
```

Below is the results we obtained on our dev machine (OS X 10.10 with OpenCV v3.1):
```
shots: [0:81],[84:93],[96:102],[108:270],[272:418],...,[9966:10131],[10135:10164]
keyframes: [52,85,98,128,165,208,242,259,265,273,...,10127,10141]
```
The units are frame indices (zero-based). You will notice that shot ranges are non-continuous; there are "gaps" between shots, e.g., two frames are missing between the first two shots [0:81] and [84:93]. This is normal and intentional: Hecate discards low-quality frames that aren't ideal in producing nicely looking thumbnails, animated GIFs, and video summaries. We refer to our CIKM 2016 paper for the rational behind our reason to invalidate low-quality frames.

### Thumbnail generation
Hecate uses computer vision to determine frames that are most "suitable" as video thumbnails. By suitable, we mean a frame that is the most relevant to the video content and that is the most beautiful in terms of computational aesthetics; technical details are explained in our CIKM 2016 paper.

You can generate thumbnail images using Hecate. Run the following command to generate one thumbnail image from the video.
```
$ ./distribute/bin/hecate -i examples/video.mp4 --generate_jpg --njpg 1
```
You will see the generated thumbnail image under the output directory (set as `output` by default; you can change this using the option `--out_dir YOUR_DIRECTORY`). On our dev machine we get this thumbnail image:

![alt text](https://github.com/yahoo/hecate/blob/master/examples/video_00.jpg "Hecate Thumbnail Image")

In the above example, we generated only one thumbnail image. Are you not satisfied with the thumbnail image? Hecate can generate any number of thunbmail images! Let's generate five thumbnail images.
```
$ ./distribute/bin/hecate -i examples/video.mp4 --generate_jpg --njpg 3
```

The output files are named `<video_filename>_<rank>.jpg`. The files are ranked by their quality (rank 0 means it's the best one).

### Animated GIF generation
Do you want to create animated GIFs from a video without the hassle of using manual tools? Hecate can automatically create them for you! Run the following command to create one animated GIF from the video.
```
$ ./distribute/bin/hecate -i examples/video.mp4 --generate_gif --ngif 1
```
On our dev machine, we get this animated GIF:

![alt text](https://github.com/yahoo/hecate/blob/master/examples/video_00.gif "Hecate Animated GIF")

You can, of course, create more than just one GIF by setting the paramter `--ngif N` with an appropriate number N. When there are multiple GIFs, you can also generate a "summary GIF" by concatenating them, using this command:
```
$ ./distribute/bin/hecate -i examples/video.mp4 --generate_gif --ngif 3 --generate_gifsum
```

If you'd rather want to obtain all available GIFs from the video, use the following command: 
```
$ ./distribute/bin/hecate -i examples/video.mp4 --generate_gifall
```

### Video summary generation
Last but not least, Hecate can summarize a video! Run the following command to create a video summary of length 15 seconds.
```
$ ./distribute/bin/hecate -i examples/video.mp4 --generate_mov --lmov 15
```
We included the video summary generated on our dev machine here: 
[https://github.com/yahoo/hecate/blob/master/examples/video_sum.mp4](https://github.com/yahoo/hecate/blob/master/examples/video_sum.mp4)


## Developer

Yale Song: [github](https://github.com/yalesong), [website](http://people.csail.mit.edu/yalesong)
</file>

</files>
